#+TITLE:Mastering Emacs Notes
#+AUTHOR:WLHarvey4
#+DATE:2018-12-04
#+VERSION:0.0.1
#+TEXINFO_FILENAME:mastering.info
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+SUBTITLE:Notes and Outine
#+SUBAUTHOR:
#+TEXINFO_DIR_CATEGORY:Emacs
#+TEXINFO_DIR_TITLE:Mastering
#+TEXINFO_DIR_DESC:notes about mastering Emacs
#+TEXINFO_PRINTED_TITLE:Mastering Emacs
* Overview
** In The Beginning
   + Emacs began in 1976 [[https://www.gnu.org/software/emacs/manual/html_mono/efaq. html#Origin-of-the-term-Emacs]]
   + Came from an editor called Teco
** Some Implementations
:CP:
#+CINDEX: xemacs
#+CINDEX: sxemacs
:END:
   + XEmacs fork
     - [[http://www.xemacs.org]]
     - [[https://www.jwz.org/doc/lemacs.html]]
   + SXEmacs fork of XEmacs
     - [[http://www.sxemacs.org]]
   + and Gnu Emacs
     - [[https://www.gnu.org/software/emacs/]]
** Starter Packages
:CP:
#+CINDEX: starter packages
#+CINDEX: packages, starter
:END:
*** Steve Purcell’s .emacs.d
:CP:
#+CINDEX:Steve Purcell @code{.emacs.d}
:END:
    + [[https://github.com/purcell/emacs.d]]
*** Bozhidar Batzov’s Prelude
:CP:
#+CINDEX: Batzov Prelude
#+CINDEX: Prelude from Batzov
:END:
    + [[https://github.com/bbatsov/prelude]]
*** Awesome Emacs
:CP:
#+CINDEX: Awesome Emacs
:END:
    + [[https://github.com/emacs-tw/awesome-emacs]]
** Lisp
*** eLisp Introduction
    + [[https://www.gnu.org/software/emacs/manual/eintr.html]]
:CP:
#+CINDEX: elisp
:END:
** Emacs as OS
*** C Core
When you run Emacs you are in fact  launching a tiny C core responsible for the
low-level interactions with your operating system’s ABI.  That includes mundane
things like  file-system and network  access; drawing  things to the  screen or
printing control codes to the terminal.
*** Elisp Interpreter
:CP:
#+CINDEX: elisp interpreter
#+CINDEX: ui thread
#+CINDEX: uptime
#+CINDEX: @code{M-x emacs-uptime}
:END:
The cornerstone of Emacs though is the elisp interpreter — without it, there is
no Emacs; speed  and asynchrony are the two main  issues.  The interpreter runs
in a single thread  and intensive tasks will lock the UI  thread. But there are
workarounds.

When  you write  elisp you  are not  just  writing snippets  of code  run in  a
sandbox,  isolated from  everything  — you  are altering  a  living system;  an
operating system running on an operating  system.  Every variable you alter and
every function  you call is  carried out by the  very same interpreter  you use
when you edit text.

Emacs  is  a hacker’s  dream  because  it is  one  giant,  mutable state.   Its
simplicity is  both a blessing and  a curse. You can  re-define live functions;
change variables left and right; and you  can query the system for its state at
any time — state that changes with every key stroke as Emacs responds to events
from your keyboard to your network  stack. Emacs is self-documenting because it
is the document. There  are no other editors that can do  that. No editor comes
close.

And yet Emacs never  crashes — not really, anyway. Emacs  has an uptime counter
to prove  that it doesn’t  (~M-x emacs-uptime~)  — multi-month uptimes  are not
uncommon.

So when you ask Emacs a question – as I will show you how to do later – you are
asking your Emacs  what its state is.  Because of this, Emacs  has an excellent
elisp debugger and un-limited access to  every facet of Emacs’s own interpreter
and state — so  it has excellent code completion too. Any  time you encounter a
lisp expression  you can tell  Emacs to evaluate it,  and it will:  from adding
numbers to setting variables to downloading packages.
*** Concepts
**** Buffer
:CP:
#+CINDEX: buffer
:END:
In Emacs, all files are buffers, but not all buffers are files.

Emacs uses these buffers for more than  just editing text. It can also act like
an I/O device  and talk to another process,  such as a shell like  bash or even
Python.

Almost all of Emacs’s own commands act  on buffers.  So when you tell Emacs to,
for example, search & replace it will actually search and replace on a buffer –
maybe the active  buffer you’re writing in, or perhaps  a temporary duplicate –
and not an internal data structure like you might think.

In Emacs, the buffer is the /data structure/.

This is an extremely powerful concept because the very same commands you use to
move  around  and edit  in  Emacs  are almost  always  the  same ones  you  use
behind-the-scenes in elisp. So once you memorize Emacs’s own user commands, you
can use them in a simple function call to mimic what you’d do by hand.
**** Windows and Frames
:CP:
#+CINDEX: windows
#+CINDEX: frames
:END:
The /frame/ is the window and the /window/  is the frame.  That is, a frame has
at least one  window, but can have  multiple windows, and each  window can have
one /buffer/.  That is, a /buffer/ must  be viewed in a /window/, which must be
in a /frame/.  A /frame/ is made up of /window/ panes.

You are  free to create as  many frames as you  like, and to tile  up the frame
into as many windows  as you like.  This allows you to  see multiple buffers on
the screen at one time.
**** Modeline Echo Area Minibuffer
:CP:
#+CINDEX: modeline
#+CINDEX: minibuffer
#+CINDEX: echo area
:END:
Emacs uses the /modeline/ to communicate facts about Emacs and the buffer you
are in.  This is equivalent to a /status bar/.  Many different kinds of
information can be displayed in the modeline.

The /minibuffer/ is below the modeline.  This is where errors and general
information is displayed.  It is nearly identical to a normal buffer; the
one-line minibuffer will expand to multiple lines if necessary.  It is how you
communicate with Emacs.

The /echo area/ and the /minibuffer/ share the same spot on the screen.
**** Point and Mark
:CP:
#+CINDEX: point
#+CINDEX: mark
#+CINDEX: region
#+CINDEX: transient mark mode
:END:
/Point/ is  your current cursor position  in a buffer.  Each  buffer tracks its
own point separately,  so each buffer has a different  position for point.  The
``current buffer'' is  that buffer which currently ``has the  point.''  This is
the buffer that you can write and move  around in.  Only one buffer can ever be
the ``current buffer'' at any one time.

The point  is one part of  a duo called /point  and mark/.  The point  and mark
represent the boundaries of a /region/, which is a contiguous block of text.
Emacs can show you the region.  This is called /transient mark mode/.
**** Killing Yanking and CUA
/Killing/ is cutting, /yanking/ is pasting, and copying is known as /saving to
the kill ring/.
**** Init Files
     + ~.emacs.d~
     + ~init.el~
     + ~.emacs~
**** Modes
Major modes in Emacs control how  buffers behave.  Each buffer will always have
a major  mode.  You are  free to change  a buffer’s major  mode at any  time by
typing the command for another one.  Each buffer can have just one major mode.

Minor modes, by contrast, are typically optional add-ons that you enable for
some (or all) of your buffers.

The major mode is  always displayed in the modeline. Some  minor modes are also
displayed in the modeline,  but usually only the ones that  alter the buffer or
how you interact with it in some way.
* Concept Index
  :PROPERTIES:
  :INDEX:    cp
  :END:
