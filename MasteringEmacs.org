# -*- mode: org; -*-

#+title:Mastering Emacs---Notes and Outline
#+subtitle:{{{version}}} {{{date}}}
#+author:Pinecone062
#+date:2020-06-22 23:17
#+macro:version Version 0.0.112
#+macro:upload-date (eval (current-time-string))
#+bucket:pinecone-forest.com

/{{{title}}}/ {{{version}}} compiled {{{date}}}

#+texinfo:@insertcopying

#+begin_smallquotation
Emacs outshines all other editing software in approximately the same
way that the noonday sun does the stars. It is not just bigger and
brighter; it simply makes everything else vanish.
#+texinfo:@author Neal Stephenson, "In the Beginning was the Command Line"
#+end_smallquotation

- [[https://www.gnu.org/software/emacs/][Gnu Emacs Home]]

- [[http://git.savannah.gnu.org/cgit/emacs.git][Emacs Source Repository]]

- [[https://www.masteringemacs.org/][Mastering Emacs]]

- [[https://www.gnu.org/software/emacs/manual/][Emacs Online Reference Manual]]

- [[https://www.gnu.org/software/emacs/manual/elisp.html][Emacs Online Lisp Reference Manual]]

- [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf][Emacs 26 Reference Card]]

- [[https://www.gnu.org/software/emacs/refcards/pdf/survival.pdf][Emacs 26 Survival Card]]



* Overview
** In The Beginning
   + [[http://project.cyberpunk.ru/lib/in_the_beginning_was_the_command_line/][In the Beginning was the Command Line]]
   + Emacs began in 1976 https://www.gnu.org/software/emacs/manual/html_node/efaq/Origin-of-the-term-Emacs.html#Origin-of-the-term-Emacs

   + Came from an editor called Teco

#+attr_texinfo: :author Andy Wingo, http://wingolog.org/archives/2009/01/07/a-brief-history-of-guile
#+attr_texinfo: :tag From “A Brief History of Guile”
#+begin_quote
Emacs, when it was first created in its GNU form in 1984, was a new take on the
problem of “how to make a program”.  The Emacs thesis is that it is delightful
to create composite programs based on an orthogonal kernel written in a
low-level language together with a powerful, high-level extension language.
#+end_quote

** Some Implementations
:CP:
#+CINDEX: xemacs
#+CINDEX: sxemacs
:END:
   + XEmacs fork
     - [[http://www.xemacs.org]]
     - [[https://www.jwz.org/doc/lemacs.html]]
   + SXEmacs fork of XEmacs
     - [[http://www.sxemacs.org]]
   + and Gnu Emacs
     - [[https://www.gnu.org/software/emacs/]]
** Starter Packages
:CP:
#+CINDEX: starter packages
#+CINDEX: packages, starter
:END:
*** Emacs Wiki Starter Kits List

+ https://www.emacswiki.org/emacs/StarterKits
+ http://wikemacs.org/wiki/Starter_Kits

*** Phil Hagelberg “Technomancy”’s emacs-starter-kit and better-defaults

“Because the Emacs defaults are not so great sometimes.”

+ https://github.com/technomancy/emacs-starter-kit

+ https://github.com/technomancy/better-defaults

*** Eric Schulte’s Emacs Starter Kit

+ https://eschulte.github.io/emacs-starter-kit/
+ http://eschulte.github.io/emacs24-starter-kit/

*** Steve Purcell’s .emacs.d
:CP:
#+CINDEX:Steve Purcell @code{.emacs.d}
#+CINDEX:Purcell, Steve
:END:

[[https://www.youtube.com/watch?v=Gq0hG_om9xY][Steve Purcell interview by Sacha Chua]]

Steve Purcell's ~emacs~ config file is not meant to be a ``starter'' file, but
is famous in the community.  Purcell does not maintain it as a starter file,
but only for his own purposes.  He knows that it is forked and circulated, and
so allows it to be used for educational purposes I suppose.  He is a (the?)
maintainer of MELPA, and has written and reviewed a lot of elisp code.

“An Emacs configuration bundle with batteries included”

+ [[https://github.com/purcell/emacs.d]]

*** Bozhidar Batzov’s Prelude
:CP:
#+CINDEX: Batzov Prelude
#+CINDEX: Prelude from Batzov
:END:
    + [[https://github.com/bbatsov/prelude]]

*** Awesome Emacs
:CP:
#+CINDEX: Awesome Emacs
:END:
    + [[https://github.com/emacs-tw/awesome-emacs]]

*** Doom Emacs

“An Emacs configuration for the stubborn martian vimmer”

#+begin_quote
Doom is a configuration framework for GNU Emacs tailored for Emacs bankruptcy
veterans who want less framework in their frameworks and the performance of a
hand rolled config (or better). It can be a foundation for your own config or a
resource for Emacs enthusiasts to learn more about our favorite OS.
#+end_quote

#+cindex:doom-emacs
+ https://github.com/hlissner/doom-emacs

*** Xah Emacs List of Starter Kits

+ http://ergoemacs.org/misc/list_of_emacs_starter_kits.html

*** An Emacs Starter Kit for the Social Sciences

- https://kieranhealy.org/resources/emacs-starter-kit/

*** Emacs Starter Kits

- https://riptutorial.com/emacs/topic/1960/starter-kits

** Lisp
*** eLisp Introduction
    + [[https://www.gnu.org/software/emacs/manual/eintr.html]]
:CP:
#+CINDEX: elisp
:END:
** Emacs as OS
*** C Core
When you run Emacs you are in fact  launching a tiny C core responsible for the
low-level interactions with your operating system’s ABI.  That includes mundane
things like  file-system and network  access; drawing  things to the  screen or
printing control codes to the terminal.
*** Elisp Interpreter
:CP:
#+CINDEX: elisp interpreter
#+CINDEX: ui thread
#+CINDEX: uptime
#+CINDEX: @code{M-x emacs-uptime}
:END:
The cornerstone of Emacs though is the elisp interpreter — without it, there is
no Emacs; speed  and asynchrony are the two main  issues.  The interpreter runs
in a single thread  and intensive tasks will lock the UI  thread. But there are
workarounds.

When  you write  elisp you  are not  just  writing snippets  of code  run in  a
sandbox,  isolated from  everything  — you  are altering  a  living system;  an
operating system running on an operating  system.  Every variable you alter and
every function  you call is  carried out by the  very same interpreter  you use
when you edit text.

Emacs  is  a hacker’s  dream  because  it is  one  giant,  mutable state.   Its
simplicity is  both a blessing and  a curse. You can  re-define live functions;
change variables left and right; and you  can query the system for its state at
any time — state that changes with every key stroke as Emacs responds to events
from your keyboard to your network  stack. Emacs is self-documenting because it
is the document. There  are no other editors that can do  that. No editor comes
close.

And yet Emacs never  crashes — not really, anyway. Emacs  has an uptime counter
to prove  that it doesn’t  (~M-x emacs-uptime~)  — multi-month uptimes  are not
uncommon.

So when you ask Emacs a question – as I will show you how to do later – you are
asking your Emacs  what its state is.  Because of this, Emacs  has an excellent
elisp debugger and un-limited access to  every facet of Emacs’s own interpreter
and state — so  it has excellent code completion too. Any  time you encounter a
lisp expression  you can tell  Emacs to evaluate it,  and it will:  from adding
numbers to setting variables to downloading packages.
*** Concepts
**** Buffer
:CP:
#+CINDEX: buffer
:END:
In Emacs, all files are buffers, but not all buffers are files.

Emacs uses these buffers for more than  just editing text. It can also act like
an I/O device  and talk to another process,  such as a shell like  bash or even
Python.

Almost all of Emacs’s own commands act  on buffers.  So when you tell Emacs to,
for example, search & replace it will actually search and replace on a buffer –
maybe the active  buffer you’re writing in, or perhaps  a temporary duplicate –
and not an internal data structure like you might think.

In Emacs, the buffer is the /data structure/.

This is an extremely powerful concept because the very same commands you use to
move  around  and edit  in  Emacs  are almost  always  the  same ones  you  use
behind-the-scenes in elisp. So once you memorize Emacs’s own user commands, you
can use them in a simple function call to mimic what you’d do by hand.
**** Windows and Frames
:CP:
#+CINDEX: windows
#+CINDEX: frames
:END:
The /frame/ is the window and the /window/  is the frame.  That is, a frame has
at least one  window, but can have  multiple windows, and each  window can have
one /buffer/.  That is, a /buffer/ must  be viewed in a /window/, which must be
in a /frame/.  A /frame/ is made up of /window/ panes.

You are  free to create as  many frames as you  like, and to tile  up the frame
into as many windows  as you like.  This allows you to  see multiple buffers on
the screen at one time.
**** Modeline Echo Area Minibuffer
:CP:
#+CINDEX: modeline
#+CINDEX: minibuffer
#+CINDEX: echo area
:END:
Emacs uses the /modeline/ to communicate facts about Emacs and the buffer you
are in.  This is equivalent to a /status bar/.  Many different kinds of
information can be displayed in the modeline.

The /minibuffer/ is below the modeline.  This is where errors and general
information is displayed.  It is nearly identical to a normal buffer; the
one-line minibuffer will expand to multiple lines if necessary.  It is how you
communicate with Emacs.

The /echo area/ and the /minibuffer/ share the same spot on the screen.
**** Point and Mark
:CP:
#+CINDEX: point
#+CINDEX: mark
#+CINDEX: region
#+CINDEX: transient mark mode
:END:
/Point/ is  your current cursor position  in a buffer.  Each  buffer tracks its
own point separately,  so each buffer has a different  position for point.  The
``current buffer'' is  that buffer which currently ``has the  point.''  This is
the buffer that you can write and move  around in.  Only one buffer can ever be
the ``current buffer'' at any one time.

The point  is one part of  a duo called /point  and mark/.  The point  and mark
represent the boundaries of a /region/, which is a contiguous block of text.
Emacs can show you the region.  This is called /transient mark mode/.
**** Killing Yanking and CUA
/Killing/ is cutting, /yanking/ is pasting, and copying is known as /saving to
the kill ring/.
**** Init Files
     + ~.emacs.d~
     + ~init.el~
     + ~.emacs~
**** Modes
Major modes in Emacs control how  buffers behave.  Each buffer will always have
a major  mode.  You are  free to change  a buffer’s major  mode at any  time by
typing the command for another one.  Each buffer can have just one major mode.

Minor modes, by contrast, are typically optional add-ons that you enable for
some (or all) of your buffers.

The major mode is  always displayed in the modeline. Some  minor modes are also
displayed in the modeline,  but usually only the ones that  alter the buffer or
how you interact with it in some way.

* Introduction
From the blog /Mastering Emacs/.  Check out the [[https://www.masteringemacs.org/all-articles][index of articles]].
See also the [[https://www.masteringemacs.org/reading-guide][Reading Guide]].

* Help
- =C-h ...= ::

- =C-h a= :: [[*apropos-command][~apropos-command~]] search for commands (interactive functions);
  with a prefix argument, search for non-interactive functions also.

- =M-x apropos= :: search for functions and variables

- =C-h d= :: [[*apropos-documentation][~apropos-documentation~]]

- =C-h f= :: [[*describe-function][~describe-function~]]

- =C-h v= :: [[*describe-variable][~describe-variable~]]

- =C-h o= :: [[*describe-symbol][~describe-symbol~]]

- =C-h F= :: [[*Info-goto-emacs-command-node][~Info-goto-emacs-command-node~]]

- =C-h i= :: ~info~

** Help Mode

Help buffers provide the same commands as View mode.  A few special commands
are also provided:

- <RET> ~help-follow~ :: follow a cross-reference at point

- <TAB> ~forward-button~ :: move point forward to the next hyperlink

- S-<TAB> ~backward-button~ :: move point back to the previous hyperlink

- =C-c C-c= ~help-follow-symbol~ :: show all documentation about the symbol at
  point

- =C-c C-f=  ~help-go-forward~ ::
- r :: go forward to the next help topic

- =C-c C-b= ~help-go-back~ ::
- l :: got back to the previous help topic

** Apropos

By default, all ~apropos~ command except ~apropos-documentation~ list their
results in alphabetical order.  See [[apropos-sort-by-scores][~apropos-sort-by-scores~]] to change.

Following the conventions for naming Emacs commands, here are some words that
you’ll find useful in apropos patterns.  By using them in ‘C-h a’, you will
also get a feel for the naming conventions.

#+begin_example
char, line, word, sentence, paragraph, region, page, sexp, list,
defun, rect, buffer, frame, window, face, file, dir, register,
mode, beginning, end, forward, backward, next, previous, up, down,
search, goto, kill, delete, mark, insert, yank, fill, indent, case,
change, set, what, list, find, view, describe, default.
#+end_example

*** apropos

  #+attr_texinfo: :options apropos pattern &optional do-all
  #+begin_defun
  [[help:apropos][apropos.el]]

  Find all meaningful Lisp symbols whose names contain a match for the apropos
  pattern =PATTERN=.

  - =PATTERN= is either ::
    - a word to match; if a word, search for matches of that word as a
      substring;
    - a space-separated list of words of which at least two must match
    - a regular expression

  - =DO-ALL= ::
    if non-nil, or if the user option ‘apropos-do-all’ is non-‘nil’, then
    ~apropos~ also shows key bindings for the functions that are found.

  - RETURN ::
    The function returns a list of elements that look like this:

    #+begin_example
    (SYMBOL SCORE FUNCTION-DOC VARIABLE-DOC
     PLIST-DOC WIDGET-DOC FACE-DOC GROUP-DOC)
    #+end_example

    - SCORE ::
      an integer measure of how important the symbol seems to be as a match

    - REST ::
      Each of the remaining elements is a documentation string, or ‘nil’, for
      SYMBOL as a function, variable, etc.

    - =*apropos*= buffer ::
      It also displays the symbols in a buffer named ‘*Apropos*’, each with a
      one-line description taken from the beginning of its documentation
      string.
  #+end_defun

*** apropos-command

- =[C-u] C-h a=


  #+attr_texinfo: :options apropos-command pattern &optional do-all var-predicate
  #+begin_defun
  Interactive; show commands (interactively callable functions) that match
  PATTERN.

  - =PATTERN= ::
    - word; search for matches for that word as a substring;
    - list of words; search for matches for any two or more of those words;
    - regexp

  - =DO-ALL= :: =C-u= prefix, or ~apropos-do-all~ is non-nil, also show
    noninteractive functions.

  - =VAR-PREDICATE= :: when non-nil, show only variables, and only those that
    satisfy the predicate =VAR-PREDICATE=.
  #+end_defun

*** apropos-documentation

- =C-h d=


#+attr_texinfo: :options apropos-documentation pattern &optional do-all
#+begin_defun
Show symbols whose documentation contains matches for PATTERN.  This function
lists its results in order of relevance by default.  To list them in
alphabetical order, change ~apropos-documentation-sort-by-scores~ to nil.

- PATTERN ::

  =PATTERN= can be a word, a list of words (separated by spaces), or a regexp
  (using some regexp special characters).  If it is a word, search for matches
  for that word as a substring.  If it is a list of words, search for matches
  for any two (or more) of those words.
#+end_defun

Note that by default this command only searches in the file specified by
‘internal-doc-file-name’; i.e., the etc/DOC file.  With C-u prefix, or if
‘apropos-do-all’ is non-nil, it searches all currently defined documentation
strings.

*** apropos variables

- ~apropos-do-all~ :: if non-nil, most apropos commands behave as if they had
  been given the prefix argument.

- ~apropos-sort-by-scores~ <<apropos-sort-by-scores>> :: if non-nil, ~apropos~
  command try to guess the relevance of each result, and display the most
  relevant ones first.

- =M-x apropos-user-option= :: search for user-customizable variables; with a
  prefix argument, search for non-customizable variables too.

- =M-x apropos-variable= :: search for (all) variables; with a prefix argument,
  search for customizable variables also.  This ignores the ~apropos-do-all~
  variable.

- =M-x apropos-local-variable= :: search for buffer-local variables

- =M-x apropos-local-value= :: search for buffer-local variables whose values
  match the specified pattern

** Info

- ~info~ =C-h i= ::

  #+findex:info
  #+attr_texinfo: :options info &optional file-or-node buffer
  #+begin_defun
  Enter =Info=, opening the top-level ~dir~ file or FILE-OR-NODE if given.

  In interactive use, a non-numeric prefix argument directs this command to
  read a file name from the minibuffer.  A numeric prefix argument N selects
  ~*info<N>~.
  #+end_defun

  runs the command ~info~.  Enter =Info=, the documentation browser.  Optional
  argument FILE-OR-NODE specifies the file to examine.  The default is the
  top-level directory of Info.  When called from a program, this argument may
  specify an Info node of the form:
  : (FILENAME)NODENAME

  #+vindex:Info-directory-list
  #+attr_texinfo: :options Info-directory-list
  #+begin_defvar
  The search path for Info files.  The top-level Info directory is made by
  combining all the files nmaed ~dir~ in all the directories in this path.
  #+end_defvar

** Describe
** Documentation
*** ElDoc Mode

- =M-x eldoc-mode=

ElDoc mode is a buffer-local minor mode that helps with looking up Lisp
documentation.  When enabled, the echo area displays information about a
function or variable in the text where point is.  If point is on a documented
variable, it displays the first line of that variable’s doc string.  Otherwise
it displays the argument list of the function called in the expression point is
on.

*** Info-goto-emacs-command-node

#+attr_texinfo: :options Info-goto-emacs-command-node command
#+begin_defun
Go to the Info node in the Emacs manual for command COMMAND.

The command is found by:

- looking up in Emacs manual’s indices or
- in another manual found via COMMAND’s =info-file= property or
- the variable ~Info-file-list-for-emacs~
#+end_defun

*** documentation-property
#+attr_texinfo: :options documentation-property symbol property &optional verbatim
#+begin_defun
This function returns the documentation string recorded in =SYMBOL= 's property
list under property =PROPERTY=.  It is most often used to look up the
documentation strings of variables.

This differs from ~get~ in that it can refer to strings stored in the ‘etc/DOC’
file; and that it evaluates documentation properties that aren’t strings.

For function documentation, use the ~documentation~ function.
#+end_defun

*** documentation
#+attr_texinfo: :options documentation function &optional verbatim
#+begin_defun
This function returns the documentation string of =FUNCTION=.  It handles
macros, named keyboard macros, and special forms, as well as ordinary
functions.

If =FUNCTION= is a symbol, this function first looks for the
=function-documentation= property of that symbol; if that has a non-nil value,
the documentation comes from that value (if the value is not a string, it is
evaluated).

If =FUNCTION= is not a symbol, or if it has no =function-documentation=
property, then documentation extracts the documentation string from the actual
function definition, reading it from a file if called for.
#+end_defun

*** documentation example

See [[info:elisp#Accessing Documentation][Access to Documentation Strings]] for an example of using these functions in
ELisp code.

*** describe-function

- ~describe-function~ (=C-h f=)


This is the only way to get the documentation of a command that is not bound to
any key.  It describes the function called by the innermost Lisp expression in
the buffer around point.

#+attr_texinfo: :options describe-function function
#+begin_defun
Display the full documentation of FUNCTION.

- FUNCTION :: a symbol
#+end_defun

*** describe-variable

- ~describe-variable~ (=C-h v=)

#+attr_texinfo: :options describe-variable variable &optional buffer frame
#+begin_defun
Display the full documentation of VARIABLE (a symbol).  Returns the
documentation as a string, also.

- VARIABLE :: a symbol; default to using the current buffer and current frame;

- BUFFER :: if VARIABLE has a buffer-local value in BUFFER, it is displayed
  along with the global value.

- FRAME :: if VARIABLE has a buffer-local value in FRAME, it is displayed along
  with the global value.
#+end_defun

*** describe-symbol

#+attr_texinfo: :options describe-symbol
#+begin_defun
Display the full documentation of SYMBOL.  Will show the info of SYMBOL as a
function, variable, and/or face.

- SYMBOL :: the symbol to use; default to the current buffer and selected
  frame.

- BUFFER :: use BUFFER  to show the information about SYMBOL

- FRAME :: use FRAME  to show the information about SYMBOL
#+end_defun

** Doc and Data Directory

#+cindex:DOC
#+cindex:documentation, preloaded functions & variables
To save memory, the documentation for preloaded functions and variables
(including primitives) is kept in a file named =DOC=, in the directory
specified by ~doc-directory~.  This is usually the same as ~data-directory~.
This directory contains a lot of other useful information as well.

~doc-directory~ ’s value on your system is:

#+begin_src emacs-lisp :exports results
(print doc-directory)
#+end_src

This directory contains the following files:

#+begin_src emacs-lisp :exports results :results list
(directory-files doc-directory)
#+end_src

* First Steps
** Installing
*** What is Your Version
#+CINDEX: version
To check your Emacs' version, type: ~emacs --version~

#+caption:Your Emacs Version using the Shell
#+name:your-emacs-version-via-shell
#+header: :exports both :results output
#+begin_src sh
emacs --version
#+end_src

The version can also be checked from within Emacs, using ~M-x version~:

#+caption:Your Emacs Version using Emacs
#+name:your-emacs-version-via-emacs
#+header: :exports both :results output
#+begin_src emacs-lisp
(print (emacs-version))
#+end_src

*** Emacs on Mac OS
:CI:
#+CINDEX: Mac OS, installing
:END:
Mac OSX, in particular, seems to attract  a great deal of conflicting advice on
how  to best  run Emacs;  the best  advice  I can  offer is  to try  out a  few
different approaches and find one that fits you.

:CI:
#+CINDEX: Mac OS, unofficial builds
:END:
 + Unofficial build  --- One approach (though  there are several) is  to use an
   unofficial build of Emacs.

**** Emacs For Mac OSX
#+CINDEX: Emacs For Mac OSX
#+CINDEX: Mac OSX, flavors
[[http://emacsformacosx.com/][Emacs For Mac OSX]]

   - Pure Emacs! No extras! No nonsense!
   - About These Emacs Builds
     * I build three different release flavors of Emacs:
       1. Official releases --- These should be more stable but are not released
            very often.
       2. Pretests --- These are much more  stable and are meant for vetting the
                      code for last minute bugs before a final release.
       3. Nightlies ---  These are bleeding edge builds and  may have bugs. They
                       are built directly from the [[http://git.savannah.gnu.org/cgit/emacs.git/][public Git repository]]. I try
                       to build these nightly.
     * The scripts I run basically just  configure and build right from the GNU
       source --- I  don't add any patches or any  extraneous lisp packages.  I
       do include  the old  Carbon icon  on the  disk image  because I  like it
       better than the new Cocoa icon but it is not enabled by default.
     * Emacs is built on  various versions of Mac OS X: 10.6,  10.7 and 10.9 as
       of this writing. The 10.6 builds  also build 32-bit and PowerPC binaries
       (only Emacs 24 builds PowerPC ---  Emacs dropped support for it in Emacs
       25).  The  later OSes  only build  64-bit builds.  All the  binaries are
       combined  into a  single executable  and a  small Ruby  launcher chooses
       which binary to run based on the machine's OS and architecture.
     * Why not just use  a fat binary? Because fat binaries can  only hold 1 of
       each architecture and Emacs has multiple x86_64 architectures binaries.
     * Why are there multiple x86_64 binaries? Because the Emacs source does OS
       feature detection at compile time instead  of at run-time. So if I build
       Emacs on  10.9 then it  will contain hard-coded  calls to 10.9  APIs and
       will not run on 10.6. If I compile  it on 10.6, then it will also run on
       10.9, but it won't take advantage of any of the features in 10.9.
     * Because  of  the unstable  nature  of  nighly  builds, and  (sadly)  the
       relative fragility  of OS X  running on VMs,  there may be  days missing
       here and there.
     * *Note:* Recent Emacs builds (since 2009-12-09) have 64 bit Intel support
       in the Universal Binary. Yay!
     * *Also  Note:* Recent  Emacs builds  (since 2012-12-16)  have been  built
       against Mac OS 10.7 (Lion) and have  Lion full screen support if you are
       running on Lion  or Mountain Lion. They also have  better retina display
       support and are code signed. Also Yay!
     * *Also  Also  Note:*  Recent  Emacs  builds  (since  2016-08-15)  include
       ~gnutls~ (except on Mac OS 10.6 ---  Homebrew doesn't work on 10.6 and I
       don't want to spend a lot of  time compiling ~gnutls~ on a platform that
       is  barely  used).    You  can  now  use  https  urls   in  the  package
       configuration. Yay!
     * *Also Also  Also Note:*  Recent Emacs builds  (since 2018-04-10)  do not
       include  ~gnutls~  on  10.8  and lower.   Unfortunately  the  method  of
       downloading  ~gnutls~ (Homebrew)  stopped  working  because the  servers
       stopped  supporting old  SSL versions  and  10.8's SSL  libs aren't  new
       enough.  The  Emacs 26.0.91-1  pretest  is  the  last version  that  has
       ~gnutls~ on Mac OS 10.8.

#+CINDEX: Mac OSX, build scripts
   - The Build Scripts
     * Get them here: https://github.com/caldwell/build-emacs
     * I rewrote the build scripts in 2014 to make them more modular so I could
       easily control them with Jenkins. I  also moved them from shell to Ruby,
       which cleaned things up tremendously. They still aren't documented super
       well, but they should be easier to read, at least.

#+CINDEX: Mac OSX, tips and tricks
#+CINDEX: Mac OSX, @code{Emacs.app}
    - Tips  and  Tricks  --  Here  are  some tips  and  tricks  on  setting  up
      ~Emacs.app~ on  Mac OS X.  These  are based on my  personal experience of
      using ~Emacs.app~ for the past 10 years  or so; there may be better ways,
      but these work for me.

@@texinfo:@heading Running @code{Emacs.app} from the command line with @command{emacs}@@

Call this script @@texinfo:@command{emacs}@@ and put it somewhere in your
@@texinfo:@env{PATH}@@ (@@texinfo:@code{~/bin}@@ or
@@texinfo:@code{/usr/local/bin}@@):

#+BEGIN_EXAMPLE
#!/bin/sh
/Applications/Emacs.app/Contents/MacOS/Emacs "$@"
#+END_EXAMPLE

@@texinfo: @heading Using @command{emacsclient}@@

 1. Make sure the latest @@texinfo:@code{emacsclient}@@ binary is in your path:

#+BEGIN_EXAMPLE
ln -s /Applications/Emacs.app/Contents/MacOS/bin/emacsclient /usr/local/bin
# or ~/bin if you prefer
#+END_EXAMPLE

 2. Call this script @@texinfo:@command{ec}@@ and  put it somewhere in your @@texinfo:@env{PATH}@@
    (@@texinfo:@code{~/bin}@@ or @@texinfo:@code{/usr/local/bin}@@):

#+BEGIN_EXAMPLE
#!/bin/sh
which osascript > /dev/null 2>&1 && osascript -e 'tell application "Emacs" to activate'
emacsclient -c "$@"
#+END_EXAMPLE

 3.  Add   @@texinfo:@command{alias  emacs=ec}@@   or  @@texinfo:@command{alias
    emacsclient=ec}@@   to  your   @@texinfo:@code{.bashrc}@@.   Or   just  use
    @@texinfo:@command{ec}@@ directly.

@@texinfo:@heading Using Emacs as the @command{mergetool} for @command{git}@@

 1. Add add this snippet to your @@texinfo:@code{.gitconfig}@@:

#+BEGIN_EXAMPLE
[merge]
        tool = ediff
[mergetool "ediff"]
        cmd = emacs --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
#+END_EXAMPLE

 2. If you want to use @@texinfo:@command{emacsclient}@@, add this snippet
    instead:

#+BEGIN_EXAMPLE
[merge]
  tool = ediff
[mergetool "ediff"]
  cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
#+END_EXAMPLE

@@texinfo:@heading Changing the Modifier Keys@@

@@texinfo:@subheading Easy@@
The easiest way is to use the Customize interface: ~M-x customize-group RET ns RET~.

@@texinfo:@subheading Hard@@
If you don't like Customize and want to do it manually, the following variables
control the modifier keys:

 - ns-alternate-modifier
 - ns-command-modifier
 - ns-control-modifier
 - ns-function-modifier
 - ns-option-modifier (just a different name for ns-alternate-modifier)
 - ns-right-alternate-modifier
 - ns-right-command-modifier
 - ns-right-control-modifier
 - ns-right-option-modifier

Each variable can be set to ~'control~, ~'meta~, ~'alt~, ~'super~, or ~'hyper~.

In addition ~ns-alternative-modifier~ (and  ~ns-option-modifier~) can be set to
~'none~, which  lets it get interpreted  by the OS so  it can be used  to input
special characters.

The ~ns-right-*~  variables are set to  ~'left~ by default which  makes them the
same as their ~left~ counterpart.

@@texinfo:@heading Verifying the Binary Integrity@@

This  site serves  the binaries  via SSL  and while  the binaries  are not  GPG
signed, the application is code signed. You can verify the signature like this:
 : codesign -dvv /Applications/Emacs.app

Or, if you haven't installed emacs yet, but have mounted the disk image:
 : codesign -dvv /Volumes/Emacs/Emacs.app

Look for the following in the output:

#+BEGIN_EXAMPLE
Authority=Developer ID Application: Galvanix
Authority=Developer ID Certification Authority
Authority=Apple Root CA
#+END_EXAMPLE

~Galvanix~  is my  consulting partnership  and is  what I  registered my  Apple
developer account under. If you see that, the binary is intact.

**** Build Emacs from Source on OSX
#+begin_src sh
git clone git://git.savannah.gnu.org/emacs.git
cd emacs
./autogen.sh
./configure --with-ns
make install
cd nextstep
open Emacs.app 
#+end_src

**** Emacs-Mac by Mitsuharu Yamamoto
- https://bitbucket.org/mituharu/emacs-mac/overview
- https://github.com/railwaycat/homebrew-emacsmacport

**** Emacs Plus
- https://github.com/railwaycat/homebrew-emacsmacport

**** Emacs For Mac OS Wiki
:CI:
#+CINDEX: wiki, mac os
:END:
[[https://www.emacswiki.org/emacs/EmacsForMacOS][EmacsForMacOS Wiki]]

***** Distributions

****** Vanilla
These builds are based on the development version of GNU Emacs and do not
contain any additional packages or patches.  Popular Mac keyboard shortcuts are
available though (e.g. ~Command-O~ for opening a file); these are mapped to the
~Super~ modifier (i.e., the Apple/Command key functions as ~Super~).

#+CINDEX: EmacsForMacOS
[[http://emacsformacosx.com/][EmacsForMacOS]]

****** Extras

******* Mitsuhara Yamamoto's Mac Port
#+CINDEX: Mac Port
[[https://bitbucket.org/mituharu/emacs-mac/][Mac Port]]

 Based on the latest stable release of GNU Emacs (26.1 as of 2018-06-14) and
 claims to incorporate most of the features of Carbon Emacs and the
 Carbon+AppKit port from Emacs 22.3. It has improved ~C-g~ support, an emulation
 of ‘select’ that doesn’t require periodic polling, full screen support,
 subpixel font rendering, and smooth (pixel) scrolling.  See the [[https://bitbucket.org/mituharu/emacs-mac/][readme]] for more
 details. Available via Homebrew and MacPorts (as emacs-mac-app), as discussed
 below, or prebuilt binaries.

******* Aquamacs
#+CINDEX: Aquamacs
- [[http://aquamacs.org/][Aquamacs]]

- [[https://github.com/davidswelt/aquamacs-emacs/][Github Aquamacs-Emacs]]

Is a convenient distribution based on GNU Emacs 25.1.

Aquamacs comes preconfigured with a large number of packages and differs from
other Emacsen in that it feels more like a Mac OS X application.

OS X standard keyboard shortcuts are supported, files open in separate windows
or tabs, nice fonts are available, and it has a convenient drag&drop
installer.

Hundreds of file types are supported (C, Java, HTML, Python, Ruby, AppleScript,
XML, R (Splus), LaTeX (AUCTeX) etc.).

All these extra modes come included and readily configured – no InitFile
hacking.

Spell checking is easy to install (e.g., CocoAspell) and asian input methods
are also supplied, and options to deal with the missing Meta key on Mac
keyboards.

Aquamacs is based on Cocoa, the modern user interface framework in OS X.

It is a ready-to-use Universal App for PPC and Intel Macs that works well on
all recent Mac OS X versions.  Recommended for Mac users who want an Emacs that
is tailored to the Mac.

Experimental versions based on GNU Emacs 25 are also available.

******* Emacs Modified for macOS
- [[https://vigou3.gitlab.io/emacs-modified-macos/][Emacs Modified for macOS]]

*Emacs Modified for macOS* is a distribution of GNU Emacs 26.1 (released May
28, 2018) bundled with a few select packages for R developers and LaTeX users.
The distribution is based on the latest stable release of GNU Emacs compiled by
David Caldwell and distributed on Emacs for Mac OS X.

******** Philosophy
This distribution of Emacs is based on the NeXTstep port part of the official
sources of GNU Emacs. Other than the additions mentioned above and the minor
configurations found in the site-start.el file, this is a stock distribution of
Emacs. Users of Emacs on other platforms will appreciate the similar look and
feel of the application.

******** vs. Aquamacs
#+CINDEX: Aquamacs
Those looking for a more Mac-like version of Emacs may consider Aquamacs. I
used Aquamacs myself for two years, but I got tired of disabling the newer
“features” in each release of the application. For me Aquamacs insists too much
on opening new frames and on playing with fonts. Moreover, ESS is not kept up
to date on a regular basis.

****** Building From Source
- To download emacs using git, use this command:
  : git clone git://git.savannah.gnu.org/emacs.git
- Tarball Available from the [[http://savannah.gnu.org/projects/emacs/][GNU Savannah emacs]] page.  Click on “Download Area”
  under “Quick Overview”.

******* Building
- There are many options for building emacs (such as whether to build for the
  X11 GUI or the Cocoa GUI), which are discussed in the INSTALL file.
- There is also a script (~emacs/mac/make-package~) to create a Mac OS X
  package for use by the installer.
- The “normal” way to build Emacs under Mac OS X is:
#+BEGIN_EXAMPLE
./configure --with-ns
 make install
#+END_EXAMPLE
- When the build is complete, you should see ~Emacs.app~ in
  ~./nextstep/Emacs.app~.  Simply copy it to your applications folder and open
  it to run.
- For more detailed instructions, see the ~nextstep/INSTALL~ file.
- Additionally, you may benefit from reading the build script here: http://github.com/ieure/emacs-nightly.

**** iTerm Wiki for Emacs
:CI:
#+CINDEX: iTerm
:END:
[[https://www.emacswiki.org/emacs/iTerm2#toc11][iTerm Wiki for Emacs --- Super and Hyper Keys]]

***** Why getting Super and Hyper working in a terminal is not straightforward
The reason for this has to do a lot with DEC terminal history and the keys that
were available  in some of the  earliest possible terminals.  The  DEC terminal
became the default basis of emulation for most software.

Contrast  this with  the [[https://en.wikipedia.org/wiki/Space-cadet_keyboard][Space-cadet]]  keyboard  that influenced  the design  of
Emacs, made  for MIT Lisp  machines.  It  included several modifier  keys which
allowed multiple  character sets  as well  as a large  macro space  for binding
commands to key combinations.   Two modifier keys to the left  of the space bar
on the Space-cadet keyboard include the *Super* and *Hyper* keys.

While insanely  useful for the  experienced user,  fewer people worked  on Lisp
machines  compared  to  the  widespread  availability  of  VT-series  character
terminals. All  command line and  serial-terminal interaction you’ll  ever find
supports VT-100.

In GUI mode most emacsen will bind the Windows or Option key to *Super*U. Or if
you’re a Mac  user, you might have swapped  *Alt* and *⌘* so the  *Meta* key is
closest to the spacebar and easier to reach.

When  you press  a key  on your  keyboard your  terminal emulator  will send  a
character  or  an escape  sequence  down  the  connection.   For DEC  or  xterm
terminals, some keys may not send signals.  iTerm2 can make use of any key that
OSX will respond to and you can  customize it to run commands locally, remotely
or send signals down the terminal connection to the remote machine.

***** Testing escape codes
First,  connect  your  remote  machine  and  issue  the  cat  command  with  no
parameters. Depending on  your OS, termcap on the remote  and the codepage your
keyboard is set  to, you’ll see either  a character or an  escape sequence when
you type something.

Let’s see how the Latin letter ~O~ works when pressed with modifier keys.
 + When I press ~o~, I get an ~o~.
 + But when I press ~ALT+o~, I get ~^[o~
 + When I press ~CTRL+ALT+o~, I get ~^[^O~
 + And when I press ~SHIFT+ALT+o~, I get ~^[O~

These combos are being  read by the remote machine and being  fed to ~STDIN~ to
~cat~ (and ~cat~ is reading them back  as output).  They’re also the most basic
escape sequences, as ~^~ is the code for ~COMMAND~, and ~^[~ is for ~ALT/META~,
known  as the  escape sequence  ~^[~ .   For terminals  and IBM  PCs, the  ~^[~
signifies some sort  of terminal code, signifying a keypress  or some action to
be taken  on the terminal  or the  remote.  If your  keyboard has a  D-pad, try
hitting  ~<up> <down>  <right>~ and  ~<left>~.  Usually  these will  be ~^[[A~,
~^[[B~, ~^[[C~ and ~^[[D~, respectively.

You can press ~C-c~ to get out of ~cat~

Now let’s  try sending a  more complicated escape  sequence using some  keys on
your keyboard and fool Emacs on the  remote into thinking you pressed a *Hyper*
key combo.
 + Go into your iTerm2 settings for your connection profile.
 + In the Keys panel, let’s set a key combo for ~Ctrl+⌘+Option+A~, which is the
   three leftmost keys next to the space bar plus the letter ~A~.
 + I’m pretty confident your remote termcap probably does not have an entry for
   ~^[[1;P9~, so let’s start off with that code.
 + Your setting should look like this:
   + Keyboard Shortcut :: ~^+Option+Control+a~
   + Action :: Send Escape Sequence
   + Escape :: ~[1;P9~
 + Let’s get Emacs to listen for this key.  Evaluate the following Lisp code in
   an Emacs session (I  took the liberty of adding escapes for  the rest of the
   keys):
 + Now we can bind Hyper to something.  Let’s try this:
   + ~(global-set-key (kbd "H-a") 'dired)~
 + Now when  you press ~Ctrl+⌘+Option+A~, ~dired~ should pop  up.  Proceed with
   adding the rest  of the keys and  escape codes in your  iTerm2 setup.  Also,
   you can use the ~cat~ command to  check your work and ensure that the proper
   escape sequences are reaching the remote machine.
 + You can also  make combinations with ~Control~ and ~META~  such as ~C-c H-o~
   with this technique.  For ~C-c H-o~ you would hit ~C-c~ and then release the
   keys, then ~Ctrl+⌘+Option+o~ for the ~H-o~ part.
 +  Now  you can  make  loads  more keybindings  for  all  your favorite  Emacs
   commands.

** Starting
*** Starting the Emacs Server
#+cindex:@var{EDITOR}
By convention, your choice of editor is specified by the environment variable
=EDITOR=.  If you set =EDITOR= to ‘emacs’, Emacs would be invoked, but in an
inconvenient way---by starting a new Emacs process.  This is inconvenient
because the new Emacs process doesn't share buffers, a command history, or
other kinds of information with any existing Emacs process.

You can solve this problem by setting up Emacs as an edit server, so that it
“listens” for external edit requests and acts accordingly.  There are various
ways to start an Emacs server:

- Run the command ~server-start~ from within a process, either interactively as
  =M-x server-start=, or from within your =INIT= file as ~(server-start)~.  The
  existing Emacs process is the server.

- Run Emacs as a daemon by invoking Emacs from the command line with a
  @@texinfo:@option{@@--daemon@@texinfo:}@@ option.  When Emacs is started this
  way, it calls ~server-start~ after initialization and does not open an
  initial frame.  It then waits for edit requests from clients (using
  ~emacsclient~).

  - ~-daemon~

  - ~--daemon[=name]~

  - ~--bg-daemon[=name]~ ::

    A “background” daemon disconnects from the terminal and runs in the
    background (~--daemon~ is an alias for ~bg-daemon~).

    To kill a daemon session, type =M-x kill-emacs=.

  - ~--fg-daemon[=name]~

  - ~emacsclient~ ::

    Once an Emacs server is started, you can use a shell command called
    ~emacsclient~ to connect to the Emacs process and tell it to visit a file.
    You can then set the =EDITOR= environment variable to ‘emacsclient’, so
    that external programs will use the existing Emacs process for editing.

    - ‘-s server-name’ or ‘--socket-name=server-name’ Connect to the Emacs
      server named =server-name=.  The server name is given by the variable
      server-name on the Emacs server. If this option is omitted, ~emacsclient~
      connects to the first server it finds.

** Interface
** Keys
*** Control
*** Extended
*** Universal
*** Remembering Keys
** Configuring
*** Must Do’s
**** Add to Init File

- install MELPA and ORG repositories ::
  1. http://melpa.org/#/getting-started
  2. ~(add-to-list ’package-archives (cons "melpa" "https://melpa.org/packages/") t)~
  3. https://orgmode.org/
  4. ~(add-to-list 'package-archives (cons "org"   "https://orgmode.org/elpa")    t)~

- Set Default Frame Size ::
  : (setq default-frame-alist '((top . 10) (left . 10) (width . 300) (height . 150)))

- Inhibit the Startup Screen ::
  1. M-x customize-group RET Initialization group
  2. Inhibit Startup Screen: “t”

- Set Mac Command key to Emacs Meta ::
  1. M-x customize-group RET ns
  2. Ns Command Modifier: “meta”
  3. Ns Alternate Modified: “No modifier”

- Set Global line number mode and column number mode ::
  1. M-x customize-group RET global-linum
  2. Global Linum Mode: “t”
  3. M-x customize-group RET mode-line
  4. Column Number Mode: “t”

- Set Show Paren mode ::
  1. M-x customize-group RET paren matching

- Set show-trailing-whitespace ::
  1. M-x customize-group RET Editing Basics
  2. Show Trailing Whitespace: “t”

- Set Electricity Group ::
  1. M-x customize-group RET electricity

- Set Icomplete mode ::
  1. M-x customize-group RET Icomplete
  2. Icomplete mode: “t”

- Set up Calendar date style to ISO (for Org-mode time stamps) ::
  1. M-x customize-group RET Calendar group
  2. Calendar Date Style: ISO

**** Must-Have Packages

- Org Mode ::
  - https://orgmode.org/

  - M-x ~package-refresh-contents~ ::
  - M-x ~package-list-packages~ ::
  - Find Org and install :: current version is now 9.3.6
  - Install global key bindings ::
    - ~org-store-link~ :: (global-set-key (kbd “C-c l”) 'org-store-link)
    - ~org-agenda~ :: (global-set-key (kbd “C-c a”) ’org-agenda)
    - ~org-capture~ :: (global-set-key (kbd “C-c c”) ’org-capture)
    - ~org-switchb~ :: (global-set-key (kbd “C-c b”) ’org-switchb)
  - Set up Org Babel :: Babel group
    - ~org-babel-load-languages~ ::
      - shell
      - perl
      - js
    - ~org-confirm-babel-evaluate~ ::
      - set to ’nil’
  - Set up Org Export Backends ::
    - M-x customize-group RET Org Group
    - Org Export Backends: texinfo, md
  - Set up Org Indent Mode for cleaner view ::
    - M-x customize-group RET Org Structure group
      - Org startup indented : “t”
  - Set up auto-fill-mode for Org mode file ::
    - ~(add-hook 'org-mode-hook 'auto-fill-mode)~
  - Set up time-stamp ::
    - ~(add-hook ’org-mode-hook 'time-stamp)~

- Magit Mode ::
  - https://magit.vc/

  - M-x ~package-refresh-contents~
  - M-x ~package-list-packages~
  - Find Magit and install---current version is now
    : Magit 20200217.135, Git 2.17.2 (Apple Git-113), Emacs 27.0.50, darwin
  - Install global key bindings to work with Magit from any buffer
    a. ~(global-set-key (kbd "C-x g") 'magit-status)~
    b. ~(global-set-key (kbd "C-x M-g") 'magit-dispatch)~

**** Start the Emacs server
- from ~/.bash_profile: ~/Applications/MacPorts/Emacs.app/Contents/MacOS/Emacs --daemon~
- from ~/.bash_profile: ~EDITOR=emacsclient~

*** Customizing
**** Custom Indexing Command
#+header_args: :eval no
***** insert-cindex
#+begin_src emacs-lisp
(defun insert-cindex ()
  "Insert #+cindex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+cindex:"))
(global-set-key (kbd "C-c I") 'insert-cindex)
#+end_src

***** insert-pindex
#+begin_src emacs-lisp
(defun insert-pindex ()
  "Insert #+pindex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+pindex:"))
(global-set-key (kbd "C-c P") 'insert-pindex)
#+end_src

***** insert-vindex
#+begin_src emacs-lisp
(defun insert-vindex ()
  "Insert #+vindex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+vindex:"))
(global-set-key (kbd "C-c V") 'insert-vindex)
#+end_src

***** insert-findex
#+begin_src emacs-lisp
(defun insert-findex ()
  "Insert #+findex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+findex:"))
(global-set-key (kbd "C-c F") 'insert-findex)
#+end_src

*** Evaluating Lisp
*** Package Manager
*** Color Themes
*** Mastering Key Bindings in Emacs
- https://www.masteringemacs.org/article/mastering-key-bindings-emacs


There’s a reason why the Emacs manual has dedicated 30-odd pages to describing,
in great detail, all the subtleties and nuances of how to bind keys.  I’ve
written a guide that covers what you need to know to bind keys to even complex
commands, and a set of templates you can use in your own code.

**** Keymaps
#+cindex:keymap
A {{{dfn(keymap)}}} is an internal data structure used by Emacs to store keys
and their associated actions.  Keymaps are rarely modified directly, but
through a set of commands that manipulate the data structure for you.

Every buffer and most major and minor modes have a keymap, and that keymap
defines what the keys do when key sequences are sent to that buffer.  Keys can
be divided into three categories:

#+cindex:prefix key
#+cindex:key, prefix
#+cindex:complete key
#+cindex:key, complete
- undefined :: self-explanatory
- prefix key :: are parts of a complete key, and each constituent part of a
                prefix key is made up of its own keymap
- complete key :: a command that, when input, executes its associated command


#+cindex:keys, show all
To enumerate all the active minor and major mode key bindings in a buffer,
type:

- =C-h m=


If you know part of a key sequence, type out that part, then type the following
to get a list of all keys that belong to that sequence.

- =C-h=

**** Key Bind Commands
There are several ways you can define (or undefine) keys.

- ~(define-key KEYMAP KEY DEF)~ ::

     #+cindex:@code{define-key}
     #+cindex:keyboard map
     #+cindex:keymap, keyboard
     Defines a key against a keyboard map.  Use this if you want to change a
     keymap that isn’t the current buffer map.

- ~(local-set-key KEY COMMAND)~ ::

     #+cindex:@code{local-set-key}
     #+cindex:local keymap
     #+cindex:keymap, local
     Binds a key to the local keymap used by the active buffer, unlike
     ~define-key~ which takes an explicit keymap to bind a key against.

- ~(global-set-key KEY COMMAND)~ ::

     #+cindex:@code{global-set-key}
     #+cindex:global keymap
     #+cindex:keymap, global
     Binds a key to the global keymap, making it available in all buffers (with
     a caveat---see below.)

- ~(global-unset-key KEY)~ ::

     #+cindex:@code{global-unset-key}
     #+cindex:global keymap
     #+cindex:keymap, global
     Removes KEY from the global keymap

- ~(local-unset-key KEY)~ ::

     #+cindex:@code{local-unset-key}
     #+cindex:local keymap
     #+cindex:keymap, local
     Removes KEY from the active, local keymap.

**** Representing Keys in Code
{{{heading(@@texinfo:@code{@@kbd@@texinfo:}@@)}}}

#+cindex:key as string, vector
#+cindex:vector key
#+cindex:@code{kbd} macro
In order to actually bind a key you must first tell Emacs what key you intend
to use.  Unfortunately there’s more than one way of representing keys in Emacs:
as a /string/, or as a /vector/.  There is a macro built in to Emacs called
{{{dfn(kbd)}}}, which translates a human-readable key into a format Emacs can
understand.

{{{heading(Function and Navigation Keys)}}}

One important point to note is that you must surround /function/ and
/navigation/ keys with =<= and =>=.  Those keys include F-keys, arrow keys and
home row keys, like so: =<home>=, =<f8>= and =<down>=.  But if you want to
represent the key =C-c p= then write ~(kbd "C-c p")~.

**** Remapping Commands
{{{heading(@@texinfo:@code{@@remap@@texinfo:}@@---Replace)}}}

#+cindex:@code{remap} event
#+cindex:@code{define-key} command
You can tell Emacs that you want to /replace/ all keys pointing to a certain
command with one of your own choosing by using the ~remap~ event; this should
be done instead of passing a key to the key bind function you are using.  This
is arguably the best way of replacing existing commands with your own as Emacs
will automagically handle the key reassignment in the background.

: (define-key (current-global-map) [remap kill-line] 'my-homemade-kill-line)

Here I globally remap all key binds that point to ~kill-line~ to
~my-homemade-kill-line~.

#+cindex:transient mark mode
For some more hands-on examples read my article [[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode][Fixing the Mark Commands in Transient Mark Mode]].

**** Reserved Keys
You can pick any keyboard combination you desire---even if that key bind is
already taken, so be careful.  But Emacs has set aside certain keys for use by
users.  Generally, all keys prefixed with =C-c ?= (where =?= is a single
character) are reserved for you, and you alone.  In practice most third-party
packages don’t give a hoot and will gladly stuff their own key binds in there.

The other set of reserved keys are the F-keys from =F5= and onwards.

{{{heading(Hyper and Super Prefix Keys)}}}

#+cindex:hyper key
#+cindex:super key
The other two prefix keys reserved to you are =hyper= and =super=.  They are
remnants from ancient keyboards used in the 80s, but live on today in Emacs.
Most PC-compatible keyboards won’t have a =super= or =hyper= key so some people
rebind the Windows key and the Application Context key to be =hyper= and
=super= instead.

#+caption:Symbolics's lisp machine keyboard PN 365407 Rev C. (Photo by Joey Devilla.)
#+name:fig-lisp-machine-super-hyper-keys
[[file:resources/images/lisp-machine-keyboard-2-left.jpg]]

[fn::From http://ergoemacs.org/emacs/emacs_hyper_super_keys.html]

- See [[http://ergoemacs.org/emacs/emacs_hyper_super_keys.html][Emacs: How to Bind Super Hyper Keys]].

- See [[http://irreal.org/blog/?p=1450][A Hyper Key for the Mac]]


If you want to use =hyper= then use the prefix key =H-= (e.g., =H-q=) and if
you want =super= use the prefix key =s-= (lower case).


{{{heading(On Mac OS X)}}}

#+caption:set keys for Apple keyboard, for emacs in OS X
#+name:set-keys-mac-os-x
#+begin_src emacs-lisp
;; set keys for Apple keyboard, for emacs in OS X
(setq mac-command-modifier 'meta) ; make cmd key do Meta
(setq mac-option-modifier 'super) ; make opt key do Super
(setq mac-control-modifier 'control) ; make Control key do Control
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper
#+end_src
*** Configuring the Emacs Frame Height
- See [[http://irreal.org/blog/?p=1331][More on Setting the Emacs Frame Height]]
*** Configuring File Name Completion
If you have changed your system's case-sensitivity setting[fn:1], have a look
at file name completion, [[ignore-case-variables][ignore case sensitivity]]:
*** Enabling Your Trash

#+vindex:delete-by-moving-to-trash
- [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]]


#+begin_src emacs-lisp :exports results
  (with-output-to-string
    (princ "Your value of 'delete-by-moving-to-trash' is currently: ")
    (princ delete-by-moving-to-trash))
#+end_src

#+cindex:Trash
#+cindex:delete using Trash
By default, Emacs =deletion= commands do not use the =Trash= facility.  To use
the =Trash= facility (when it is available) for common deletion commands,
change the variable [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] to =t=.  This affects the
commands =M-x delete-file= [[*delete-file][delete-file]] and =M-x delete-directory=
[[*delete-directory][delete-directory]] (see Directories), as well as the deletion commands in =Dired=
(see Dired Deletion).

* Directories---Files---Buffers
** File Directories
A /directory listing/ is a list of all the files in a directory.

Emacs provides commands to create and delete directories, and to make directory
listings in /brief format/ (file names only) and /verbose format/ (sizes,
dates, and other attributes included).

#+cindex:Dired
Emacs also includes a directory browser feature called Dired, which you can
invoke with =C-x d=;

- [[*list-directory][~list-directory~]] (=C-x C-d=)

- [[*make-directory][~make-directory~]]

- [[*delete-directory][~delete-directory~]]

- [[*move-file-to-trash][~move-file-to-trash~]] (a Lisp function)

- [[*system-move-file-to-trash][~system-move-file-to-trash~]] (a non-interactive built-in C function)

- ~list-directory-brief-switches~ (a variable)

- ~list-directory-verbose-switches~ (a variable)

- ~directory-free-space-program~ (a variable)

- ~directory-free-space-args~ (a variable)

- [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] (a variable)

- ~trash-directory~ (a variable)

*** list-directory

#+attr_texinfo: :options list-directory dirname &optional verbose
#+begin_defun
Display a list of files in or matching DIRNAME, a la ‘ls’.  When called
interactively, a prefix argument switches on verbose mode.

- DIRNAME :: a directory file name; wildcard characters can be included; it
  will be globbed by the shell if necessary;

- VERBOSE :: if non-nil, supply the {{{option (-l)}}} switch.


The variables:

- ~list-directory-brief-switches~
- ~list-directory-verbose-switches~


control which switches are passed to the ~ls~ command in brief and verbose
listings.

The variables:

- ~directory-free-space-program~ (~df~)
- ~directory-free-space-args~ (args to pass to ~df~)


customize the display of free space on the disk containing the directory in
verbose mode.

#+end_defun

*** make-directory

Create the directory DIR and optionally any nonexistent parent dirs.  When
called interactively, non-existent parent dirs will automatically be created.

#+attr_texinfo: :options make-directory dir &optional parents
#+begin_defun
- DIR :: The DIR to create; if DIR exists, signal an error unless PARENTS is
  non-nil.

- PARENTS :: If non-nil, create any non-existent parent directories.
#+end_defun

*** delete-directory

Delete the directory named DIRECTORY.  Symlinks are /not/ followed.

#+attr_texinfo: :options delete-directory directory &optional recursive trash
#+begin_defun
- DIRECTORY :: The directory to delete;

- RECURSIVE :: If non-nil, delete all files contained inside DIRECTORY;

- TRASH :: If non-nil, and if variable [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] is also
  non-nil, move the DIRECTORY into the trash or recycle bin using
  [[*move-file-to-trash][~move-file-to-trash~]].
#+end_defun

*** move-file-to-trash

First, if the function [[*system-move-file-to-trash][~system-move-file-to-trash~]] is defined, call it with
FILENAME as an argument.

Otherwise, move the file (or directory) named FILENAME to the trash, or if the
variable ~trash-directory~ is defined[fn::by default it is nil], to it.

When [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] is non-nil, this function is called by
[[*delete-file][~delete-file~]] and [[*delete-directory][~delete-directory~]] instead of deleting files outright.

#+attr_texinfo: :options move-file-to-trash filename
#+begin_defun
- FILENAME :: file or directory to move to trash.
#+end_defun

*** system-move-file-to-trash

Move file or directory named FILENAME to the recycle bin.

#+attr_texinfo: :options system-move-file-to-trash filename
#+begin_defun
- FILENAME :: file or directory to move to the trash
#+end_defun

*** delete-by-moving-to-trash---a variable

#+attr_texinfo: :options delete-by-moving-to-trash
#+begin_defvar
If non-nil (nil is the default), some file deletion commands using the function
~move-file-to-trash~ instead of deleting them outright.  These commnds include:
- [[*delete-file][~delete-file~]]
- [[*delete-directory][~delete-directory~]]
- =Dired= deletion commands


The variable can be customized.
#+end_defvar

** Directories and File Names

#+texinfo:@heading Directory Variables

- [[*default-directory---a variable][~default-directory~]] --- a variable representing the current buffer's default
  directory


#+texinfo:@heading File Name Components

- [[*file-name-directory][~file-name-directory~]] --- the directory name of a file name (path) (ends with
  a trailing slash =/=)

- [[*file-name-as-directory][~file-name-as-directory~]] --- the directory name of a file name, or path (with
  a slash)

- [[*file-name-nondirectory][~file-name-nondirectory~]] --- the filename of a path (everything after last
  slash)

- [[*file-name-extension][~file-name-extension~]] --- the filename's extension

- [[*file-name-sans-extension][~file-name-sans-extension~]] --- the filename without its extension

- [[*directory-name-p][~directory-name-p~]] --- true for a directory name

- [[*directory-file-name][~directory-file-name~]] --- a directory file name (dirname) (file name without
  a trailing slash)


#+texinfo:@heading Absolute and Relative File Names

- [[*file-name-absolute-p][~file-name-absolute-p~]] --- true if the file name is absolute

- [[*file-relative-name][~file-relative-name~]] --- a relative file name in relation to a directory


#+texinfo:@heading Expanding and Abbreviating File Names

- [[*expand-file-name][~expand-file-name~]] --- expands to absolute an abbreviated file name

- [[*substitute-in-file-name][~substitute-in-file-name~]] --- expands environment variables in a file name
  (path)

- [[*abbreviate-file-name][~abbreviate-file-name~]] --- abbreviates an absolute file or directory name


#+texinfo:@heading Quoting File Names

- [[*file-name-quote][~file-name-quote~]] --- adds quote prefix to a file name

- [[*file-name-unquote][~file-name-unquote~]] --- removes quote prefix from a file name

- [[*file-name-quoted-p][~file-name-quoted-p~]] --- tests whether a file name is quoted


#+texinfo: @heading Magic File Names

- magic file names :: TODO

*** File Name Components

The operating system groups files into directories.  To specify exactly and
precisely (absolutely) a file[fn::some would call this a /path/], you must
specify the *directory* and the file's *file name* within that directory.

Therefore, Emacs considers a file name[fn:path:path] as having two main parts:

#+cindex:directory name
- the /directory name/ part; see [[*file-name-directory][~file-name-directory~]] and [[*file-name-as-directory][~file-name-as-directory~]]

- the nondirectory part (or /file name/ within the directory).  This is also
  sometimes referred to as a /relative file name/, since it is *relative* to
  the directory part.  The file name often has a /base name/ and an optional
  /extension/.

  - see [[*file-name-nondirectory][~file-name-nondirectory~]]

  - see [[*file-name-extension][~file-name-extension~]] and [[*file-name-sans-extension][~file-name-sans-extension~]]

  - see [[*file-name-base][~file-name~base~]]


Either part may be empty.  Concatenating these two parts reproduces the
original file name[fn:path].  On most systems, the directory part is everything
up to and including the last slash; the nondirectory part is the rest.

#+texinfo:@heading Absolute File Names

An /absolute file name/ specifies all the directory names starting from the
root of the tree.  An absolute file name starts with a ‘/’.

- see [[*file-name-absolute-p][~file-name-absolute-p~]]

#+texinfo:@heading Relative File Names

A /relative file name/ specifies the position of the file in the tree relative
to a default directory.  A relative file name does NOT start with a ‘/’.  It
can use abbreviations such as =.=, =..=, and =~=.

- see [[*file-relative-name][~file-relative-name~]]

#+texinfo:@heading Expanding File Names

Expanding a file name means converting a relative file name to an absolute one.
Since this is done relative to a default directory, you must specify the
default directory as well as the file name to be expanded.  It also involves
expanding abbreviations (e.g., =~=).

- see [[*expand-file-name][~expand-file-name~]]

- see [[*substitute-in-file-name][~substitute-in-file-name~]]

- see [[*abbreviate-file-name][~abbreviate-file-name~]]


#+texinfo:@heading Quoting File Name

Sometimes, it is not desired to expand file names.  In such cases, the file
name can be quoted to suppress the expansion, and to handle the file name
literally.  Quoting happens by prefixing the file name with ‘/:’.

- see [[*file-name-quote][~file-name-quote~]]

- see [[*file-name-unquote][~file-name-unquote~]]

- see [[*file-name-quoted-p][~file-name-quoted-p~]]

*** Directory Names and Directory File Names

#+texinfo:@heading Directory Name

#+cindex:directory name
A /directory name/ <<directory-name>> is a string that must name a directory if
it names any file at all.

- see [[*file-name-directory][~file-name-directory~]]

- see [[*file-name-as-directory][~file-name-as-directory~]]


#+texinfo:@heading Directory File Name

#+cindex:directory
#+cindex:directory file name
A /directory/ is actually a kind of file, and it has a file name (called the
/directory file name/ <<directory-file-name>>, which is related to the
/directory name/ but is typically not identical, e.g., it will not have a
trailing slash.

- See [[*directory-file-name][~directory-file-name~]]

#+texinfo:@heading The Difference

These two names for the same entity are related by a syntactic transformation:

- On GNU and other POSIX-like systems, to obtain a directory name, append a ‘/’
  to a directory file name that does not already end in ‘/’.

  : directory name = directory file name + /


The difference between a [[directory-name][directory name]] and a [[directory-file-name][directory file name]] is subtle but
crucial:

- When an Emacs variable or function argument is described as being a
  /directory name/, a /directory file name/ is not acceptable.

- When [[*file-name-directory][~file-name-directory~]] returns a string, that is always a /directory
  name/.

*** Directory and File Variables and Functions
**** default-directory---a variable

#+attr_texinfo: :options default-directory
#+begin_defvar
Name of default directory of current buffer.  It should be a [[directory-name][directory name]] (as
opposed to a [[directory-file-name][directory file name]]).  On GNU and Unix systems, [[directory-name][directory names]]
end in a slash ‘/’.
#+end_defvar

**** file-name-directory

#+attr_texinfo: :options file-name-directory filename
#+begin_defun
This function returns the /directory component/ of a file name.  Given a Unix
syntax file name, it returns a string ending in slash (=/=).

- FILENAME :: a file name (path)

- RETURN VALUE :: the directory component ([[directory-name][directory name]]) from FILENAME
  (path);

  nil if FILENAME does not include a directory.
#+end_defun

**** file-name-nondirectory

This function takes a full file name (path) and returns everything after the
last slash, or the full name if it contains no slash.  If the file name ends in
a slash, then this function will return the empty string.

#+attr_texinfo: :options file-name-nondirectory filename
#+begin_defun
- FILENAME :: a full file name (path)

- RETURN VALUE :: file name without its directory.
#+end_defun
**** file-name-extension

#+attr_texinfo: :options file-name-extension filename &optional period
#+begin_defun
- FILENAME :: a file name

- PERIOD :: if non-nil, include the period in the returned value; if file name
  has no extension, return the empty string rather than nil.

- RETURN VALUE :: the FILENAME's extension, i.e., the part that begins with the
  last ‘.’, or nil for extensionless file name, or the empty string if the file
  name ends with a period.
#+end_defun
**** file-name-sans-extension

#+attr_texinfo: :options file-name-sans-extension filename
#+begin_defun
- FILENAME :: a file name to work upon

- RETURN VALUE :: a file name without an extension; this includes the directory
  portion of the FILENAME, if any.
#+end_defun
**** file-name-base

#+attr_texinfo: :options file-name-base &optional filename
#+begin_defun
- FILENAME :: a file name to work upon; the default is [[*buffer-file-name][~buffer-file-name~]]

- RETURN VALUE :: the base name of the file name, i.e., no directory and no
  extension
#+end_defun
**** directory-file-name

This function returns a string representing /dirname/ in a form that the
operating system will interpret as the name of a file (a directory file name).
In general, it will return a name without a trailing slash.

This operation exists because a directory is also a file, but its name as a
directory is different from its name as a file.

#+attr_texinfo: :options directory-file-name directory
#+begin_defun
- DIRECTORY :: a directory to process; obtain its file name; in Unix-syntax,
  this function just removes the final slash.

- RETURN VALUE :: the file name of the directory named DIRECTORY (its directory
  file name).
#+end_defun
**** file-name-as-directory

This operation exists because a directory is also a file, but its name as a
directory is different from its name as a file.  The result can be used as the
value of ~default-directory~ or passed as second argument to
~expand-file-name~.

#+attr_texinfo: :options file-name-as-directory file
#+begin_defun
- FILE :: a file

- RETURN VALUE :: Return a string representing the file name FILE interpreted
  as a directory.  For a Unix-syntax file name, just appends a slash unless a
  trailing slash is already present.
#+end_defun
**** directory-name-p

#+attr_texinfo: :options directory-name-p name
#+begin_defun
- NAME :: potential file name to test

- RETURN VALUE :: non-nil if NAME ends with a directory separator character.
#+end_defun
**** file-name-absolute-p

This function tests whether a file name is absolute.  Given a possibly relative
file name, you can expand any leading ‘~’ and convert the result to an absolute
name using [[*expand-file-name][~expand-file-name~]].

#+attr_texinfo: :options file-name-absolute-p filename
#+begin_defun
- FILENAME :: the file name to test

- RETURN VALUE :: returns t if FILENAME is an absolute file name or begins with
  =~=; returns nil if not.
#+end_defun
**** file-relative-name

Convert an absolute file name to a relative file name in relation to a
directory.

#+attr_texinfo: :options file-relative-name filename &optional directory
#+begin_defun
- FILENAME :: a file name upon which to operate to convert it to be relative to
  DIRECTORY, which defaults to [[*default-directory---a variable][~default-directory~]].

- DIRECTORY :: a directory to act as a reference for this function;

- RETURN VALUE :: a relative file name which is equivalent to FILENAME in
  combination with DIRECTORY.
#+end_defun

**** file-name-quote

This macro adds the quotation prefix ‘/:’ to the file name.

#+attr_texinfo: :options file-name-quote name
#+begin_defun
- NAME :: a file name upon which to operate;

- RETURN VALUE :: the file name to which has been added the quotation prefix:
  ‘/:’;

  - local file name :: prefixes name with ‘/:’.

  - remote file name :: the local part of name (see Magic File Names) is
    quoted;

  - quote name :: If name is already a quoted file name, name is returned
    unchanged.
#+end_defun
**** file-name-unquote

This macro removes the quotation prefix ‘/:’ from the file name, if any.

#+attr_texinfo: :options file-name-unquote name
#+begin_defun
- NAME :: a file name upon which to operate

- RETURN VALUE :: the NAME without a quote prefix.  If name is a remote file
  name, the local part of name is unquoted.
#+end_defun
**** file-name-quoted-p

This macro returns non-nil, when name is quoted with the prefix ‘/:’.

#+attr_texinfo: :options file-name-quoted-p name
#+begin_defun
- NAME :: a file name to test

= RETURN VALUE :: returns non-nil, when name is quoted with the prefix ‘/:’; if
  name is a remote file name, the local part of name is checked.
#+end_defun

**** expand-file-name

Convert a relative file name to an absolute one and canonacilize it.  However,
use =(directory-file-name (file-name-directory dirname))= to traverse a
filesystem tree, not =(expand-file-name ".." dirname)=.

#+attr_texinfo: :options expand-file-name name &optional default-directory
#+begin_defun
- NAME :: a file name (a string that is a valid file name) upon which to
  operate: convert the file name to absolute and canonicalize it.  =~/= expands
  to the home directory.  =~USER= expands to USER's home directory.

- DEFAULT-DIRECTORY :: a directory used to start with if NAME is relative (does
  not start with slash or tilde);  this can be either a directory name or a
  directory file name; if nil or missing, the current buffer's value of
  ~default-directory~ is used.

- RETURN VALUE :: an absolute, canonacalized file name.
#+end_defun
**** substitute-in-file-name

This function replaces environment variable references in filename with the
environment variable values.

Sometimes, it is not desired to expand file names. In such cases, the file name
can be quoted to suppress the expansion, and to handle the file name
literally. Quoting happens by prefixing the file name with ‘/:’.

#+attr_texinfo: :options substitute-in-file-name filename
#+begin_defun
- FILENAME :: a file name upon which to operate; in FILENAME, substitute
  environment variables

- RETURN VALUE :: an absolute file name
#+end_defun
**** abbreviate-file-name

Converts a directory name to its abbreviation.  You can use this function for
directory names and for file names, because it recognizes abbreviations even as
part of the name.

#+attr_texinfo: :options abbreviate-file-name filename
#+begin_defun
- FILENAME :: an absolute file name upon which to operate;

- RETURN VALUE :: a shortened version of FILENAME, using
  ~directory-abbrev-alist~.  Also substitute =~= for the user's home directory
  and remove automounter prefixes.

  When this function is first called, it caches the user’s home directory as a
  regexp in ~abbreviated-home-dir~, and reuses it afterwards.
#+end_defun

** Files

#+texinfo:@heading Visiting Files

- [[*find-file][~find-file~]] ::

- [[find-file-literally][~find-file-literally~]] ::

- [[*find-file-noselect][~find-file-noselect~]] ::

- [[*find-file-other-window][~find-file-other-window~]] ::

- [[*find-file-read-only][~find-file-read-only~]] ::

- [[*find-file-wildcards --- User Option][~find-file-wildcards~]] --- user option ::

- [[*find-file-hook --- User Option][~find-file-hook~]] --- user option ::

- [[*find-file-not-found-functions --- Variable][~find-file-not-found-functions~]] --- variable ::

- [[*find-file-literally --- Variable][~find-file-literally~]] --- variable ::


#+texinfo:@heading Saving Files

- [[*save-buffer][~save-buffer~]] ::

- [[*save-some-buffers][~save-some-buffers~]] ::

- [[*write-file][~write-file~]] ::

- [[*set-visited-file-name][~set-visited-file-name~]] ::

- [[*not-modified][~not-modified~]] ::


#+texinfo:@heading Deleting Files

- [[*delete-file][~delete-file~]] ::

#+texinfo:@heading Hooks Related to Saving

- [[*write-file-functions---a hook][~write-file-functions~]] ::

- [[*write-contents-functions---a hook][~write-contents-functions~]] ::

- [[*before-save-hook][~before-save-hook~]] ::

- [[*after-save-hook][~after-save-hook~]] ::


#+texinfo:@heading Writing Buffers to Files

- [[*append-to-file][~append-to-file~]] ::

- [[*write-region][~write-region~]] ::

- [[*with-temp-file][~with-temp-file~]] ::


#+texinfo:@heading Errors

- handle errors ::

  - ~system-messages-locale~ (a variable) ::

  - ~locale-coding-system~ (a variable) ::


#+texinfo:@heading Creating Temporary Files

- [[*make-temp-file][~make-temp-file~]] :: create a unique temporary file

- [[*temporary-file-directory---a user option][~temporary-file-directory~]]---a user option :: default directory for storing
  temporary files

- [[*small-temporary-file-directory---a user option][~small-temporary-file-directory~]]---a user option :: a default directory for
  storing small temporary files

*** Visiting or Finding Files

#+cindex:visit a file
/Visiting/ a file means reading a *file* (information recorded in a computer)
into a *buffer* (information inside of Emacs that can be viewed and edited).
Once this is done, we say that the buffer is “visiting” that file, and call the
file “the visited file” of the buffer.  The buffer contains information copied
from the file.  If that information is changed, it must be *saved* (copied back
into the file) to make the changes permanent; otherwise the new information
will be lost.

Function names that visit files for historical reasons start with ~find-~
rather than ~visit-~.

In a Lisp program, if you want to look at the contents of a file but not alter
it, the fastest way is to use [[*Insert File Contents][~insert-file-contents~]] in a temporary buffer.
Visiting the file is not necessary and takes longer.

**** find-file

#+attr_texinfo: :options find-file filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, using an existing
buffer if there is one, and otherwise creating a new buffer and reading the
file into it.  It also returns that buffer.  This function is equivalent to:

 : (switch-to-buffer (find-file-noselect filename nil nil wildcards))

See [[switch-to-buffer][~switch-to-buffer~]].

- WILDCARDS :: if non-nil, expand wildcard characters in FILENAME and visit all
  of the matching files.  It is *always* true interactively.
#+end_defun

**** find-file-literally

#+attr_texinfo: :options find-file-literally filename
#+begin_defun
This command visits FILENAME, like ‘find-file’ does, but it does not perform
any format conversions (*note Format Conversion::), character code conversions
(*note Coding Systems::), or end-of-line conversions (*note End of line
conversion: Coding System Basics.).  The buffer visiting the file is made
unibyte, and its major mode is Fundamental mode, regardless of the file name.
File local variable specifications in the file (*note File Local Variables::)
are ignored, and automatic decompression and adding a newline at the end of the
file due to ‘require-final-newline’ (*note require-final-newline: Saving
Buffers.) are also disabled.

If you want to be sure of accessing a file’s contents literally, you should
create a temporary buffer and then read the file contents into it using
~insert-file-contents-literally~ (*note Reading from Files::).
#+end_defun

**** find-file-noselect

#+attr_texinfo: :options find-file-noselect filename &optional nowarn rawfile wildcards
#+begin_defun
This function returns a buffer visiting the file FILENAME.  It does *not* make
the buffer /current/ or /display/ it in a window.

The function returns an existing buffer if there is one; otherwise it creates a
new buffer and reads the file into it.

When this function uses an existing buffer, it first verifies that the file has
not changed since it was last visited or saved in that buffer.  If the file has
changed, this function asks the user whether to reread the changed file.  If
the user says ‘yes’, any edits previously made in the buffer are lost.

This function normally calls ~after-find-file~ after reading the file.  This
function sets the buffer major mode, parses local variables, warns the user if
there exists an auto-save file more recent than the file just visited, and
finishes by running the functions in ‘find-file-hook’.

- WILDCARDS :: if non-nil, expand wildcard characters in FILENAME and visit all
  of the matching files.

- NOWARN :: if non-nil, do not issue warnings.

- RAWFILE :: if non-nil, do not call ~after-find-file~, and
  ~find-file-not-found-functions~ are not run in case of failure, and
  suppresses coding system conversion and format conversion.

- RETURN VALUE :: usually returns the buffer that is visiting the file
  FILENAME.  If WILDCARDS are used, it returns a list of buffers that are
  visiting various files.
#+end_defun

**** find-file-other-window

#+attr_texinfo: :options find-file-other-window filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, but does so in a
window other than the selected window.  It may use another existing window or
split a window;
#+end_defun

**** find-file-read-only

#+attr_texinfo: :options find-file-read-only filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, like ‘find-file’, but
it marks the buffer as read-only.
#+end_defun

**** find-file-wildcards --- User Option

#+attr_texinfo: :options find-file-wildcards
#+begin_defvar
If this option is set to =nil=, then the various ~find-file~ functions ignore
their WILDCARDS argument and never treat wildcard characters specially.  The
default value is =t=.
#+end_defvar

**** find-file-hook --- User Option

#+attr_texinfo: :options find-file-hook
#+begin_defvar
The value of this variable is a list of functions to be called after a file is
visited.  The buffer visiting the file is current when the hook functions are
run.

#+cindex:hook
This is a normal hook.
#+end_defvar

**** find-file-not-found-functions --- Variable

#+attr_texinfo: :options find-file-not-found-functions
#+begin_defvar
The value of this variable is a list of functions to be called when ‘find-file’
or ‘find-file-noselect’ is passed a nonexistent file name.
‘find-file-noselect’ calls these functions as soon as it detects a nonexistent
file.  It calls them in the order of the list, until one of them returns
non-‘nil’.

#+cindex:hook, not normal
This is not a normal hook because the values of the functions are used, and in
many cases only some of the functions are called.
#+end_defvar

**** find-file-literally --- Variable

#+attr_texinfo: :options find-file-literally
#+begin_defun
If non-nil, makes ~save-buffer~ behave as if the buffer were visiting its file
literally, without conversions of any kind.

The command ~find-file-literally~ sets this variable’s local value, but other
equivalent functions and commands can do that as well.

This variable is permanent local, so it is unaffected by changes of major
modes.

#+end_defun

*** File Names
**** Minibuffer for File Names

#+texinfo:@heading Minibuffer

#+cindex:minibuffer
#+cindex:completion
#+cindex:history
While in the minibuffer, you can use the usual /completion/ and /history/
commands.  Minibuffer history commands offer some special features for reading
file names.

#+findex:find-file
#+cindex:visit file
#+cindex:minibuffer
- ~find-file~ (=C-x C-f=) :: use the /minibuffer/ to read a file name argument.
  Emacs obeys this command by /visiting/ the file: it creates a buffer, copies
  the contents of the file into the buffer, and then displays the buffer for
  editing.  If the file does not exist, this command creates an empty buffer;
  Emacs creates the file the first time you save this buffer.

- ~save-buffer~ (=C-x C-s=) :: you can save the new text in the file by typing
  =C-x C-s= (~save-buffer~).  This copies the altered buffer contents back into
  the file

#+texinfo:@subheading Completion

<<ignore-case-variables>>
#+vindex:read-file-name-completion-ignore-case
- ~read-file-name-completion-ignore-case~ :: when non-nil, ignore case when
  completing file names.
#+vindex:read-buffer-completion-ignore-case
- ~read-buffer-completion-ignore-case~ :: when non-nil, ignore case when
  completing buffer names.
  #+vindex:completion-ignored-extensions
- ~completion-ignored-extensions~ :: When completing file names, Emacs usually
  omits certain alternatives that are considered unlikely to be chosen, as
  determined by this list variable.

  It's value is:

  src_elisp[:eval yes :results output :exports results]{(princ completion-ignored-extensions)}
  #+vindex:completion-cycle-threshold
- ~completion-cycle-threshold~ :: If non-nil, completion commands can cycle
  through completion alternatives. If t, cycling is always used.

#+texinfo:@subheading Permissive Completion with Confirmation

#+texinfo: @subheading Minibuffer History

#+cindex:minibuffer history
Every argument that you enter with the minibuffer is saved in a minibuffer
history list so you can easily use it again later.  Emacs keeps separate
history lists for several different kinds of arguments.  For example, there is
a list for file names, used by all the commands that read file names.  Other
history lists include buffer names, command names (used by M-x), and command
arguments (used by commands like ~query-replace~).  Use the following arguments
to quickly fetch an earlier argument into the minibuffer:

- ~previous-history-element~ (=M-p=)

- ~next-history-element~ (=M-n=)

- ~previous-line-or-history-element~ (=<UP>=)

- ~next-line-or-history-element~ (=<DOWN>=)

- ~previous-matching-history-element~ (=M-r regexp=)

- ~next-matching-history-element~ (=M-s regexp=)

- ~repeat-complex-command~ (=C-x <ESC> <ESC>=) : Re-execute a recent minibuffer
  command from the command history.  With no argument, it repeats the last such
  command. A numeric argument specifies which command to repeat; 1 means the
  last one, 2 the previous, and so on.  You can use the usual minibuffer
  history commands to move through the history list.

- ~list-command-history~ (=M-x list-command-history=) : open a new window with
  the list of commands
  #+vindex:command-history
- ~command-history~ : The list of previous minibuffer-using commands is stored
  as a Lisp list in this variable.  Lisp programs can re-execute a command by
  calling eval with the command-history element.

**** Default Directory

#+cindex:default directory
#+vindex:default-directory
- ~default-directory~ :: Each buffer has a default directory, stored in the
  buffer-local variable ~default-directory~.  Emacs always assumes that any
  relative file name is relative to the default directory,

  When you visit a file, Emacs sets ~default-directory~ in the visiting buffer
  to the directory of its file.

  #+findex:pwd
- ~pwd~ :: Show the current default directory.

  #+findex:cd
- ~cd DIR~ :: Make DIR become the current buffer’s default directory.

**** Quoting File Names
You can quote an absolute file name to prevent special characters and syntax in
it from having their special effects.  The way to do this is to add =/:= at the
beginning.
: /:/foo:/bar

**** Completion
After you type part of the argument, Emacs can fill in the rest, or some of it,
based on what was typed so far.  Certain keys (usually =<TAB>=, =<RET>=, and
=<SPC>=) are rebound in the minibuffer to special completion commands.  You can
usually type =?= to see a list of completion alternatives.

*** Saving Files

#+cindex:hooks
#+cindex:format conversion
Saving a buffer runs several hooks.  It also performs format conversion.  These
hooks are only run by ~save-buffer~; they are not run by other primitives and
functions that write buffer text to files.  Auto-saving does not run these
hooks.

**** save-buffer

#+attr_texinfo: :options save-buffer &optional arg
#+begin_defun
Save current buffer in visited file if modified.

- arg :: how to deal with backup files
#+end_defun

**** save-some-buffers

#+attr_texinfo: :options save-some-buffers &optional ARG PRED
#+begin_defun
Save some modified file-visiting buffers.  Asks user about each one.  You can
answer ‘y’ to save, ‘n’ not to save, ‘C-r’ to look at the buffer in question
with ~view-buffer~ before deciding or ‘d’ to view the differences using
~diff-buffer-with-file~.

This command first saves any buffers where ~buffer-save-without-query~ is
non-nil, without asking.

- ARG :: Optional argument ARG (interactively, prefix argument) non-nil means
  save all with no questions.

- PRED :: Optional second argument PRED determines which buffers are
  considered:

  - If PRED is nil, all the file-visiting buffers are considered.

  - If PRED is t, then certain non-file buffers will also be considered.

  - If PRED is a zero-argument function, it indicates for each buffer whether
    to consider it or not when called with that buffer current.

  - PRED defaults to the value of ‘save-some-buffers-default-predicate’.


See ~save-some-buffers-action-alist~ if you want to change the additional
actions you can take on files.
#+end_defun

**** write-file

#+attr_texinfo: :options write-file FILENAME &optional CONFIRM
#+begin_defun
Write current buffer into file FILENAME.  This makes the buffer visit that
file, and marks it as not modified.

If optional second arg CONFIRM is non-nil, this function asks for confirmation
before overwriting an existing file.
#+end_defun

**** set-visited-file-name

#+attr_texinfo: :options set-visited-file-name FILENAME &optional NO-QUERY ALONG-WITH-FILE
#+begin_defun
Change name of file visited in current buffer to FILENAME.  This also renames
the buffer to correspond to the new file.  The next time the buffer is saved it
will go in the newly specified file.

FILENAME nil or an empty string means mark buffer as not visiting any file.

The optional second argument NO-QUERY, if non-nil, inhibits asking for
confirmation in the case where another buffer is already visiting FILENAME.

The optional third argument ALONG-WITH-FILE, if non-nil, means that the old
visited file has been renamed to the new name FILENAME.
#+end_defun
**** not-modified

If you have changed a buffer but do not wish to save the changes, you should
take some action to prevent it.  Otherwise, each time you use =C-x s= or =C-x
C-c=, you are liable to save this buffer by mistake.  One thing you can do is
type =M-~= (not-modified), which clears out the indication that the buffer is
modified.  If you do this, none of the save commands will believe that the
buffer needs to be saved. (‘~’ is often used as a mathematical symbol for
“not”; thus =M-~= is “not”, metafied.)

#+attr_texinfo: :options not-modified &optional ARG
#+begin_defun
This function is for interactive use only; in Lisp code use
~set-buffer-modified-p~ instead.

Mark current buffer as unmodified, not needing to be saved.

With prefix ARG, mark buffer as modified, so C-x C-s will save.
#+end_defun
**** write-file-functions---a hook

#+attr_texinfo: :options write-file-functions
#+begin_defvar
This variable a list of functions to be called before writing out a buffer to
its visited file.  If one of them returns non-‘nil’, the file is considered
already written and the rest of the functions are not called, nor is the usual
code for writing the file executed.  In addition, if a function in
~write-file-functions~ returns non-‘nil’, it is responsible for making a backup
file, using the following code:

: (or buffer-backed-up (backup-buffer))

Even though this is not a normal hook, you can use ‘add-hook’ and ‘remove-hook’
to manipulate the list.
#+end_defvar

**** write-contents-functions---a hook

#+attr_texinfo: :options write-contents-functions
#+begin_defvar
This works just like ‘write-file-functions’, but it is intended for hooks that
pertain to the buffer’s contents, not to the particular visited file or its
location, and can be used to create arbitrary save processes for buffers that
aren’t visiting files at all.  Such hooks are usually set up by major modes, as
buffer-local bindings for this variable.

If any of the functions in this hook returns non-‘nil’, the file is considered
already written and the rest are not called and neither are the functions in
~write-file-functions~.
#+end_defvar

**** before-save-hook

#+attr_texinfo: :options before-save-hook
#+begin_defvar
This normal hook runs before a buffer is saved in its visited file, regardless
of whether that is done normally or by one of the hooks described above.
#+end_defvar
**** after-save-hook

#+attr_texinfo: :options after-save-hook
#+begin_defvar
This normal hook runs after a buffer has been saved in its visited file.
#+end_defvar

*** Backing Up Files

**** ~make-backup-files~---a variable

Emacs can be configured to make backup files on save in several different
ways, using the variable ~make-backup-files~, which by default is t.

- ~make-backup-files~ ::

  - non-nil means make a backup of a file the first time it is saved.  This can
    be done:

    - by renaming the file; the existing file is renamed so that it is a backup
      file; the buffer is then written into a new file with the original file
      name.

    - by copying the file; the existing file is copied into a backup file; then
      the buffer is written into the file, overwriting it with new content.

    - the choice of renaming or copying is controlled by the variables:

      - ~backup-by-copying~ :: non-nil means using copying

      - ~backup-by-copying-when-linked~ :: non-nil means using copying for
        files with multiple names.  The alternate names will refer to the
        latest version as edited.  ~backup-by-copying~ must be nil.

      - ~backup-by-copying-when-mismatch~ :: Non-nil means create backups by
        copying if this preserves owner or group.

      - ~backup-by-copying-when-priviledged-mismatch~ :: Non-nil means create
        backups by copying to preserve a privileged owner.

      - ~backup-inhibited~ :: If non-nil, backups will be inhibited.

**** Making Interactive Backups

By default, Emacs will only make a backup of a file the first time it is
saved.  You can explicitly control further backups as follows:

- =C-u C-x C-s= :: the version thus saved will be made into a backup file if
  you save the buffer again.

- =C-u C-u C-x C-s= :: saves the buffer, but first makes the previous file
  contents into a new backup file.

- =C-u C-u C-u C-x C-s= :: does both things: it makes a backup from the
  previous contents, and arranges to make another from the newly saved contents
  if you save again.

**** Making Backups into Specific Directories

- ~backup-directory-alist~---a variable ::

  Use this variable to specify that files matching certain patterns should be
  backed up in specific directories.  A typical use is to add an element =("."
  . dir)= to make all backups in the directory with absolute name ~dir~.
  Alternatively, adding, =("." . ".~")= would make backups in the invisible
  subdirectory =.~= of the original file’s directory.

**** Single or Numbered Backups

When Emacs makes a backup file, its name is normally constructed by appending
‘~’ to the file name being edited.

Emacs can also make numbered backup files. Numbered backup file names contain
‘.~’, the number, and another ‘~’ after the original file name.

- ~version-control~ --- a variable :: determines whether to make single backup
  files or mul- tiple numbered backup files.  The usual way to set this
  variable is globally, through your init file or the customization buffer.
  But you can set version-control locally in an individual buffer to control
  the making of backups for that buffer’s file.

  - nil :: make single backups, unless files already have numbered backups.

  - t :: make numbered backups.

  - never :: never make numbered backups; always make single backups.

- ~make-backup-file-name-function~ :: tell Emacs what function to use to make
  backup names.

**** Automatic Backup Deletion

To prevent excessive consumption of disk space, Emacs can delete numbered
backup versions automatically.  Generally Emacs keeps the first few backups and
the latest few backups, deleting any in between.  This happens every time a new
backup is made.

- ~kept-old-versions~---a variable ::

  the number of oldest (lowest-numbered) backups to keep (default 2)

- ~kept-new-version~---a variable ::

  the number of newest (highest-numbered) ones to keep (default 2)

- ~delete-old-versions~ :: if t, Emacs deletes the excess backup files
  silently.  If nil, the default, Emacs asks you whether it should delete the
  excess backup versions.  If any other value, Emacs never automatically
  deletes backups.

- Dired =.= command :: can be used to delete old versions.
*** Writing to Files
You can write the contents of a buffer, or part of a buffer, directly to a file
on disk using the functions:

- ~append-to-file~

- ~write-region~


But don’t use these functions to write to files that are being visited.

**** append-to-file

#+attr_texinfo: :options append-to-file start end filename
#+begin_defun
This function appends the contents of the region delimited by START and END in
the current buffer to the end of file FILENAME.  If that file does not exist,
it is created.

When called from Lisp, this function is completely equivalent to:

: (write-region start end filename t)

- RETURN VALUE :: nil
#+end_defun

**** write-region

#+attr_texinfo: :options write-region start end filename &optional append visit lockname mustbenew
#+begin_defun
This function writes the region delimited by START and END in the current
buffer into the file specified by FILENAME.

If START is ‘nil’, then the command writes the entire buffer contents (_not_
just the accessible portion) to the file and ignores END.

If START is a string, then ‘write-region’ writes or appends that string, rather
than text from the buffer.  END is ignored in this case.

If APPEND is non-‘nil’, then the specified text is appended to the existing
file contents (if any).  If APPEND is a number, ‘write-region’ seeks to that
byte offset from the start of the file and writes the data from there.
#+end_defun

**** with-temp-file

#+attr_texinfo: :options with-temp-file file body
#+begin_defun
The ‘with-temp-file’ macro evaluates the BODY forms with a temporary buffer as
the current buffer; then, at the end, it writes the buffer contents into file
FILE.  It kills the temporary buffer when finished, restoring the buffer that
was current before the ‘with-temp-file’ form.  Then it returns the value of the
last form in BODY.

See also [[*with-temp-buffer][~with-temp-buffer~]].
#+end_defun

**** make-temp-file

Some programs need to write temporary files.  Here is the usual way to
construct a name for such a file.  The job of ~make-temp-file~ is to prevent
two different users or two different jobs from trying to use the exact same
file name.

#+attr_texinfo: :options make-temp-file prefix &optional dir-flag suffix text
#+begin_defun
This function creates a temporary file and returns its name by adding to PREFIX
some random characters that are different in each Emacs job.

- PREFIX :: a user-provided string that should be unique to this program; this
  helps Emacs generate a unique file name despite numerous programs in
  different jobs running simultaneously and using this macro.

- DIR-FLAG :: if non-nil, create a new, empty directory instead of a file.

- SUFFIX :: if non-nil, it is added to the end of the file name.

- TEXT :: if a string, insert it into the new file before returning; DIR-FLAG
  should be nil;

  if nil, leave the file empty.

- RETURN VALUE :: the newly-created file name pointing to a new-created file
  that is empty unless TEXT contains a string, in which case the file contains
  TEXT.
#+end_defun

If you want to write a temporary file which is likely to be small, you should
compute the directory like this:

#+caption:Creating a Small Temporary File
#+name:create-small-temp-file
#+begin_src elisp :eval never
  (make-temp-file
   (expand-file-name prefix
                     (or small-temporary-file-directory
                         temporary-file-directory)))
#+end_src

**** temporary-file-directory---a user option

The default directory for temporary files is controlled by the variable
~temporary-file-directory~.  This variable gives the user a uniform way to
specify the directory for all temporary files.  It will have a default value
consistent with the operating system so it does not need to be explicitly
created.

#+attr_texinfo: :options temporary-file-directory
#+begin_defvar
This variable specifies the directory name for creating temporary files.  Its
value should be a [[directory-name][directory name]], but a program should be able to handle a
[[directory-file-name][directory file name]] instead.

The default value is determined in a reasonable way for your operating system;
it is based on the =TMPDIR=, =TMP= and =TEMP= environment variables, with a
fall-back to a system-dependent name if none of these variables is defined.  At
the time of writing this, this variable’s default value is:
: /var/folders/x_/v2pfz45s7h3245q6wlvvvnyh0000gn/T/

The variable’s value can be customized from within Emacs.

The directory ~/var/folders/~ is owned by =root=, but the folders ~x/~ and
above are owned by the User.  ~x/~ was apparently created at the time the User
account was created, and the folders inside it were created in the recent past.

This variable works well as the optional default directory for
[[*expand-file-name][~expand-file-name~]].
#+end_defvar

**** small-temporary-file-directory---a user option

#+attr_texinfo: :options small-temporary-file-directory
#+begin_defvar
The directory for writing small temporary files.  If non-nil, use this
directory instead of [[*temporary-file-directory---a user option][~temporary-file-directory~]] when creating small temporary
files.  This is for systems that have fast storage with limited space, such as
a RAM disk.

It’s default value is nil.  It’s value can be customized.
#+end_defvar
*** Deleting Files
**** delete-file
Delete file named FILENAME.  If it is a symlink, remove the symlink.

#+attr_texinfo: :options delete-file filename &optional trash
#+begin_defun
- FILENAME :: file name to delete.

- TRASH :: if non-nil, and if the variable [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] is also
  non-nil, then use the Trash facility to delete the file.
#+end_defun

** Buffers

#+texinfo:@heading Working with Buffers

- [[bufferp][~bufferp~]]

- [[list-buffers][~list-buffers~]] invoke Buffer Menu

- [[ibuffer][=ibuffer=]] invoke Ibuffer-mode

- [[Icomplete][=Icomplete=]] global minor mode


#+texinfo:@heading Buffer Names

- [[*buffer-name][~buffer-name~]] return the name of the buffer

- [[*rename-buffer][~rename-buffer~]] rename a buffer


#+texinfo:@heading Interactive Buffer Commands using Windows

- [[switch-to-buffer][~switch-to-buffer~]] display a buffer in a window

- [[switch-to-buffer-other-window][~switch-to-buffer-other-window~]]

- [[switch-to-buffer-other-frame][~switch-to-buffer-other-frame~]]

- [[previous-buffer][~previous-buffer~]]

- [[next-buffer][~next-buffer~]]

- [[beginning-of-buffer][~beginning-of-buffer~]]

- [[end-of-buffer][~end-of-buffer~]]


#+texinfo:@heading Positions within a Buffer

- [[point][~point~]]

- [[point-min][~point-min~]]

- [[point-max][~point-max~]]

- [[buffer-end][~buffer-end~]]

- [[buffer-size][~buffer-size~]]


#+texinfo:@heading Moving Around Within a Buffer

- [[goto-char][~goto-char~]]

- [[forward-char][~forward-char~]]

- [[backward-char][~backward-char~]]

- [[forward-word][~forward-word~]]

- [[backward-word][~backward-word~]]

- [[goto-line][~goto-line~]]

- [[forward-line][~forward-line~]]

- [[beginning-of-line][~beginning-of-line~]]

- [[line-beginning-position][~line-beginning-position~]]

- [[end-of-line][~end-of-line~]]

- [[line-end-position][~line-end-position~]]

- [[forward-line][~forward-line~]]

- [[count-lines][~count-lines~]]

- [[count-words][~count-words~]]

- [[line-number-at-pos][~line-number-at-pos~]]

- [[bobp][~bobp~]]

- [[eobp][~eobp~]]

#+texinfo:@heading The Current Buffer for Editing

- [[*current-buffer][~current-buffer~]] return the current buffer

- [[*set-buffer][~set-buffer~]] make buffer current for editing

- [[*save-current-buffer][~save-current-buffer~]] save the current buffer before editing

- [[*with-current-buffer][~with-current-buffer~]] make buffer current temporarily for editing

- [[*with-temp-buffer][~with-temp-buffer~]] create a temporary buffer for editing


#+texinfo:@heading Working with Buffer Names

- [[*get-buffer][~get-buffer~]] return a buffer given a name

- [[other-buffer][~other-buffer~]] return the previous buffer

- [[*generate-new-buffer-name][~generate-new-buffer-name~]] just return a unique buffer name

- [[*buffer-file-name][~buffer-file-name~]] return the visited file's name

- [[*get-file-buffer][~get-file-buffer~]] return the buffer visiting the file name (exact) or nil

- [[*find-buffer-visiting][~find-buffer-visiting~]] return a buffer visiting the file name (not exact)

- [[set-visited-file-name][~set-visited-file-name~]] change the name of the visited file


#+texinfo:@heading Working with Buffer Contents

- [[*buffer-string][~buffer-string~]] return a buffer as a string


#+texinfo:@heading Creating and Killing Buffers

- [[*get-buffer-create][~get-buffer-create~]] creates or returns an existing buffer

- [[*generate-new-buffer][~generate-new-buffer~]] generate a new buffer with a unique name

- [[*create-file-buffer][~create-file-buffer~]] create a buffer and visit a file

- [[*kill-buffer][~kill-buffer~]] kill a buffer


*** About Buffers

#+texinfo:@heading A Buffer is a Lisp Object---a special data type

#+cindex:buffer
A /buffer/ is a Lisp object containing text to be edited.  Buffers in Emacs
editing are objects that have distinct names and hold text that can be edited.
Each time you visit a file, a buffer is used to hold the file’s text.  Each
buffer has a unique name, which can be of any length.  Most buffers are made by
visiting files, and their names are derived from the files’ names; however, you
can also create an empty buffer with any name you want.

Buffers appear to Lisp programs as a special data type.  You can think of the
contents of a buffer as a string that you can extend; insertions and deletions
may occur in any part of the buffer.

#+texinfo:@heading Files and Windows

Buffers are used to hold the contents of files that are being visited; there
may also be buffers that are not visiting files.  For examppl each time you
invoke Dired, a buffer is used to hold the directory listing.  If you send a
message with =C-x m=, a buffer is used to hold the text of the message.  When
you ask for a command’s documentation, that appears in a buffer named =*Help*=.
Each buffer, including the current buffer, may or may not be displayed in any
windows.  When a buffer is displayed in a window, its name is shown in the mode
line.

#+texinfo:@heading Current Buffer

#+cindex:current buffer
Only one buffer is selected and designated the [[*Current Buffer][current buffer]] at any time.
When a command operates on “the buffer”, this really means that it operates on
the /current buffer/.  When there is only one Emacs window, the buffer
displayed in that window is current.  When there are multiple windows, the
buffer displayed in the “selected window” is current.

#+texinfo:@heading Properties

#+cindex:text properties
A buffer’s “contents” consist of a series of characters, each of which
optionally carries a set of text properties that can specify more information
about that character.

#+texinfo:@heading Buffer-Local Variables

#+cindex:buffer-local variables
#+cindex:local variables
Buffer-specific information that is directly accessible is stored in
/buffer-local variable bindings/, which are variable values that are effective
only in a particular buffer.  This feature allows each buffer to override the
values of certain variables.  Most major modes override variables.

Aside from its textual contents, each buffer records several pieces of
information, such as what file it is visiting (if any), whether it is modified,
and what major mode and minor modes are in effect.  These are stored in
“buffer-local variables”---variables that can have a different value in each
buffer.

#+texinfo:@heading Buffer Positions

#+cindex:position
A /position/ is the index of a character in the text of a buffer.  A position
actually identifies the place between characters or before the first character,
or after the last character.  One speaks of the character either before or
after a given position.  When one says the character “at” a position, one
usually is referring to the character /after/ that position.

#+cindex:marker
Positions can be represented either by integers or by markers.  A /marker/ is a
special object that relocates automatically when text is inserted or deleted so
it stays with the surrounding characters.

<<bufferp>>
#+attr_texinfo: :options bufferp @var{object}
#+begin_defun
Return t if OBJECT is an editor buffer.
#+end_defun

*** Interactive Commands for Creating and Selecting Buffers

#+findex:list-buffers
- ~list-buffers &optional ARG~ (=C-x C-b=) ::
  <<list-buffers>>
  Invoke the Buffer Menu.  Display a list of existing buffers.  With prefix
  argument ARG, show only buffers that are visiting files.
  #+findex:buffer-menu
- ~buffer-menu &optional ARG~ ::
- ~buffer-menu-other-window~ ::
  Switch to the Buffer Menu.

  |            C            |       R       |           M           | Buffer | Size | Mode       | File         |
  |           <c>           |      <c>      |          <c>          |        |      |            |              |
  |-------------------------+---------------+-----------------------+--------+------+------------+--------------|
  | ~.~ the current buffer  | ~%~ read-only |     ~*~ modified      | name   | size | major mode | visited file |
  | ~>~ marked for display  |               | ~S~ marked for saving |        |      |            |              |
  | ~D~ marked for deletion |               |                       |        |      |            |              |


- ~buffer-menu-mode~ is the major mode for Buffer Menu buffers.

  - q --- leave Buffer Menu
  - RET --- select new current buffer this window
  - o --- select new current buffer other window
  - V --- select new current buffer in View mode
  - M-x Buffer-menu-view-other-window
  - C-o --- display buffer in another window
  - m --- make for display
  - v --- select this buffer and show marked buffers in other windows
  - 1 --- select this buffer in full-frame window
  - 2 --- select this buffer in half-window and other buffer in half window
  - M-s a C-s --- Incremental search in marked buffers
  - M-s a C-M-s --- Isearch for regext in marked buffers
  - t --- visit-tags-table this buffer
  - ~ --- clear modified flog on buffer
  - s --- mark for saving
  - C-k --- mark for deletion
  - C-d --- makr for deletion and move up
  - x --- delete or save marked buffers
  - u --- remove marks (ARG and move up)
  - M-DEL --- remove a mark from all lines
  - U --- remove all marks from all lines
  - DEL --- back up a line and remove marks
  - % --- toggle read-only status
  - g --- update
  - T --- toggle displaying only file buffers
  - b --- bury buffer

#+cindex:Icomplete global minor mode
- =Icomplete= <<Icomplete>>global minor mode (=M-x icomplete-mode=) :: provides
  a convenient way to quickly select an element among the possible completions
  in a minibuffer.  When enabled, typing in the minibuffer continuously
  displays a list of possible completions that match the string you have typed.
  At any time, you can type ‘C-j’ to select the first completion in the list.
  There are two ways to make an item first:

  1. You can type more of the completion name and thus narrow down the list;

  2. You can use ‘C-.’ and ‘C-,’ to rotate the list until the desired buffer is
     first.

  ‘M-<TAB>’ will select the first completion in the list, like ‘C-j’ but
  without exiting the minibuffer, so you can edit it further.  This is
  typically used when entering a file name, where ‘M-<TAB>’ can be used a few
  times to descend in the hierarchy of directories.

  - ~icomplete-mode~ variable :: nil to deselect; t to select.


#+cindex:Ibuffer-mode
- ~ibuffer~ :: <<ibuffer>>Begin using Ibuffer to edit a list of buffers.  Make
  a list of buffers and operate on them in Dired-like fashion.  Type ‘h’ after
  entering ibuffer for more information.
  #+findex:switch-to-buffer
- ~switch-to-buffer BUFFER-OR-NAME~ (=C-x b BUFFER=) ::
  <<switch-to-buffer>>

  If called interactively, read the buffer name using ‘read-buffer’.  The
  variable ~confirm-nonexistent-file-or-buffer~ determines whether to request
  confirmation before creating a new buffer.  If BUFFER-OR-NAME is a string
  that does not identify an existing buffer, create a buffer with that name.
  If BUFFER-OR-NAME is =nil=, switch to the buffer returned by ~other-buffer~
  (Return most recently selected buffer other than BUFFER).

  *WARNING*: This is NOT the way to work on another buffer temporarily within a
  Lisp program!  Use [[*set-buffer][~set-buffer~]] instead.  That avoids messing with the
  window-buffer correspondences.

- ~switch-to-buffer-other-window~ (=C-x 4 b BUFFER=) ::
  <<switch-to-buffer-other-window>>

- ~switch-to-buffer-other-frame~ (=C-x 5 b BUFFER=) ::
  <<switch-to-buffer-other-frame>>

- ~previous-buffer~ (=C-x <LEFT>=) ::
  <<previous-buffer>>

- ~next-buffer~ (=C-x <RIGHT>=) ::
  <<next-buffer>>

- ~beginning-of-buffer~ (=M-<=) ::
  <<beginning-of-buffer>>

  This function is for interactive use only; move point to the beginning of the
  buffer.  With numeric arg N, put point N/10 of the way from the beginning.

- ~end-of-buffer~ (=M->=) ::
  <<end-of-buffer>>

  This function is for interactive use only; move point to the end of the
  buffer.  With numeric arg N, put point N/10 of the way from the end.  If the
  buffer is narrowed, this command uses the end of the accessible part of the
  buffer.

- ~goto-char~ (=M-g c=) ::
  <<goto-char>>

  #+attr_texinfo: :options goto-char position
  #+begin_defun
  Set point to POSITION.  The beginning of the buffer is ~(point-min)~, and the
  end is ~(point-max)~.

  - POSITION :: a number or marker indicating buffer position.

  - RETURN VALUE :: POSITION


  If narrowing is in effect, position still counts from the beginning of the
  buffer, but point cannot go outside the accessible portion.  If position is
  out of range, ~goto-char~ moves point to the beginning or the end of the
  accessible portion.
  #+end_defun

  To move point to the beginning (end) of the buffer, write:
  : (goto-char (point-min))
  : (goto-char (point-max))

- ~forward-char~ ~backward-char~ ::
  <<forward-char>> <<backward-char>>

  #+attr_texinfo: :options forward-char &optional count
  #+begin_defun
  Move point COUNT characters forward (backward if COUNT is negative).  Signal
  error if the beginning or ending of the buffer is reached.

  - COUNT :: if nil, use a default value of 1.
  #+end_defun

- ~forward-word~ ~backward-word~ ::
  <<forward-word>> <<backward-word>>

  #+attr_texinfo: :options forward-word &optional count
  #+begin_defun
  Move point forward (backward) COUNT words.

  - COUNT :: if nil, default is 1.

  - RETURN VALUE :: t; but if an edge of the buffer or a field boundary is
    reached, point is left there and the function returns nil.
  #+end_defun

- ~forward-word-strictly~ ~backward-word-strictly~ ::

  See above

- ~goto-line LINE &optional BUFFER~ (=M-g g=) ::
  <<goto-line>>

  This function is for interactive use only (because it sets mark); in Lisp
  code use [[forward-line][~forward-line~]] instead.

  Go to LINE, counting from line 1 at beginning of buffer.  If called
  interactively, a numeric prefix argument specifies LINE; without a numeric
  prefix argument, read LINE from the minibuffer.

  If optional argument BUFFER is non-nil, switch to that buffer and move to
  line LINE there.  If called interactively with C-u as argument, BUFFER is the
  most recently selected other buffer.

  This function is usually the wrong thing to use in a Lisp program. What you
  probably want instead is something like:

  #+begin_src elisp :eval no
  (goto-char (point-min))
  (forward-line (1- N))
  #+end_src

  If at all possible, an even better solution is to use char counts rather than
  line counts.

- ~goto-line~ (=C-u M-g M-g=) ::

  reads a number N using the minibuffer, selects the most recently selected
  buffer other than the current buffer in another window, and then moves point
  to the beginning of line number N in that buffer.

  This is mainly useful in a buffer that refers to line numbers in another
  buffer: if point is on or just after a number, ‘goto-line’ uses that number
  as the default for N.

  Note that prefix arguments other than just ‘C-u’ behave differently.  ‘C-u 4
  M-g M-g’ goes to line 4 in the _current_ buffer, without reading a number
  from the minibuffer.

- ~forward-line &optional N~ ::
  <<forward-line>>

  #+attr_texinfo: :options forward-line &optional n
  #+begin_defun
  Move N lines forward (backward if N is negative).  Precisely, if point is on
  line I, move to the start of line I + N.  If there isn’t room, go as far as
  possible (no error).

  - N :: number of lines to move;

  - RETURN VALUE :: Returns the count of lines left to move.  If moving
    forward, that is N minus number of lines moved; if backward, N plus number
    moved.
  #+end_defun

- ~beginning-of-line~ ::
  <<beginning-of-line>>

  Move point to the beginning of current line.  With argument N > 1, move
  forward =N - 1= lines first.  Stop when reaching the beginning or ending of
  the buffer without error.

- ~line-beginning-position~ ::
  <<line-beginning-position>>

  Return the position that ~(beginning-of-line count)~ would move to.

  - RETURN VALUE :: Return the character position of the first character on the
    current line.  With optional argument N, scan forward N - 1 lines first.
    If the scan reaches the end of the buffer, return that position.

- ~end-of-line~ ::
  <<end-of-line>>

  Move point to end of current line (in the logical order). With argument N not
  nil or 1, move forward N - 1 lines first.  If point reaches the beginning or
  end of buffer, it stops there.

- ~line-end-position~ ::
  <<line-end-position>>

  Return the character position of the last character on the current line. With
  argument N not nil or 1, move forward N - 1 lines first.  If scan reaches end
  of buffer, return that position.

- ~forward-line~ ::
  <<forward-line>>

  Move N lines forward (backward if N is negative).  If point is on line I,
  move to the start of line I + N.  If there isn’t room, go as far as possible
  (no error).

  Returns the count of lines left to move.  That is, N minus moved lines.

- ~count-lines start end~ ::
  <<count-lines>>

  Return number of lines between START and END.  This is usually the number of
  newlines between them.

- ~count-words start end~ ::
  <<count-words>>

  Count words between START and END.

- ~line-number-at-pos~ ::
  <<line-number-at-pos>>

  Return buffer line number at position POS. If POS is nil, use current buffer
  location.

- bobp :: Return t if point is at the beginning of the buffer.
  <<bobp>>

- eobp :: Return t if point is at the end of the buffer.
  <<eobp>>

*** Current Buffer
#+cindex:current buffer
At any time, one buffer is designated the /current buffer/---the buffer in
which most editing takes place.  Most of the primitives for examining or
changing text operate implicitly on the current buffer.

Normally, the buffer displayed in the selected window is the current buffer,
but this is not always so: a Lisp program can temporarily designate any buffer
as current in order to operate on its contents, without changing what is
displayed on the screen.

**** current-buffer

#+attr_texinfo: :options current-buffer
#+begin_defun
Return the current buffer as a Lisp object.
#+end_defun

**** set-buffer

#+attr_texinfo: :options set-buffer @var{buffer-or-name}
#+begin_defun
Make buffer BUFFER-OR-NAME current for editing operations.

- BUFFER-OR-NAME :: may be a buffer or the name of an existing buffer.
#+end_defun

When an editing command returns to the editor command loop, Emacs automatically
calls ~set-buffer~ on the buffer shown in the selected window.  you should not
use set-buffer to switch visibly to a different buffer; for that, use the
functions described in Switching Buffers.  However, when writing a Lisp
function, do not rely on this behavior of the command loop to restore the
current buffer after an operation.

To operate temporarily on another buffer, put the ~set-buffer~ within a
[[*save-current-buffer][~save-current-buffer~]] form.

**** save-current-buffer

#+attr_texinfo: :options save-current-buffer &rest body
#+begin_defun
Record which buffer is current; execute BODY; can use ~set-buffer~ to make a
different buffer current without displaying it.  At the conclusion of BODY,
make the original buffer current.

BODY is executed just like ‘progn’.
#+end_defun

**** with-current-buffer

#+attr_texinfo: :options with-current-buffer buffer-or-name &rest body
#+begin_defun
Execute the forms in BODY with BUFFER-OR-NAME temporarily current.

- BUFFER-OR-NAME :: must be a buffer or the name of an existing buffer.

- RETURN VALUE :: The value returned is the value of the last form in BODY.
#+end_defun

**** with-temp-buffer

#+attr_texinfo: :options with-temp-buffer &rest body
#+begin_defun
Create a temporary buffer, and evaluate BODY there like ‘progn’.

- RETURN VALUE :: The return value is the value of the last form in body.  You
  can return the contents of the temporary buffer by using ~buffer-string~ as
  the last form.
#+end_defun

**** buffer-string

#+attr_texinfo: :options buffer-string
#+begin_defun
Return the contents of the current buffer as a string.  If narrowing is in
effect, this function returns only the visible part of the buffer.
#+end_defun

*** Positions
#+cindex:point
/Point/ is a special buffer position used by many editing commands, and like
other positions, designates a place between two characters (or before the first
character, or after the last character), rather than a particular character.
Usually terminals display the cursor over the character that immediately
follows point; point is actually before the character on which the cursor sits.

The value of point is a number no less than 1, and no greater than the buffer
size plus 1.

Each buffer has its own value of point.  Each window also has its own value of
point, independent of the value of point in other windows displaying the same
buffer.  This makes it useful to have multiple windows showing one buffer:
This is why point can have different values in various windows that display the
same buffer.

**** point

#+attr_texinfo: :options point
#+begin_defun
Return value of point as an integer.
#+end_defun

**** point-min

#+attr_texinfo: :options point-min
#+begin_defun
Return the minimum permissible value of point in the current buffer.  This is
1, unless narrowing (a buffer restriction) is in effect.
#+end_defun

**** point-max

#+attr_texinfo: :options point-max
#+begin_defun
Return the maximum permissible value of point in the current buffer.  This is
(1+ (buffer-size)), unless narrowing (a buffer restriction) is in effect, in
which case it is less.
#+end_defun

**** buffer-end

#+attr_texinfo: :options buffer-end arg
#+begin_defun
- ARG :: If position, return the end position (~point-max~) of the buffer.
  Otherwise, return the beginning (~point-min~) of the buffer.
#+end_defun

**** buffer-size

#+attr_texinfo: :options buffer-size &optional buffer
#+begin_defun
Return the number of characters in the current buffer, without taking into
account narrowing.

- BUFFER :: if non-nil, return the number of characters in this buffer.


To count the number of characters in the accessible portion of the current
buffer, use ~(- (point-max) (point-min))~, and to count the number of
characters in some other BUFFER, use ~(with-current-buffer BUFFER (-
(point-max) (point-min)))~.
#+end_defun

*** Buffer Names and File Names
#+cindex:buffer name
#+cindex:buffer-or-name
Each buffer has a unique name, which is a string.  Many of the functions that
work on buffers accept either a buffer or a buffer name as an argument.  Any
argument called BUFFER-OR-NAME is of this sort.  Any argument called BUFFER must
be an actual buffer object, not a name.

#+texinfo:@heading Buffer File Names

#+cindex:buffer file name
The /buffer file name/ is the name of the file that is visited in that buffer.
When a buffer is not visiting a file, its buffer file name is ‘nil’.  Most of
the time, the buffer name is the same as the nondirectory part of the buffer
file name, but the buffer file name and the buffer name are distinct and can be
set independently.

#+texinfo:@heading Buffer Name Functions

**** buffer-name

#+attr_texinfo: :options buffer-name &optional buffer
#+begin_defun
This function returns the name of BUFFER as a string.  BUFFER defaults to the
current buffer.
#+end_defun

**** rename-buffer

#+attr_texinfo: :options rename-buffer newname &optional unique
#+begin_defun
This function renames the current buffer to NEWNAME.

Ordinarily, ‘rename-buffer’ signals an error if NEWNAME is already in use.
However, if UNIQUE is non-‘nil’, it modifies NEWNAME to make a name that is not
in use.

This function returns the name actually given to the buffer.
#+end_defun

Also ~rename-uniquely~

**** get-buffer

#+attr_texinfo: :options buffer-or-name
#+begin_defun
This function returns the buffer specified by BUFFER-OR-NAME.

If BUFFER-OR-NAME is a string and there is no buffer with that name, the value
is ‘nil’.
#+end_defun

**** other-buffer

#+attr_texinfo: :options other-buffer &optional buffer visible-ok frame
#+begin_defun
Return most recently select buffer other than BUFFER.  This is done by scanning
the selected or specified frame’s buffer list first, followed by the list of
all buffers.

- BUFFER :: Return a buffer other than this one if possible; ignore this buffer
  completely unless it is a live buffer.

- VISIBLE-OK :: Buffers not visible in windows are preferred to visible
  buffers, unless optional second argument VISIBLE-OK is non-nil.

- FRAME :: if non-nil, and is a live frame, use that frame’s buffer list, not
  the selected frame’s buffer list.

- RETURN VALUE :: return a found buffer; if no other buffer exists, return the
  =*scratch*= buffer, and create it if necessary.
#+end_defun

**** generate-new-buffer-name

#+attr_texinfo: :options starting-name &optional ignore
#+begin_defun
This function returns a name that would be unique for a new buffer---but does
not create the buffer.  It starts with STARTING-NAME, and produces a name not
currently in use for any buffer by appending a number inside of ‘<...>’.

If the optional second argument IGNORE is non-‘nil’, it should be a string, a
potential buffer name.  It means to consider that potential buffer acceptable,
if it is tried, even it is the name of an existing buffer (which would normally
be rejected).
#+end_defun

**** buffer-file-name

#+texinfo:@heading Buffer File Name Functions and Variables

#+attr_texinfo: :options buffer-file-name &optional buffer
#+begin_defun
This function returns the absolute file name of the file that BUFFER is
visiting (defaulting to the current buffer).  It returns 'nil' if BUFFER is not
visiting a file.
#+end_defun

**** buffer-file-name---a permanent buffer-local variable

#+attr_texinfo: :options buffer-file-name
#+begin_defvar
This buffer-local variable contains the name of the file being visited in the
current buffer, or ‘nil’ if it is not visiting a file.

Use [[*set-visited-file-name][~set-visited-file-name~]] to change this variable's value.
#+end_defvar

**** buffer-file-truename---a permanent buffer-local variable

#+attr_texinfo: :options buffer-file-truename
#+begin_defvar
This buffer-local variable holds the abbreviated [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Truenames.html#Truenames][truename]] of the file visited
in the current buffer, or ‘nil’ if no file is visited.
#+end_defvar

**** get-file-buffer

#+attr_texinfo: :options get-file-buffer filename
#+begin_defun
This function returns the buffer visiting file FILENAME, or 'nil' if there is
none.  The argument FILENAME, which must be a string, is expanded then compared
against the visited file names of all live buffers.  Note that the buffer’s
‘buffer-file-name’ must match the expansion of FILENAME exactly.

In unusual circumstances, there can be more than one buffer visiting the same
file name.  In such cases, this function returns the first such buffer in the
buffer list.
#+end_defun

**** find-buffer-visiting

#+attr_texinfo: :options find-buffer-visiting filename &optional predicate
#+begin_defun
This is like ‘get-file-buffer’, except that it can return any buffer visiting
the file possibly under a different name.  That is, the buffer’s
‘buffer-file-name’ does not need to match the expansion of FILENAME exactly, it
only needs to refer to the same file.

If PREDICATE is non-‘nil’, it should be a function of one argument, a buffer
visiting FILENAME.  The buffer is only considered a suitable return value if
PREDICATE returns non-‘nil’.
#+end_defun

**** set-visited-file-name
<<set-visited-file-name>>

#+attr_texinfo: :options set-visited-file-name filename &optional no-query along-with-file
#+begin_defun
If FILENAME is a non-empty string, this function changes (or sets) the name of
the file visited in the current buffer to FILENAME.  The next time the buffer
is saved it will go in the newly-specified file.

This command marks the buffer as modified.  It also renames the buffer to
correspond to the new file name, unless the new name is already in use.

If FILENAME is ‘nil’ or the empty string, that stands for “no visited file”.
In this case, ‘set-visited-file-name’ marks the buffer as having no visited
file, without changing the buffer’s modified flag.

Normally, this function asks the user for confirmation if there already is a
buffer visiting FILENAME.  If NO-QUERY is non-‘nil’, that prevents asking this
question.

If ALONG-WITH-FILE is non-‘nil’, that means to assume that the former visited
file has been renamed to FILENAME.  In this case, the command does not change
the buffer’s modified flag, nor the buffer’s recorded last file modification
time as reported by ‘visited-file-modtime’.  If ALONG-WITH-FILE is ‘nil’, this
function clears the recorded last file modification time, after which
‘visited-file
#+end_defun

*** Modifying Buffers

#+texinfo:@heading Modified Flag

#+cindex:modified flag
Emacs keeps a flag called the “modified flag” for each buffer, to record
whether you have changed the text of the buffer.  This flag is set to ‘t’
whenever you alter the contents of the buffer, and cleared to ‘nil’ when you
save it.

Some Lisp programs set the flag explicitly.  For example, the function
‘set-visited-file-name’ sets the flag to ‘t’, because the text does not match
the newly-visited file, even if it is unchanged from the file formerly visited.

**** buffer-modified-p

This function returns ‘t’ if the buffer BUFFER has been modified since it was
last read in from a file or saved, or ‘nil’ otherwise.

**** set-buffer-modified-p

This function marks the current buffer as modified if FLAG is non-‘nil’, or as
unmodified if the flag is ‘nil’.

Another effect of calling this function is to cause unconditional redisplay of
the mode line for the current buffer.

#+texinfo:@subheading @code{force-mode-line-update}

: (set-buffer-modified-p (buffer-modified-p))

**** restore-buffer-modified-p

Like ‘set-buffer-modified-p’, but does not force redisplay of mode lines.

**** not-modified

This command marks the current buffer as unmodified, and not needing to be
saved.

If ARG is non-‘nil’, it marks the buffer as modified, so that it will be saved
at the next suitable occasion.

Don’t use this function in programs, since it prints a message in the echo
area; use ~set-buffer-modified-p~ (above) instead.

**** buffer-modified-tick

This function returns BUFFER’s modification-count.  This is a counter that
increments every time the buffer is modified.

**** buffer-chars-modified-tick

This function returns BUFFER’s character-change modification-count.  Changes to
text properties leave this counter unchanged;

**** with-silent-modifications

Sometimes there’s a need for modifying buffer in a way that doesn’t really
change its text, like if only its text properties are changed.  If your program
needs to modify a buffer without triggering any hooks and features that react
to buffer modifications, use the ~with-silent-modifications~ macro.

**** Buffer Modification Time

When a buffer and its visited file are changed independently of each, saving
the buffer contents into the file would potentially lose new information.
Emacs therefore checks the file’s modification time using the functions
described below before saving the file.

**** verify-visited-file-modtime

This function compares what BUFFER (by default, the current-buffer) has
recorded for the modification time of its visited file against the actual
modification time of the file as recorded by the operating system.  The two
should be the same unless some other process has written the file since Emacs
visited or saved it.

The function returns ‘t’ if the last actual modification time and Emacs’s
recorded modification time are the same, ‘nil’ otherwise.

**** clear-visited-file-modtime

This function clears out the record of the last modification time of the file
being visited by the current buffer.  As a result, the next attempt to save
this buffer will not complain of a discrepancy in file modification times.

**** visited-file-modtime

This function returns the current buffer’s recorded last file modification
time, as a list of the form ‘(HIGH LOW MICROSEC PICOSEC)’.  (This is the same
format that ‘file-attributes’ uses to return time values;

**** set-visited-file-modtime

This function updates the buffer’s record of the last modification time of the
visited file, to the value specified by TIME if TIME is not ‘nil’, and
otherwise to the last modification time of the visited file.

**** ask-user-about-supersession-threat

This function is used to ask a user how to proceed after an attempt to modify a
buffer visiting file FILENAME when the file is newer than the buffer text.

**** Read-Only Buffers

Read-only buffers are used in two kinds of situations:

- A buffer visiting a write-protected file is normally read-only.

- Modes such as Dired and Rmail make buffers read-only when altering the
  contents with the usual editing commands would probably be a mistake.

**** buffer-read-only---a variable

This buffer-local variable specifies whether the buffer is read-only.

**** inhibit-read-only---a variable

If this variable is non-‘nil’, then read-only buffers and, depending on the
actual value, some or all read-only characters may be modified.

**** read-only-mode

This is the mode command for Read Only minor mode, a buffer-local minor mode.
When the mode is enabled, ‘buffer-read-only’ is non-‘nil’ in the buffer; when
disabled, ‘buffer-read-only’ is ‘nil’ in the buffer.

**** barf-if-buffer-read-only

This function signals a ‘buffer-read-only’ error if the current buffer is
read-only.

*** The Buffer List
*** Creating and Killing Buffers

#+texinfo:@heading Creating Buffers

#+cindex:create
There are two primitives for creating buffers, plus several others:

- ~get-buffer-create~ ::

  creates a buffer if it finds no existing buffer with the specified name;

- ~generate-new-buffer~ ::

  always creates a new buffer and gives it a unique name.

- ~with-output-to-temp-buffer~ ::

- ~create-file-buffer~ ::

#+texinfo:@heading Killing Buffers

#+cindex:kill
/Killing a buffer/ makes its name unknown to Emacs and makes the memory space
it occupied available for other use.  The ‘buffer-name’ of a buffer is ‘nil’
if, and only if, the buffer is killed.  If you kill a buffer that is current or
displayed in a window, Emacs automatically selects or displays some other
buffer instead.  Killing a buffer can change the current buffer.  If you kill a
buffer that is the base buffer of one or more indirect buffers, the indirect
buffers are automatically killed as well.

#+cindex:live buffer
A buffer that has not been killed is called a /live/ buffer.  To test whether a
buffer is live or killed, use the function ~buffer-live-p~ (see below).

**** get-buffer-create

#+attr_texinfo: :options get-buffer-create buffer-or-name
#+begin_defun
- BUFFER-OR-NAME :: a buffer of this name is returned.  It does not become the
  current buffer, though.  If the buffer exists, it is returned.  If no such
  buffer exists, a new buffer is created.

  The major mode of a newly-created buffer is set to Fundamental.

  If the buffer name begins with a space, undo information recording is
  disabled.
#+end_defun

**** generate-new-buffer

#+attr_texinfo: :options generate-new-buffer name
#+begin_defun

- NAME :: This function returns a newly created, empty buffer, but does not
  make it current.  The name of the buffer is generated by passing NAME to the
  function [[*generate-new-buffer-name][~generate-new-buffer-name~]].

  The major mode for the new buffer is set to Fundamental mode.
#+end_defun

**** with-output-to-temp-buffer

#+attr_texinfo: :options with-output-to-temp-buffer bufname &rest body
#+begin_defun
Bind ‘standard-output’ to buffer BUFNAME, eval BODY, then show that buffer.
#+end_defun

**** create-file-buffer

#+attr_texinfo: :options create-file-buffer filename
#+begin_defun
Create a suitably named buffer for visiting FILENAME, and return it.
#+end_defun

**** kill-buffer

#+attr_texinfo: :options kill-buffer &optional buffer-or-name
#+begin_defun
- BUFFER-OR-NAME ::

  The buffer (or current buffer if the name is omitted) is killed, freeing all
  its memory.

  Any processes that have this buffer as the /process-buffer/ are sent the
  =SIGHUP= (hangup) signal, which normally causes them to terminate.

  If the buffer to be killed has unsaved changes, the user is asked to
  confirm.  To prevent the request, clear the =modified= flag before calling
  this function.  See [[*Modifying Buffers][Modifying Buffers]].

  This function calls ~replace-buffer-in-windows~ for cleaning up all windows
  currently displaying the buffer to be killed.

- RETURN VALUE ::

  t is returned if the buffer is actually killed.  'nil' is returned if the
  user refuses to confirm or if the buffer is already dead.
#+end_defun

**** kill-buffer-query-functions---a variable

#+attr_texinfo: :options kill-buffer-query-functions
#+begin_defvar
Before confirming unsaved changes, ‘kill-buffer’ calls the functions in the
list ‘kill-buffer-query-functions’, in order of appearance, with no arguments.
The buffer being killed is the current buffer when they are called.  The idea
of this feature is that these functions will ask for confirmation from the
user.  If any of them returns ‘nil’, ‘kill-buffer’ spares the buffer’s life.
#+end_defvar

**** kill-buffer-hook---a permanent local variable

#+attr_texinfo: :options kill-buffer-hook
#+begin_defvar
This is a normal hook run by ‘kill-buffer’ after asking all the questions it is
going to ask, just before actually killing the buffer.  The buffer to be killed
is current when the hook functions run.
#+end_defvar

**** buffer-offer-save---a buffer-local user-option

#+attr_texinfo: :options buffer-offer-save
#+begin_defvar
If non-'nil', tells ~save-buffers-kill-emacs~ to offer to save that buffer.

If ~save-some-buffers~ is called with its second optional argument set to t, it
will also offer to save the buffer.

If set to the symbol =always=, both ~save-buffers-kill-emacs~ and
~save-some-buffers~ will always offer to save.
#+end_defvar

**** buffer-save-without-query---a buffer-local variable

#+attr_texinfo: :options buffer-save-without-query
#+begin_defvar
If non-'nil', tells ~save-buffers-kill-emacs~ and ~save-some-buffers~ to save
this buffer if it is modified without asking.
#+end_defvar

**** buffer-live-p

#+attr_texinfo: :options buffer-live-p object
#+begin_defun
Returns t if OBJECT is a live buffer, or 'nil' otherwise.
#+end_defun

*** Indirect Buffers
#+cindex:indirect buffer
#+cindex:base buffer
An /indirect buffer/ shares the text of some other buffer, which is called the
/base buffer/ of the indirect buffer.

The text of the indirect buffer is always identical to the text of its base
buffer; changes made by editing either one are visible immediately in the
other.

But in all other respects, the indirect buffer and its base buffer are
completely separate.  They can have different names, different values of point,
different narrowing, different markers, different major modes, and different
local variables.

An indirect buffer cannot visit a file, but its base buffer can.  If you try to
save the indirect buffer, that actually works by saving the base buffer.
Killing the base buffer effectively kills the indirect buffer, but killing an
indirect buffer has no effect on its base buffer.

**** make-indirect-buffer

The general way to make an indirect buffer.

#+attr_texinfo: :options make-indirect-buffer base-buffer name &optional clone
#+begin_defun
Create and return an indirect buffer for buffer BASE-BUFFER, named NAME.

- BASE-BUFFER :: should be a live buffer or the name of an existing buffer.

- NAME :: should be a string which is not the name of an existing buffer.

- CLONE :: if non-nil, preserve BASE-BUFFER's state in the indirect buffer; if
  nil, the indirect buffer's state is reset to default values.
#+end_defun

**** clone-indirect-buffer
This function creates and returns a new indirect buffer that shares the current
buffer’s base buffer and copies the rest of the current buffer’s attributes.

If DISPLAY-FLAG is non-‘nil’, as it always is in interactive calls, that means
to display the new buffer by calling ~pop-to-buffer~.

#+attr_texinfo: :options clone-indirect-buffer newname display-flag &optional norecord
#+begin_defun
Create an indirect buffer that is a twin copy of the current buffer.

- NEWNAME :: name to give to the new indirect buffer.  If nil, defaults to the
  current buffer's name, modified by adding an <N> suffix to it, or
  incrementing the N in an existing suffix.

- DISPLAY-FLAG :: if non-nil, show the new buffer with ~pop-to-buffer~.

- NORECORD :: if non-nil, do not put this buffer at the front fo the list of
  recently selected ones.

- RETURN VALUE :: the newly-created indirect buffer.
#+end_defun

**** clone-indirect-buffer-other-window---C-x 4 c

#+attr_texinfo: :options clone-indirect-buffer-other-window NEWNAME DISPLAY-FLAG &optional NORECORD
#+begin_defun
Like ~clone-indirect-buffer~, but display in another window.
#+end_defun

**** buffer-base-buffer

#+attr_texinfo: :options buffer-base-buffer &optional buffer
#+begin_defun
This function returns the base buffer of BUFFER, which defaults to the current
buffer.  If BUFFER is not indirect, the value is ‘nil’.  Otherwise, the value
is another buffer, which is never an indirect buffer.
#+end_defun

*** Swapping Text

**** buffer-swap-text

#+attr_texinfo: :options buffer-swap-text buffer
#+begin_defun
Swap the text between current buffer and BUFFER.

This function is very fast because it doesn’t move any text, it only changes
the internal data structures of the buffer object to point to a different chunk
of text.  Using it, you can pretend that a group of two or more buffers are
actually a single virtual buffer that holds the contents of all the individual
buffers together.

If you use ~buffer-swap-text~ on a file-visiting buffer, you should set up a
hook to save the buffer’s original text rather than what it was swapped with.
~write-region-annotate-functions~ works for this purpose.  You should probably
set ~buffer-saved-size~ to −2 in the buffer, so that changes in the text it is
swapped with will not interfere with auto-saving.
#+end_defun

** Insert File Contents

#+cindex:file, insert
#+cindex:insert file
#+attr_texinfo: :indic code
In a Lisp program, if you want to look at the contents of a file but not alter
it, the fastest way is to use ‘insert-file-contents’ in a temporary buffer.
Visiting the file is not necessary and takes longer.

- insert-file =C-x i= ::

     This function is for interactive use only; in Lisp code use
     ~insert-file-contents~ instead

- insert-file-contents ::

     #+attr_texinfo: :options insert-file-contents @var{filename} &optional @var{visit} @var{end} @var{replace}
     #+begin_defun
     Insert contents of file FILENAME after point.  Returns list of absolute
     file name and number of characters inserted.

     - VISIT if non-nil, the buffer’s visited filename and last save file
       modtime are set, and it is marked unmodified.

     - BEG and END specify what portion of the file to insert.
       These arguments count bytes in the file, not characters in the buffer.
       If VISIT is non-nil, BEG and END must be nil.

     - REPLACE if non-nil, replace the current buffer contents (in the
       accessible portion) with the file contents.  This is better than simply
       deleting and inserting the whole thing because (1) it preserves some
       marker positions and (2) it puts less data in the undo list.  When
       REPLACE is non-nil, the second return value is the number of characters
       that replace previous buffer contents.
     #+end_defun
* Movement

Movement in Emacs is more than characters in a buffer; there’s a host of
supplementary skills that make up navigation, like:

#+cindex:windowing system
- understanding Emacs’s rather complicated windowing system

- movement in Emacs is /local/, /regional/ or /global/.
  #+cindex:local movement
- /local movement/ is what you do when you edit and move around text near to
  the point.
  #+cindex:syntactic unit
- A /syntactic unit/ --- a semi-formal term for commands that operate on a
  group of characters --- is a character, word, line, sentence, paragraph,
  balanced expression, and so forth.
  #+cindex:regional movement
- /regional movement/ involves whole functions or class definitions, if you are
  writing code; or chapters and such constructs, if you are writing prose.
  #+cindex:global movement
- /global movement/ is anything that takes you from one buffer to another, or
  from one window to the next.

#+texinfo:@heading Windows

#+cindex:windows
#+cindex:tiling window manager
Emacs has a penchant for creating windows: when you view a help file, when you
compile a file, or when you open a shell.  Emacs is a /tiling window manager/.

In Emacs, windows are transient; they come and go as you need them.  You can
save your window configuration (and there are several ways of doing this) but
they were never meant to be immutable, like so many editors --- set once and
then never changed again.

#+texinfo:@heading Buffers

#+cindex:buffers
Buffers are rarely killed (that is, closed) when they are no longer needed;
most Emacs hackers will simply switch away to something else, only to return to
it when needed.  That may seem wasteful, but each buffer (aside from assorted
metadata and the buffer’s particular coding system) is only slightly bigger
than the byte size of the characters in it.  A typical Emacs session lasts
weeks between restarts and most Emacs hackers have many hundreds of buffers
running without issue.

** The Basics
Learning the basic key bindings to:

- find and save files,
- change buffers, and
- the bare essentials of day-to-day use


{{{noindent}}}is the first step on the path to mastering Emacs.

#+caption:Basic Commands
#+name:basic-commands
| Key Binding | Command                      | Purpose                                     |
|-------------+------------------------------+---------------------------------------------|
| C-x C-f     | ~find-file~                  | Find and open a file                        |
| C-x C-s     | ~save-buffer~                | Save the buffer                             |
| C-x b       | ~switch-to-buffer~           | Switch buffer                               |
| C-x k       | ~kill-buffer~                | Kill (close) a buffer                       |
| C-x C-b     | ~list-buffers~               | Display all open buffers                    |
| C-x C-c     | ~save-buffers-kill-terminal~ | Exit Emacs                                  |
| esc-esc-esc | ~keyboard-escape-quit~       | Exit the current mode; return to one window |
| C-/         | ~undo~                       | Undo changes                                |
| F-10        | ~menu-bar-open~              | Activate the menu bar                       |
|-------------+------------------------------+---------------------------------------------|

*** find-file =C-x C-f=
#+findex:find-file
To *open* a file is to /find/ or /visit/ it.  The two are synonymous.  If the
file does not exist, Emacs will open an empty buffer associated with that
filename.  If the file exists, Emacs will place the contents into a buffer
associated with that filename.

#+texinfo:@heading Major Mode Load Order

When you visit a file, Emacs will pick a major mode.  Emacs supports an array
of detection mechanisms that can all be changed to suit your needs.  They are
listed here in the order they are applied.

**** File-local variables

**** Program loader directives

**** Magic mode detection

**** Automatic mode detection

*** Coding Systems and Line Endings
Emacs applies two other important heuristics you should know about:
- coding systems and
- line endings.

**** Coding Systems
#+cindex:coding system
Emacs has excellent Unicode support, including:
- transparently reading and writing between different coding systems,
- bidirectional right-to-left script support,
- keyboard input method switching, and more.


#+findex:describe-coding-system
- ~describe-coding-system~ (=C-h C=) ::

  To see the coding system in use for the current buffer.  Emacs will display a
  lot of information, including all the coding systems associated with the
  buffer.  For files, they are almost always set to the same coding system.


The modeline will also provide some information:

: U:**-  helloworld.c       92% of 5k   ...

#+cindex:multi-byte
The first character, =U=, means the buffer ~helloworld.c~ has a *multi-byte*
coding system.

#+cindex:ISO character encoding
If it said =1=, it would typically be part 1 of any number of ISO character
encodings.  The exact mnemonic will depend on which of the hundreds of
supported coding systems you are using.

**** Line Endings
#+cindex:line endings
When you open a file, Emacs will determine the line endings used.

#+cindex:DOS line endings
#+cindex:UNIX line endings
If the file uses DOS or UNIX line endings, they will be preserved when you open
and save a file.

The modeline will tell you what line ending you are using:

: U:**-  helloworld.c       92% of 5k   ...

The : means it’s UNIX-style line endings.  For DOS it would say =(DOS)=.

** Window Management

** Frame Management

** Elemental Movement

** Bookmarks and Registers

[[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#index-bookmarks-559][Bookmarks in Manual §13.8]]

/Bookmarks/ record positions you can jump to.  They have long names, and they
persist automatically from one Emacs session to the next.  The prototypical use
of bookmarks is to record where you were reading in various files.

#+cindex:bookmark
Bookmarks in Emacs work identically to the ones in your web browser but with
the notable exception of supporting a wider variety of sources.  That makes
Emacs’s bookmarking system flexible enough for you to bookmark:

- info pages
- files
- dired directories
- remote files using Emacs' Tramp system


Bookmarks are a very efficient way of jumping to frequently-used files or
directories; it is also useful if there are sections of Emacs’s manual that you
want to return to frequently.  And because of the unified nature of Emacs ---
buffers --- the three are seamlessly stored and recalled from the same list of
bookmarks.

#+cindex:bookmark file
Bookmarks are saved to a bookmark file in ~$HOME/.emacs.d/~ called ~bookmarks~.

#+texinfo:@heading Bookmark File

#+vindex:bookmark-default-file
The variable ~bookmark-default-file~ determines where Emacs stores your
bookmarks.

#+cindex:s-expression
The file is plain text (elisp =s-expressions=, actually) meaning it is possible
edit it manually (if you absolutely must) or merge the files if you regularly
add or remove bookmarks from multiple machines.

Here is a sample entry:

#+begin_src elisp :eval never
("mastering-emacs.org"
 (filename . "~/Dev/Emacs/MasteringEmacs/MasteringEmacs.org")
 (front-context-string . "# -*- mode: org;")
 (rear-context-string)
 (position . 1))
#+end_src

#+texinfo:@heading Bookmark Commands

#+caption: Bookmark Commands
#+name:bookmark-commands
|-------------+---------------------|
| Key Binding | Purpose             |
|-------------+---------------------|
| C-x r m     | Set a bookmark      |
| C-x r l     | List bookmarks      |
| C-x r b     | Jump to a bookmark  |
|-------------+---------------------|

#+texinfo:@heading Register Commands

#+cindex:register
Registers, however, are different; they are the flip side of the coin --- where
bookmarks are permanent, registers are transient.  A /register/ is a
single-character store-and-recall mechanism for several types of data,
including:

- Window configurations and framesets
- Points
- Numbers and Text


A register is a single character only.  When you want to store or recall
something, you are asked for a single character to query.

#+caption:Register Commands
#+name:register-commands
|-------------+----------------------------------------|
| Key Binding | Purpose                                |
|-------------+----------------------------------------|
| C-x r n     | Store number in register               |
| C-x r s     | Store region in register               |
| C-x r SPC   | Store point in register                |
| C-x r +     | Increment number in register           |
| C-x r j     | Jumpt to register                      |
| C-x r i     | Insert content in register             |
| C-x r w     | Store window configuration in register |
| C-x r f     | Store frameset in register             |
|-------------+----------------------------------------|

** Selections and Regions

** Searching and Indexing

** Other Movement Commands

* Editing
** Killing and Yanking

** Transposing Text

** Filling and Commenting

** Searching and Replacing

#+cindex:regular expression
When you search for text, you can do so either with regular expressions or
without.  Replacing text in Emacs is no different, but with the added benefit
of letting you leverage the power of elisp in the /replace/ portion of search
and replace.

In that sense, Emacs is different from other editors: you can use elisp and
regexp capturing groups together --- powerful, if you know elisp.

#+cindex:PCRE
#+cindex:regular expression, GNU standard
Emacs’s regular expression implementation is also different from PCRE.  It
follows the GNU standard for regular expressions with many additions (and quite
a few omissions) to make it suitable for both package developers and Emacs
users.

*** Regular Expressions

#+cindex:regexp
Emacs’s regexp engine is nowhere near as user-friendly as it could be.  It’s
old, weathered and too entrenched --- and heavily modified to suit Emacs’s
peculiar needs --- to be easily replaced.  In practical terms, that causes
confusion in regexp building for people unaccustomed to Emacs’s quirky regexp
engine.  It’s even worse if you write elisp as you have to escape the escape
character as Emacs’s C-style string reader would otherwise trigger on
backslashes.

I will not cover regular expressions in great detail since that is a whole book
onto itself.  Instead, I will tell you how Emacs’s regexp engine differs from
modern ones.

**** Backslashed Constructs

The following constructs require backslashes or Emacs will treat them like
literal characters:

| Construct | Description     |
|-----------+-----------------|
| =\pipe=   | Alternative     |
| =\(...\)= | Capturing group |
| =\{...\}= | Repetition      |
|-----------+-----------------|


See also [[*Backslash Constructs][Backslash Constructs]]

**** Missing Features

**** Emacs-Only Features

#+cindex:match construct
#+cindex:Unicode
One area where Emacs’s regexp engine does shine is its support for /match
constructs/ and /Unicode support/:

#+caption:Match Constructs and Unicode Support
#+name:match-constructs-and-unicode-support
| Constructs   | Description                                               |
|--------------+-----------------------------------------------------------|
| =\<=, =\>=   | Matches beginning and end of word                         |
| =\_<=, =\_>= | Matches beginning and end of symbol                       |
| =\scode=     | Matches any character whose syntax table code is code     |
| =\Scode=     | Matches any character whose syntax table code is not code |
|--------------+-----------------------------------------------------------|

**** Syntax of Regular Expressions

#+cindex:syntax, regexp
#+cindex:regexp syntax
Regular expressions have a syntax in which a few characters are “special
constructs” and the rest are “ordinary”.

#+texinfo:@heading Special Characters

#+cindex:special characters, regexp
#+cindex:regexp special characters
The “special characters” are:

#+attr_texinfo: :indic code
- .
- *
- +
- ?
- [ and sometimes ]
- [: ... :]
- ^
- $
- \
- -


Any other character appearing in a regular expression is ordinary, unless a ‘\’
precedes it.

Things to note:

#+texinfo: :indic code
- ^ :: For historical compatibility reasons, ‘^’ can be used only at the
  beginning of the regular expression, or after ‘\(’, ‘\(?:’ or ‘\|’.

- $ :: For historical compatibility reasons, ‘$’ can be used only at the end of
  the regular expression, or before ‘\)’ or ‘\|’.

- \ :: also has special meaning in the read syntax of Lisp strings and must be
  quoted with ‘\’.

#+begin_example
\\   => \
\\\\ => \\
#+end_example

#+texinfo:@heading Character Alternatives

=[ ... ]= is a /character alternative/.

#+attr_texinfo: :indic code
- [ad] ::
- [a-z] ::
- [a-z$%.] ::
- []a-z]  :: To include a ‘]’ in a character alternative, you must make it the
  first character.
- []a-z-] :: To include a ‘-’, write ‘-’ as the first or last character of the
  character alternative, or as the upper bound of a range.
- ^ :: To include ‘^’ in a character alternative, put it anywhere but at the
  beginning.
  #+cindex:newline, regexp
- [^...] :: ‘[^’ begins a “complemented character alternative”.  This matches
  any character except the ones specified.  ‘^’ is not special in a character
  alternative unless it is the first character.  A complemented character
  alternative can match a newline, unless newline is mentioned as one of the
  characters not to match.  This is in contrast to the handling of regexps in
  programs such as ‘grep’.


#+texinfo:@heading Rules Regarding ]

The exact rules are that:
- at the beginning of a regexp, ‘[’ is special and ‘]’ not.
- This lasts until the first unquoted ‘[’,
  - after which we are in a character alternative;
  - ‘[’ is no longer special
    - (except when it starts a character class)
  - but ‘]’ is special,
    - unless it immediately follows the special ‘[’ or
    - that ‘[’ followed by a ‘^’.
  - This lasts until the next special ‘]’ that does not end a character class.
- This ends the character alternative and restores the ordinary syntax of regular expressions;
- an unquoted ‘[’ is special again and a ‘]’ not.

#+texinfo:@heading POSIX Features

#+cindex:POSIX regexp
The following aspects of ranges are specific to Emacs, in that POSIX allows but
does not require this behavior and programs other than Emacs may behave
differently:

#+vindex:case-fold-search
#+cindex:collation sequence
#+cindex:unibyte character
1. If ~case-fold-search~ is non-‘nil’, =[a-z]= also matches upper-case letters.

2. A range is not affected by the locale’s collation sequence: it always
   represents the set of characters with codepoints ranging between those of
   its bounds, so that =[a-z]= matches only ASCII letters, even outside the C
   or POSIX locale.

3. As a special case, if either bound of a range is a raw 8-bit byte, the other
   bound should be a unibyte character, and the range matches only unibyte
   characters.

4. If the lower bound of a range is greater than its upper bound, the range is
   empty and represents no characters.  Thus, ‘[b-a]’ always fails to match,
   and ‘[^b-a]’ matches any character, including newline.  However, the lower
   bound should be at most one greater than the upper bound; for example,
   ‘[c-a]’ should be avoided.

5. A character alternative can also specify [[*Char Classes][named character classes]].  This is
   a POSIX feature.  Using a character class is equivalent to mentioning each
   of the characters in that class; but the latter is not feasible in practice,
   since some classes include thousands of different characters.  A character
   class should not appear as the lower or upper bound of a range.

**** Syntax Classes

#+cindex:syntax classes
#+cindex:classes, regexp syntax
#+cindex:regexp, syntax classes
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html#Syntax-Class-Table][Table of Syntax Classes]]

**** Char Classes

#+cindex:char classes, regexp
#+cindex:classes, regexp char
#+cindex:regexp, char classes
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Char-Classes.html#Char-Classes][Character Classes]]

**** Backslash Constructs

#+cindex:backslash, regexp
#+cindex:regexp backslash
For the most part, =\= followed by any character matches only that character.
However, there are several exceptions: certain sequences starting with =\= that
have special meanings.  Here is a table of the special =\= constructs.

- =\|= :: an alternative
- =\{M\}= :: repeat the previous pattern exactly M times
- =\{M,N\}= :: specifies repetition
- =\(...\)= :: a grouping construct
- =\(?:...\)= :: the “shy group” (“non-capturing” or “unnumbered”) construct
- =\(?NUM:...\)= :: the “explicitly numbered group” construct
- =\DIGIT= :: matches the same text that matched DIGITth occurrence of a group
- =\w= :: matches any word-constituent character
- =\W= :: matches any character that is not a work constituent
- =\sCODE= :: matches any character whose syntax is CODE
- =\SCODE= :: matches any character whose syntax is not CODE
- =\cC= :: matches any character whose category is C. =M-x describe-categories=
- =\CC= :: matches any character whose category is not C


The following regular expression constructs match the empty string---that is,
they don’t use up any characters---but whether they match depends on the
context.

#+attr_texinfo: :indic code
- \` :: matches the empty string, but only at the beginning of the buffer or
  string being matched against.
- \' :: matches the empty string, but only at the end of the buffer or string
  being matched against.
- \= :: matches the empty string, but only at point.
- =\b= :: matches the empty string, but only at the beginning or end of a word.
- =\B= :: matches the empty string, but _not_ at the beginning or end of a
  word, nor at the beginning or end of the buffer (or string)
- \< :: matches the empty string, but only at the beginning of a word.
- \> :: matches the empty string, but only at the end of a word.
- \_< :: matches the empty string, but only at the beginning of a symbol.
- \_> :: matches the empty string, but only at the end of a symbol.

*** Regular Expression Functions
These functions operate on regular expressions.

**** regexp-quote

#+attr_texinfo: :options regexp-quote string
#+begin_defun
This function returns a regular expression whose only exact match is STRING.
This allows you to request an exact string match or search when calling a
function that wants a regular expression.
#+end_defun

**** regexp-opt

#+attr_texinfo: :options regexp-opt strings &optional paren
#+begin_defun
This function returns an efficient regular expression that will match any of
the strings in the list STRINGS.  This is useful when you need to make matching
or searching as fast as possible—for example, for Font Lock mode.

- STRINGS :: list of strings

- PAREN :: The optional argument PAREN can be any of the following:

  - a string :: The resulting regexp is preceded by PAREN and followed by ‘\)’;
    =\\(?1:=

  - words :: The resulting regexp is surrounded by ‘\<\(’ and ‘\)\>’.

  - symbols :: The resulting regexp is surrounded by ‘\_<\(’ and ‘\)\_>’

  - non-nil :: The resulting regexp is surrounded by ‘\(’ and ‘\)’.

  - nil :: The resulting regexp is surrounded by ‘\(?:’ and ‘\)’
#+end_defun

**** regexp-opt-charset

#+attr_texinfo: :options regexp-opt-depth regexp
#+begin_defun
This function returns the total number of grouping constructs (parenthesized
expressions) in REGEXP.  This does not include shy groups.
#+end_defun

**** regexp-opt-charset chars

#+attr_texinfo: :options regexp-opt-charset chars
#+begin_defun
This function returns a regular expression matching a character in the list of
characters CHARS.
#+end_defun

*** Regular Expression Searching in Programs

**** re-search-forward

#+attr_texinfo: :options re-search-forward regexp &optional limit noerror count
#+begin_defun
This function searches forward in the current buffer for a string of text that
is matched by the regular expression REGEXP.  The function skips over any
amount of text that is not matched by REGEXP, and leaves point at the end of
the first match found.  It returns the new value of point.

- REGEXP :: The regexp to match against

- LIMIT :: The upper bound to the search, unless nil

- NOERROR :: What ‘re-search-forward’ does when the search fails depends on the
  value of NOERROR:

  - nil :: Signal a ‘search-failed’ error.

  - t :: Do nothing and return ‘nil’.

  - other :: Move point to LIMIT (or the end of the accessible portion of the
    buffer) and return ‘nil’.

- COUNT :: If COUNT is positive number, N, search N times.  If all searches
  succeed, function call succeeds, moves point and return point’s new value.
  Otherwise, function call fails.

  If COUNT is a negative number -N, the search is done N times in the backward
  direction.

- RETURN VALUE :: Upon success, the value of point; nil on failure.
#+end_defun

**** string-match

#+attr_texinfo: :options string-match regexp string &optional start
#+begin_defun
This function returns the index of the start of the first match for the regular
expression REGEXP in STRING, or ‘nil’ if there is no match

- REGEXP :: regexp to match against

- STRING :: string to use for match

- START :: if non-nil, start search at that index in STRING

- RETURN VALUE :: index of the start of the first match in STRING, or nil if
  there is no match.
  #+findex:match-end
- ~(match-end 0)~ :: If this function finds a match, the index of the first
  character beyond the match is available as ‘(match-end 0)’.


You can use the function <<match-string>> [[*match-string][~match-string~]] to extract the
substrings matched by the parenthesis constructions in REGEXP.
#+end_defun

**** string-match-p

#+attr_texinfo: :options string-match-p regexp string &optional start
#+begin_defun
This predicate function does what ~string-match~ does, but it avoids modifying
the match data.
#+end_defun

**** looking-at

#+attr_texinfo: :options looking-at regexp
#+begin_defun
This function determines whether the text in the current buffer directly
following point matches the regular expression REGEXP.  The result is ‘t’ if
so, ‘nil’ otherwise.  This function does not move point, but it does update the
match data.
#+end_defun

**** looking-at-p

#+attr_texinfo: :options looking-at-p regexp
#+begin_defun
This predicate function works like ‘looking-at’, but without updating the match
     data.
#+end_defun

**** looking-back

#+attr_texinfo: :options looking-back regexp limit &optional greedy
#+begin_defun
This function returns ‘t’ if REGEXP matches the text immediately before point
(i.e., ending at point), and ‘nil’ otherwise.

- REGEXP :: the regexp to match against

- LIMIT :: You can bound the time required by specifying a non-‘nil’ value for
  LIMIT, which says not to search before LIMIT.

- GREEDY :: If GREEDY is non-‘nil’, this function extends the match backwards
  as far as possible, stopping when a single additional previous character
  cannot be part of a match for REGEXP.  When the match is extended, its
  starting position is allowed to occur before LIMIT.
#+end_defun

**** search-spaces-regexp---a variable

#+attr_texinfo: :options search-spaces-regexp
#+begin_defun
If this variable is non-‘nil’, it should be a regular expression that says how
to search for whitespace.  In that case, any group of spaces in a regular
expression being searched for stands for use of this regular expression.

Since this variable affects all regular expression search and match constructs,
you should bind it temporarily for as small as possible a part of the code.
#+end_defun

*** Replacing Text Using Match Data

#+cindex:match data
Emacs keeps track of the start and end positions of the segments of text found
during a search; this is called the “match data”.

All functions are allowed to overwrite the match data unless they’re explicitly
documented not to do so.  A consequence is that functions that are run
implicitly in the background should likely save and restore the match data
explicitly.

**** replace-match

This function replaces all or part of the text matched by the last search.  It
works by means of the match data.

#+attr_texinfo: :options replace-match replacement &optional fixedcase literal string subexp
#+begin_defun
This function performs a replacement operation on a buffer or string.

- REPLACEMENT :: The String to replace the matched text

- FIXEDCASE :: If FIXEDCASE is non-‘nil’, then ~replace-match~ uses the
  replacement text without case conversion; otherwise, it converts the
  replacement text depending upon the capitalization of the text to be
  replaced.

- LITERAL :: If LITERAL is non-‘nil’, then REPLACEMENT is inserted exactly as
  it is, the only alterations being case changes as needed.  If it is ‘nil’
  (the default), then the character ‘\’ is treated specially.

  If a ‘\’ appears in REPLACEMENT, then it must be part of one of the following
  sequences:

  - =\&= :: This stands for the entire text being replaced.

  - =\N= :: where N is a digit; this stands for the text that matched the Nth
    subexpression in the original regexp.

  - =\\= :: This stands for a single ‘\’ in the replacement text.

  - =\?= :: This stands for itself (for compatibility with ‘replace-regexp’ and
    related commands;

  - any other :: error

- STRING :: If you performed the last search on a string, pass the same string
  as STRING.  Then this function returns a new string, in which the matched
  text is replaced by REPLACEMENT.

- SUBEXP :: If SUBEXP is non-‘nil’, that says to replace just subexpression
  number SUBEXP of the regexp that was matched, not the entire match.
#+end_defun

#+texinfo:@heading Replace All Matches in Part of a Buffer

If you want to find all matches for a regexp in part of the buffer, and replace
them, the best way is to write an explicit loop using [[*re-search-forward][~re-search-forward~]] and
~replace-match~, like this:

#+begin_src elisp :eval no
  (while (re-search-forward "foo[ \t]+bar" nil t)
    (replace-match "foobar"))
#+end_src

Replacing matches in a string is more complex, especially if you want to do it
efficiently.  So Emacs provides a function to do this: [[*replace-regexp-in-string][~replace-regexp-in-string~]].

**** match-substitue-replacement

#+attr_texinfo: :options match-substitute-replacement replacement &optional fixedcase literal string subexp
#+begin_defun
This function returns the text that would be inserted into the buffer by
‘replace-match’, but without modifying the buffer.

It is useful if you want to present the user with actual replacement result,
with constructs like ‘\N’ or ‘\&’ substituted with matched groups.

Arguments REPLACEMENT and optional FIXEDCASE, LITERAL, STRING and SUBEXP have
the same meaning as for ‘replace-match’.

#+end_defun
**** replace-regexp-in-string

#+attr_texinfo: :options replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
#+begin_defun

This function uses [[*replace-match][~replace-match~]] to do the replacement.

- REGEXP :: the regexp to use

- REP :: replacement string or function.

  If a function, ~replace-regexp-in-string~ calls REP for each match, passing
  the text of the match as its sole argument.  It collects the value REP
  returns and passes that to ~replace-match~ as the replacement string.

- STRING :: string to search; this function copies STRING and searches it for
  matches for REGEXP, and replaces them with REP.

- FIXEDCASE :: passed to ~replace-match~

- LITERAL :: passed to ~replace-match~

- SUBEXP :: passed to ~replace-match~

- START :: If START is non-‘nil’, the search for matches starts at that index
  in STRING, so matches starting before that index are not changed.

- RETURN VALUE :: It returns the modified copy.
#+end_defun

**** perform-replace

If you want to write a command along the lines of ~query-replace~, you can use
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Search-and-Replace.html#Search-and-Replace][~perform-replace~]] to do the work.

#+attr_texinfo: :options perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end backward region-noncontiguous-p
#+begin_defun
This function is the guts of ‘query-replace’ and related commands.

It searches for occurrences of FROM-STRING in the text between positions START
and END and replaces some or all of them.  If START is ‘nil’ (or omitted),
point is used instead, and the end of the buffer’s accessible portion is used
for END.  (If the optional argument BACKWARD is non-‘nil’, the search starts at
END and goes backward.)
#+end_defun

*** Accessing Matched Text Using Match Data
This section explains how to use the match data to find out what was matched by
the last search or match operation, if it succeeded.

Every successful search sets the match data.  You should query the match data
immediately after searching, before calling any other function that might
perform another search, or save and restore the match data around the call to
functions that could perform another search, or use the functions that
explicitly do not modify the match data.

You can ask about the entire matching text, or about a particular parenthetical
subexpression of a regular expression, using the COUNT argument.

- If count is zero, you are asking about the entire match.
- If count is positive, it specifies which subexpression you want.

**** match-string

#+attr_texinfo: :options match-string count &optional in-string
#+begin_defun

- COUNT :: if zero, return the entire matched text; if positive integer,
  return the COUNTth matched parenthetical subexpression.

- IN-STRING :: If the last such operation was done against a string with
  [[match-string][~string-match~]], then you should pass the same string as the argument
  IN-STRING.

  After a buffer search or match, you should omit IN-STRING or pass ‘nil’ for
  it; but you should make sure that the current buffer when you call
  ~match-string~ is the one in which you did the searching or matching.

- RETURN VALUE :: The matched text or a portion of the matched text as a string
  depending on the value of COUNT.

  The value is ‘nil’ if COUNT is out of range, or for a subexpression inside a
  ‘\|’ alternative that wasn’t used or a repetition that repeated zero times.

#+end_defun

**** match-string-no-properties

#+attr_texinfo: :options match-string-no-properties count &optional in-string
#+begin_defun
This function is like ~match-string~ except that the result has no text
properties.
#+end_defun

**** match-beginning

#+attr_texinfo: :options match-beginning count
#+begin_defun
If the last regular expression search found a match, this function returns the
position of the start of the matching text or of a subexpression of it.

- COUNT :: If COUNT is zero, then the value is the position of the start of the
  entire match.  Otherwise, COUNT specifies a subexpression in the regular
  expression, and the value of the function is the starting position of the
  match for that subexpression.

  The value is ‘nil’ for a subexpression inside a ‘\|’ alternative that wasn’t
  used or a repetition that repeated zero times.
#+end_defun

**** match-end

#+attr_texinfo: :options match-end count
#+begin_defun
This function is like ~match-beginning~ except that it returns the position of
the end of the match, rather than the position of the beginning.
#+end_defun

**** match-data

#+attr_texinfo: :options match-data &optional integers reuse reseat
#+begin_defun
This function returns a list of positions (markers or integers) that record all
the information on the text that the last search matched.

- RETURN VALUE ::

  - Element zero is the position of the beginning of the match for the whole
    expression;

  - element one is the position of the end of the match for the expression.

  - The next two elements are the positions of the beginning and end of the match
    for the first subexpression, and so on.

  - In general, element number 2N corresponds to ‘(match-beginning N)’; and
  element number 2N + 1 corresponds to ‘(match-end N)’.

- INTEGERS :: Applies only to buffer searches; normally all the elements are
  markers or ‘nil’, but if INTEGERS is non-‘nil’, that means to use integers
  instead of markers.  (In that case, the buffer itself is appended as an
  additional element at the end of the list, to facilitate complete restoration
  of the match data.)

- REUSE :: If REUSE is non-‘nil’, it should be a list.  In that case,
  ‘match-data’ stores the match data in REUSE.  REUSE is destructively
  modified.  The purpose of this feature is to reduce the need for garbage
  collection.

- RESEAT :: If RESEAT is non-‘nil’, all markers on the REUSE list are reseated
  to point to nowhere.
#+end_defun

**** set-match-data

#+attr_texinfo: :options set-match-data match-list &optional reseat
#+begin_defun
This function sets the match data from the elements of MATCH-LIST, which should
be a list that was the value of a previous call to ‘match-data’.

If RESEAT is non-‘nil’, all markers on the MATCH-LIST list are reseated to
point to nowhere.
#+end_defun

**** save-match-data

#+attr_texinfo: :options save-match-data body
#+begin_defun
This macro executes BODY, saving and restoring the match data around it.  The
return value is the value of the last form in BODY.
#+end_defun

*** Using RE Builder Command

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Regular-Expressions.html#Regular-Expressions


For interactive development of regular expressions, you can use the =M-x
re-builder= command.  It provides a convenient interface for creating regular
expressions, by giving immediate visual feedback in a separate buffer.  As you
edit the regexp, all its matches in the target buffer are highlighted.  Each
parenthesized sub-expression of the regexp is shown in a distinct face, which
makes it easier to verify even very complex regexps.

#+attr_texinfo: :options re-builder
#+begin_defun
Construct a regexp interactively.

This command makes the current buffer the "target" buffer of
the regexp builder.  It displays a buffer named "*RE-Builder*"
in another window, initially containing an empty regexp.

As you edit the regexp in the "*RE-Builder*" buffer, the
matching parts of the target buffer will be highlighted.
#+end_defun

** Changing Case

** Counting

** Text Manipulation

** Keyboard Macros

** Text Expansion

** Indenting

#+cindex:indentation
“Indentation” refers to inserting or adjusting “whitespace characters” (space
and/or tab characters) at the beginning of a line of text.

#+heading:Enter a =<TAB>= Character
#+cindex:TAB character, enter
If you just want to insert a tab character in the buffer, type =C-q <TAB>=.
This always inserts a tab character, regardless of the value of
‘indent-tabs-mode’.

#+findex:indent-for-tab-command
#+cindex:TAB key
The simplest way to perform indentation is the =<TAB>= key.  In most major
modes, this runs the command ~indent-for-tab-command~.  The exact behavior of
=<TAB>= depends on the major mode.

In Text mode and related major modes, <TAB> normally inserts some combination
of space and tab characters to advance point to the next tab stop.  For this
purpose, the position of the first non-whitespace character on the preceding
line is treated as an additional tab stop, so you can use <TAB> to align point
with the preceding line.

If the region is active (*note Using Region::), =<TAB>= acts specially: it
indents each line in the region so that its first non-whitespace character is
aligned with the preceding line.

*** Electric Indent Mode
#+cindex:electric indent mode
In Emacs 24.4 a new minor mode called /electric indent mode/ now handles
intelligent indentation when you press RET.

**** Indenting New Lines
#+findex:electric-indent-mode
When you press =RET= Emacs will insert a newline character and then invoke the
major mode’s indentation engine.  For this to work, you have to enable the
minor mode ~electric-indent-mode~.

#+findex:newline-and-indent
- newline-and-indent ::

  Insert a NEWLINE, then indent according to major mode.  Indentation is done
  using the value of ‘indent-line-function’.  In programming language modes,
  this is the same as =TAB=.  In some text modes, where =TAB= inserts a tab,
  this command indents to the column specified by the function
  ‘current-left-margin’.


With electric indent, Emacs now also checks if you type certain block
characters --- like Python’s =:= or ={= and =}= in C --- and automatically
re-indents the current line.

**** Indenting the Current Line
#+findex:indent-for-tab-command
#+vindex:indent-line-function
#+findex:indent-region
When you press =TAB=, Emacs usually calls ~indent-for-tab-command~, a generic
proxy command that either indents your code or attempts to =TAB=-complete the
word at the point.

- indent-for-tab-command &optional ARG ::

  Indent the current line or region, or insert a tab, as appropriate.  This
  function either inserts a tab, or indents the current line, or performs
  symbol completion, depending on ‘tab-always-indent’.  The function called to
  actually indent the line or insert a tab is given by the variable
  ‘indent-line-function’.

  If a prefix argument is given, after this function indents the current line
  or inserts a tab, it also rigidly indents the entire balanced expression
  which starts at the beginning of the current line, to reflect the current
  line’s indentation.

  If ‘transient-mark-mode’ is turned on and the region is active, this function
  instead calls ‘indent-region’.  In this case, any prefix argument is ignored.


Some major modes override the =TAB= key and instead call their own specialized
indent command --- one example is the C major mode.

However, pressing =TAB= (or ~M-x indent-for-tab-command~) will, if its 
heuristic determines that it should indent, call the indentation function
stored in the variable ~indent-line-function~.

#+vindex:tab-always-indent
The variable ~tab-always-indent~ governs Emacs’s behavior when you press =TAB=.
Usually, it just indents but it also has a completion mechanism, though
seldomly used.

If ~tab-always-indent~ is ‘t’, hitting =TAB= always just indents the current
line.  If nil, hitting TAB indents the current line if point is at the left
margin or in the line’s indentation, otherwise it inserts a "real" TAB
character.  If ‘complete’, TAB first tries to indent the current line, and if
the line was already indented, then try to complete the thing at point.

#+vindex:intent-tabs-mode
If you dislike the use of tab characters and if you prefer whitespace,
customize the variable ~indent-tabs-mode~.  Indentation can insert tabs if this
is non-nil.

#+vindex:tab-width
The variable ~tab-width~ controls how many characters of spacing each tab uses.
It also controls the amount of whitespace to use if you disabled
~indent-tabs-mode~.

Finally, when Emacs indents it calls the aforementioned function in
~indent-line-function~.  The default function is ~indent-relative~, a command
that inserts an actual tab character.  Modes such as =text-mode= and
=fundamental-mode= (the default mode for a new, empty buffer) uses
~indent-relative~.  Most programming modes do not.

#+texinfo:@heading Tab Stops
#+findex:edit-tab-stops
#+findex:tabs-to-tab-stop
There is also the concept of tab stops in Emacs and you can edit the tab stops
by typing ~M-x edit-tab-stops~ and inserting =:= characters where you want
Emacs to set the tab point.  Subsequent calls to =M-i= (which calls the command
~M-x tabs-to-tab-stop~) then insert tab stops, by way of whitespace and tab
characters.

*** Indenting Regions
Regions are even more difficult to indent. How do you safely indent a region
Python code when block indentation determines program flow?  The answer is ---
you don’t.

There are two types of region indentation commands:

- “intelligent” ones that ask your major mode’s indentation engine for advice –
  something that works well with languages like HTML or C;

- and plain, fixed-width indentation for the rest.


- =TAB= :: Indents a line or region as per the major mode

- =C-M-\= :: Indents using major mode’s region indent command

- =C-x TAB= :: Rigidly indents

*** Program Indent
In programming modes, =<TAB indents the current line of code in a way that
makes sense given the code in the preceding lines.  If the region is active,
all the lines in the region are indented this way.  If point was initially
within the current line’s indentation, it is repositioned to the first
non-whitespace character on the line.

*** Tabs versus Spaces
#+vindex:indent-tabs-mode
If you prefer, all indentation can be made from spaces only.  By using spaces
only, you can make sure that your file always looks the same.

- indent-tabs-mode :: set this buffer-local variable to nil


#+vindex:tab-width
If you only care about how it looks within Emacs, another way to tackle this
problem is to set the ~tab-width~ variable in a file-local variable.

**** Convert Tabs to Spaces and Vice Versa
There are also commands to convert tabs to spaces or vice versa, always
preserving the columns of all non-whitespace text.

- tabify :: scans the region for sequences of spaces, and converts sequences of
  at least two spaces to tabs if that can be done without changing indentation.

- untabify :: changes all tabs in the region to appropriate numbers of spaces.

**** Tab Always Indent
#+vindex:tab-always-indent
The variable ~tab-always-indent~ tweaks the behavior of the =<TAB>=
(‘indent-for-tab-command’) command.  The default value, ‘t’, gives the behavior
described in *note Indentation::.  If you change the value to the symbol
=complete=, then =<TAB>= first tries to indent the current line, and if the
line was already indented, it tries to complete the text at point.  If the
value is ‘nil’, then =<TAB>= indents the current line only if point is at the
left margin or in the line’s indentation; otherwise, it inserts a tab
character.

** Sorting and Aligning

** Zapping

** Spell Checking

** Quoted Insert

** Comparing Diffing and Merging
{{{heading(Diff Mode)}}}

=M-x diff= command produces Diff mode, which displays the differences between
two files in a =*diff*= buffer through running the ~diff~ program.  Switches
are found in the ~diff-switches~ variable (the default is =-u=, a unified
context diff).

{{{heading(Ediff Package)}}}

Ediff is a more sophisticated alternative to Diff mode.  See info:ediff.

{{{heading(Comparing a File to a Backup)}}}

=M-x diff-backack= compares a file with its most recent backup.  If you specify
the name of a backup file, this command compares it with the source file
instead.  Otherwise, it is the same as =M-x diff=.

{{{heading(Compare a Buffer with its File)}}}

=M-x diff-buffer-with-file= compares a specified buffer with its corresponding
file.  This shows you what changes you would make to the file if you save the
buffer.

{{{heading(Compare Windows)}}}

=M-x compare-windows= compares the text in the current window with that in the
window that was the selected window before you selected the current one.

{{{heading(Smerge Mode)}}}

=M-x smerge-mode= turns on Smerge mode, a minor mode for editing output from
the ‘diff3’ program.

{{{heading(Emerge)}}}

The Emerge commands compare two files or buffers, and display the comparison in
three buffers: one for each input text (the “A buffer” and the “B buffer”), and
one (the “merge buffer”) where merging takes place.  The merge buffer shows the
full merged text, not just the differences.  Wherever the two input texts
differ, you can choose which one of them to include in the merge buffer.

- =M-x emerge-files= :: to merge two specific files.

- =M-x emerge-files-with-ancestor= :: to merge two files with reference to a
     common ancestor.

- =M-x emerge-buffers= :: to merge two buffers

- =M-x emerge-buffers-with-ancestor= :: to merge two buffers with reference to
     a common ancestor in a third buffer.

*** Diff Mode
#+cindex:diff mode
Used for the output of =M-x diff=.  Select Diff mode manually with =M-x
diff-mode=.

- =M-x diff= ‘(diff OLD NEW &optional SWITCHES)’ :: Find and display the
     differences between OLD and NEW files.  When called interactively, read
     NEW, then OLD, using the minibuffer.  The default for NEW is the current
     buffer’s file name, and the default for OLD is a backup file for NEW, if
     one exists.  When called interactively with a prefix argument, prompt
     interactively for diff switches.  Otherwise, the switches specified in the
     variable ‘diff-switches’ are passed to the diff command.

{{{heading(Hunks)}}}

#+cindex:hunks
#+cindex:hunk header
The changes specified in a patch are grouped into “hunks”, which are contiguous
chunks of text that contain one or more changed lines.  Each hunk is preceded
by a “hunk header”, which specifies the old and new line numbers where the
hunk’s changes occur.  Diff mode highlights each hunk header

{{{subheading(File Header)}}}

#+cindex:file header
The first hunk in a patch is preceded by a file header, which shows the names
of the new and the old versions of the file, and their time stamps.

{{{subheading(Editing Hunks)}}}

- =M-n= ‘(diff-hunk-next)’ :: Move to the next hunk-start (‘diff-hunk-next’).
     With prefix argument N, move forward to the Nth next hunk.

- =M-p= ‘(diff-hunk-prev)’ :: Move to the previous hunk-start
     (‘diff-hunk-prev’).  With prefix argument N, move back to the Nth previous
     hunk.

- =M-}= ‘(diff-file-next)’ :: Move to the next file-start, in a multi-file
     patch (‘diff-file-next’).  With prefix argument N, move forward to the
     start of the Nth next file.

- =M-{= ‘(diff-file-pref)’ :: Move to the previous file-start, in a multi-file
     patch (‘diff-file-prev’).  With prefix argument N, move back to the start
     of the Nth previous file.

- =M-k= ‘(diff-hunk-kill)’ :: Kill the hunk at point (‘diff-hunk-kill’).

- =M-K= ‘(diff-file-kill)’ :: In a multi-file patch, kill the current file
     part.  (‘diff-file-kill’).

- =C-c C-a= ‘(diff-apply-hunk)’ :: Apply this hunk to its target file
     (‘diff-apply-hunk’).  With a prefix argument of ‘C-u’, revert this hunk,
     i.e. apply the reverse of the hunk, which changes the “new” version into
     the “old” version.

- =C-c C-b= ‘(diff-refine-hunk)’ :: Highlight the changes of the hunk at point
     with a finer granularity (‘diff-refine-hunk’).  This allows you to see
     exactly which parts of each changed line were actually changed.

- =C-c C-c= ‘(diff-goto-source)’ :: Go to the source file and line
     corresponding to this hunk (‘diff-goto-source’).  By default, this jumps
     to the “new” version of the file, the one shown first on the file header.
     With a prefix argument, jump to the “old” version instead.

- =C-c C-e= ‘(diff-ediff-patch)’ :: Start an Ediff session with the patch
     (‘diff-ediff-patch’).  See info:ediff

- =C-c C-n= ‘(diff-restrict-view)’ :: Restrict the view to the current hunk
     (‘diff-restrict-view’).  *Note info:emacs#Narrowing.  With a prefix argument,
     restrict the view to the current file of a multiple-file patch.  To widen
     again, use ‘C-x n w’ (‘widen’).

- =C-c C-d= ‘(diff-unified->context)’ :: Convert the entire buffer to the
     “context diff format” (‘diff-unified->context’).  With a prefix argument,
     convert only the hunks within the region.

- =C-c C-u= ‘(diff-context->unified)’ :: Convert the entire buffer to unified
     diff format (‘diff-context->unified’).  With a prefix argument, convert
     unified format to context format.  When the mark is active, convert only
     the hunks within the region.

- =C-c C-w= ‘(diff-ignore-whitespace-hunk)’ :: Re-generate the current hunk,
     disregarding changes in whitespace (‘diff-ignore-whitespace-hunk’).

- =C-x 4 A= ‘(diff-add-change-log-entries-other-window)’ :: Generate a
     ChangeLog entry, like ‘C-x 4 a’ does (*note [[info:emacs#Change%20Log]]), for
     each one of the hunks.

*** eDiff Mode
See [[info:ediff][Ediff]]

Ediff is a comprehensive visual interface to Unix diff and patch utilities.

*** sMerge
~smerge-mode~ is a minor mode to simplify editing output from the ~diff3~
program.  This is typically the result of a failed merge from a version control
system update outside VC, due to conflicting changes to a file.  Smerge mode
provides commands to resolve conflicts by selecting specific changes.

*** eMerge
See info:emacs#Emerge

{{{noindent}}}See [[info:emacs#Merge%20Commands]]

It’s not unusual for programmers to get their signals crossed and modify the
same program in two different directions.  To recover from this confusion, you
need to merge the two versions.

- =M-x emerge-files= :: Merge two specified files.

- =M-x emerge-files-with-ancestor= :: Merge two specified files, with reference
     to a common ancestor.

- =M-x emerge-buffers= :: Merge two buffers.

- =M-x emeerge-buffers-with-ancestor= :: Merge two buffers with reference to a
     common ancestor in a third buffer.


The Emerge commands compare two files or buffers, and display the comparison in
three buffers: one for each input text (the “A buffer” and the “B buffer”), and
one (the “merge buffer”) where merging takes place.  The merge buffer shows the
full merged text, not just the differences.  Wherever the two input texts
differ, you can choose which one of them to include in the merge buffer.

If a common ancestor version is available, from which the two texts to be
merged were both derived, Emerge can use it to guess which alternative is
right.  Wherever one current version agrees with the ancestor, Emerge presumes
that the other current version is a deliberate change which should be kept in
the merged version.  Use the ‘with-ancestor’ commands if you want to specify a
common ancestor text.  These commands read three file or buffer names—variant
A, variant B, and the common ancestor.

**** Interactive Merging
#+cindex:emerge mode
You control the merging by typing special “merge commands” in the merge buffer.
For each run of differences between the input texts, you can choose which one
of them to keep, or edit them both together.  The merge buffer uses a special
major mode, Emerge mode, with commands for making these choices.  But you can
also edit the buffer with ordinary Emacs commands.

Normally, the merge buffer starts out with the A version of the text.  But when
the A version of a difference agrees with the common ancestor, then the B
version is initially preferred for that difference.

{{{heading(Selected Difference)}}}

At any given time, the attention of Emerge is focused on one particular
difference, called the “selected” difference.  This difference is marked off in
the three buffers like this:

#+BEGIN_EXAMPLE

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

#+END_EXAMPLE

Emerge numbers all the differences sequentially and the mode line always shows
the number of the selected difference.

{{{heading(Exiting Emerge)}}}

Emerge leaves the merged text in the merge buffer when you exit.

- =C-x C-w= :: save the merge buffer in a file.  If you give a
numeric argument to ‘emerge-files’ or ‘emerge-files-with-ancestor’, it reads
the name of the output file using the minibuffer.  Then exiting from Emerge
saves the merged text in the output file.

- =C-]= :: abort Emerge without saving.

**** Submodes in Emerge

There are two modes for giving merge commands: Fast Mode and Edit Mode.  The
mode line indicates Edit and Fast modes with ‘E’ and ‘F’.

There are two additional submodes that affect how particular merge commands
work: Auto Advance Mode, and Skip Prefers Mode.

{{{heading(Fast Mode)}}}

- =C-c C-c f= :: switch to Fast mode (from Edit mode)

In Fast mode, basic merge commands are single characters, but ordinary Emacs
commands are disabled.

{{{heading(Edit Mode)}}}

- =e= :: swith to Edit mode (from Fast mode)

In Edit mode, all merge commands start with the prefix key ‘C-c C-c’, and the
normal Emacs commands are also available.  This allows editing the merge
buffer, but slows down Emerge operations.

{{{heading(Auto Advance Mode)}}}

If Auto Advance mode is in effect, the ‘a’ and ‘b’ commands advance to the next
difference.  This lets you go through the merge faster as long as you simply
choose one of the alternatives from the input.  The mode line indicates Auto
Advance mode with ‘A’.

{{{heading(Skip Prefers Mode)}}}

If Skip Prefers mode is in effect, the ‘n’ and ‘p’ commands skip over
differences in states “prefer-A” and “prefer-B” (*note State of Difference::).
Thus you see only differences for which neither version is presumed correct.
The mode line indicates Skip Prefers mode with ‘S’.  This mode is only relevant
when there is an ancestor.

Use the command ‘s a’ (‘emerge-auto-advance’) to set or clear Auto Advance
mode.  Use ‘s s’ (‘emerge-skip-prefers’) to set or clear Skip Prefers mode.
These commands turn on the mode with a positive argument, turn it off with a
negative or zero argument, and toggle the mode with no argument.

**** State of a Difference
In the merge buffer, a difference is marked with lines of ‘v’ and ‘^’
characters.  Each difference has one of these seven states:

- =A= :: The difference is showing the A version.  The ‘a’ command always
         produces this state; the mode line indicates it with ‘A’.

- =B= :: The difference is showing the B version.  The ‘b’ command always
         produces this state; the mode line indicates it with ‘B’.

- =default-A= or =default-B= :: The difference is showing the A or the B state
     by default, because you haven’t made a choice.  All differences start in
     the default-A state (and thus the merge buffer is a copy of the A buffer),
     except those for which one alternative is preferred (see below).

     When you select a difference, its state changes from default-A or
     default-B to plain A or B.  Thus, the selected difference never has state
     default-A or default-B, and these states are never displayed in the mode
     line.

     The command ‘d a’ chooses default-A as the default state, and ‘d b’
     chooses default-B.  This chosen default applies to all differences that
     you have never selected and for which no alternative is preferred.  If you
     are moving through the merge sequentially, the differences you haven’t
     selected are those following the selected one.  Thus, while moving
     sequentially, you can effectively make the A version the default for some
     sections of the merge buffer and the B version the default for others by
     using ‘d a’ and ‘d b’ between sections.

- =prefer-A= or =prefer-B= :: The difference is showing the A or B state
     because it is “preferred”.  This means that you haven’t made an explicit
     choice, but one alternative seems likely to be right because the other
     alternative agrees with the common ancestor.  Thus, where the A buffer
     agrees with the common ancestor, the B version is preferred, because
     chances are it is the one that was actually changed.

     These two states are displayed in the mode line as ‘A*’ and ‘B*’.

- =combined= :: The difference is showing a combination of the A and B states,
                as a result of the ‘x c’ or ‘x C’ commands. The mode line
                displays this state as ‘comb’.

                Once a difference is in this state, the ‘a’ and ‘b’ commands
                don’t do anything to it unless you give them a numeric
                argument.

** Entering Special Symbols
   #+cindex:Section § symbol
   #+cindex:symbol §
- Section § symbol :: =C-x 8 S=
* Practicals
** Exploring Emacs

** Log Files

** TRAMP

** Dired
#+cindex:dired
You can manipulate directories and files using Emacs’s directory editor, dired.

Ways to access dired:

- From IDO Mode :: =C-x C-f C-d= when finding files to open a dired buffer in
                   that file's current directory.

- As a command :: =M-x dired=

- As a key bind :: =C-x d= =C-x 4 d=


#+cindex:@command{dired-listing-switches}
Dired Buffer is usually based upon ~ls -al~.  This can be configured using
~dired-listing-switches~.

*** Dired Navigation

*** Dired Marking and Unmarking

*** Dired Operations

*** Working Across Directories

**** Include Additional Directories

#+cindex:directories, include subdirectories
#+cindex:subdirectories, include
#+cindex:include subdirectories
- ~dired-maybe-insert-subdir~ ::

  - =i= :: insert this subdirectory into the same dired buffer (like ~ls -lR~)

  #+cindex:switches, @command{ls}
  #+cindex:@command{ls} switches
  - =C-u i= :: edit the ~ls~ switches; add =R= to the switches to expand
                    the whole tree starting at this subdirectory

  - [[info:emacs#Subdir%20switches][Subdir Switches]] :: for more details

- ~dired-hide-subdir~ :: =$= --- hide or unhide the current subdirectory and
     move to next directory

     - =M-$= :: (un)hide all directories

- ~dired-reset-subdir-switches~ :: reset all subdirectory switches to the
     default


**** Find Wrapper Commands
#+cindex:@command{find} wrapper commands
To recursively apply a dired or shell command, use Emac's ~find~ wrapper
commands.

All commands take the output of find and build a dired buffer relative to a
starting directory. Emacs is clever enough to notice the relative paths in what
was the filename portion of the buffer. All commands in dired work as usual.

| Commands               | Description                                                |
|------------------------+------------------------------------------------------------|
| ~find-dired~           | Calls ~find~ with a pattern                                |
| ~find-name-dired~      | Calls ~find~ with =-name= using glob patterns              |
| ~find-grep-dired~      | Calls ~find~ and ~grep~                                    |
| ~find-lisp-find-dired~ | Uses Emacs and regexp to find files (elisp implementation) |
|                        | does not use shell globbing                                |
|------------------------+------------------------------------------------------------|

** Shell Commands
The following shell commands work on generic buffers.

#+caption:Shell command key bindings
#+name:shell-command-bindings
|------------+---------------------------------------|
| Keys       | Description                           |
|------------+---------------------------------------|
| M-!        | Calls shell command and prints output |
| C-u M-!    | As above, but inserts into buffer     |
| M-&        | Like M-! but asynchronous             |
| C-u M-&    | Like C-u M-! but asynchronous         |
| M-pipe     | Pipes region to shell command         |
| C-u M-pipe | Likes M-pipe, but replaces region     |
|------------+---------------------------------------|

- [ =C-u= ] =M-!= and =M-&= :: Invoke any shell command; output is
     printed to the mini-buffer if it is only a small amount, or to a
     dedicated buffer otherwise.  Add a prefix argument to insert the
     output into the buffer.

- [ =C-u= ] =M-|= :: Takes the region as input and sends it to the
     standard input of a shell command, and returns the output to
     either the mini-buffer or a dedicated buffer.  Add a prefix
     argument to replace the region with the shell output.

*** Compiling in Emacs
=M-x compile= asynchronously runs a compilation command (by default
~make -k~).  You can run any command or script, however, and track the
output.  Error messages go to the "*compilation*" buffer.

#+caption:Compilation command key bindings
#+name:compilation-command-bindings
|-----------------------------+------------------------------------------------------|
| Commands                    | Description                                          |
|-----------------------------+------------------------------------------------------|
| =M-x compile=               | Runs a command, and tracks errors                    |
| =M-x recompile=             | Re-runs last command                                 |
| =M-g M-n=, =M-g M-p=        | Jumps to next or previous error                      |
| =C-x `=                     | Visit errors sequentially                            |
| =g= (Compilation mode)      | Re-runs last command                                 |
| =M-x kill-compilation=      | Kill the running compilation subprocess              |
| =compile-command=           | Variable holding prior command                       |
| =compilation-scroll-output= | Variable controlling scrolling of compilation buffer |
| =compilation-environment=   | Variable to control the environment passed           |
|-----------------------------+------------------------------------------------------|

*** Compilation Mode
The "*compilation*" buffer uses a major mode called Compilation mode.
This mode turns each error message in the buffer into a hyperlink; you
can move point to it and type <RET> to visit "locus" of the error
message in a separate window.

- =compilation-auto-jump-to-first-error= :: Variable allowing Emacs to
     automatically jump to the first error message that appears in the
     compilation buffer (when set to non-=nil=).

** Shells

*** Shell Mode

*** Terminal Emulator

*** eshell---Emac's Shell

* Loading
All functions call the ~load~ function:

** Load Functions
#+findex:load
#+attr_texinfo: :options load filename &optional missing-ok nomessage nosuffix must-suffix
#+begin_defun

#+vindex:load-prefer-newer
This function finds and opens a file of Lisp code, evaluates all the forms in
it, and closes the file.  If the option ~load-prefer-newer~ is non-nil, then
when searching suffixes, load selects whichever version of a file (‘.elc’,
‘.el’, etc.) has been modified most recently.

#+vindex:load-path
If filename is a relative file name, ~load~ searches for the file using the
variable ~load-path~.  The current default directory is tried only if it is
specified in ~load-path~, where nil stands for the default directory.

#+vindex:load-file-name
When found, Emacs sets the value of the variable ~load-file-name~ to that
file's name.

- FILENAME ::

  Execute a file of Lisp code named FILENAME.  Append =.elc=, =.el=,
  system-dependent suffix of dynamic modules, unmodified.  See ~load-suffixes~.
  Env vars are replaced with their values by calling ~substitute-in-file-name~.

- MISSING-OK ::

  If non-nil, don’t report error if FILE doesn’t exist.

- NOMESSAGE ::

  Print messages at start and end of loading unless this is non-nil.

- NOSUFFIX ::

  If non-nil, don’t add suffixes.

- MUST-SUFFIX ::

  If non-nil, insist on the suffix =.elc= or =.el= or the module suffix.

- RETURN ::

  Returns ’t’ if the file exists and loads successfully.
#+end_defun

*** Load-File

Use this command if you wish to specify precisely the file name to load.

#+attr_texinfo: :options load-file filename
#+begin_defun
- FILENAME :: Load the file named FILENAME.  If FILENAME is a relative file
  name, then the current default directory is assumed.  This command does not
  use ~load-path~, and does not append suffixes.
#+end_defun

*** Load-Library

This command is equivalent to ~load~, except for the way it reads its argument
interactively.  This is an interface to the function ~load~.

#+attr_texinfo: :options load-library library
#+begin_defun
- LIBRARY :: This command loads the library named LIBRARY (a string).
#+end_defun

** Provide and Require
#+cindex:feature
These work in terms of named /features/.  A /feature/ is loaded the first time
another program asks for it by name.  A /feature name/ is a symbol that stands
for a collection of functions, variables, etc.  The file that defines the
functions, variabes, etc. should /provide/ the feature.  Another program that
uses them may ensure they are defined by /requiring/ the feature.  This loads
the file of definitions if it has not been loaded yet.

To /require/ the presence of a /feature/, call ~require~ with the feature name
as argument.  ~require~ looks in the global variable ~features~ to see whether
the desired feature has been provide already.  If not, it loads the feature
from the appropriate file.  This file should call ~provide~ at the top level to
add the feature to ~features~.

Features are normally named after the files that provide them, so that
~require~ need not be given the file name.

#+attr_texinfo: :options provide feature &optional subfeatures
#+begin_defun
- FEATURE :: a symbol that accounces that FEATURE is a feature of the current
  Emacs, e.g., it is loaded into the current Emacs session, and its facilities
  are or will be available for other Lisp programs.  ~provide~ ensures that
  FEATURE is added to the front of the variable ~features~ if it is not already
  there.  If it has not already been added, the ~provide~ calls any
  ~eval-after-load~ code waiting for it.

- SUBFEATURES ::  a list of symbols listing particular subfeatures supported in
  this version of FEATURE.

- RETURN VALUE :: FEATURE is returned.
#+end_defun

#+attr_texinfo: :options require feature &optional filename noerror
#+begin_defun
- FEATURE :: a symbol representing a set of code and variables to load into the
  current Emacs.  If FEATURE is not a member of the list held by the variable
  ~features~, tested by ~featurep~, then load it from FILENAME.  If FILENAME is
  omitted, the /printname/ of FEATURE is used as the file name, and ~load~ will
  try to laod this name, with an added suffixe (require).  The directories in
  ~load-path~ are searched.

- FILENAME :: if given, then load the feature from the file identified by
  FILENAME.

- NOERROR :: if non-nil, return nil if the file is not found instead of
  signalling an error.

- RETURN VALUE :: the return value is FEATURE.
#+end_defun

#+attr_texinfo: :options featurep feature &optional subfeature
#+begin_defun
- FEATURE :: the symbol to check.  This function returns t if FEATURE has
   already been provided in the current Emacs session.

- RETURN VALUE :: Boolean t if FEATURE has alreayd been provided.
#+end_defun

#+attr_texinfo: :options features
#+begin_defvar
The value of this variable is  list of symbols that are the features loaded in
the current Emacs session, put there by calls to ~provide~.
#+end_defvar
* Packages

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging


#+cindex:package
Emacs provides a standard way to distribute Emacs Lisp code to users.
A package is a collection of one or more files, formatted and bundled
in such a way that users can easily download, install, uninstall, and
upgrade it.

** Installing and Using Packages
- https://www.emacswiki.org/emacs/InstallingPackages

The most common method of installing packages of Emacs Lisp since
Emacs 24 has been *ELPA* packages.  Additional package archives such
as *MELPA* exist to supplement what is in GnuELPA.

#+cindex:UsePackage
#+cindex:use-package
[[https://github.com/jwiegley/use-package][UsePackage]] can make it easier for you to organize your package-related
configuration.

** Emacs Lisp Package Manager and Archives
#+cindex:ELPA
#+cindex:@code{package.el}
#+cindex:Tromey, Tom

- http://tromey.com/elpa/index.html


ELPA is the Emacs Lisp Package Archive, written originally by [[https://www.emacswiki.org/emacs/TomTromey][Tom Tromey]].  It
is included in GnuEmacs, starting with version 24 as ~package.el~.
~package.el~ supports multiple ELPA repositories.

*** GnuElpa

#+cindex:ELPA
#+cindex:GnuElpa
“GNU Emacs Lisp Package Archive---The default package repository for
GNU Emacs.”

- http://elpa.gnu.org

- [[http://elpa.gnu.org/packages/][Browse the Repositories]]

- [[http://git.savannah.gnu.org/cgit/emacs/elpa.git][The Gnu ELPA Repository]]

- [[https://savannah.gnu.org/projects/emacs][Gnu ELPA Project Page]]


This should already be in Emacs (for Emacs 24+):

- ~package-archives~ ::

    : (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")))


You can also add repositories one at a time:

: (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
: (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t) ; Org-mode's repository

To use it, type =M-x list-packages= in Emacs.

Since you'll probably want to use your installed packages, it's also
recommended that you add ~(package-initialize)~ somewhere in your
~$HOME/.emacs~ file.

*** Milkypostman’s Emacs Lisp Package Archive---MELPA

- https://melpa.org/

- https://www.emacswiki.org/emacs/MELPA


#+cindex:MELPA
MELPA is an ELPA-compatible package repository that contains an enormous amount
of useful Emacs packages.

#+texinfo:@heading Features

- Up-to-date packages built on our servers from upstream source

- Installable in any Emacs with 'package.el' - no local version-control tools
  needed

- Curated - no obsolete, renamed, forked or randomly hacked packages

- Comprehensive - more packages than any other archive

- Automatic updates - new commits result in new packages

- Extensible - contribute recipes via github, and we'll build the packages

**** Getting Started with MELPA

***** Installing MELPA

You need ~package.el~.  Emacs 24 on has ~package.el~ bundled.

#+cindex:@code{package-archives}
#+vindex:package-archives
#+cindex:@code{package-initialize}
Enable installation of packages from MELPA by adding an entry to
~package-archives~ after ~(require 'package)~ and before the call to
~package-initialize~ in your ~init.el~ or ~.emacs~ file:

: (add-to-list 'package-archives (cons "melpa" "https://melpa.org/packages/") t)
: (add-to-list 'package-archives (cons "melpa-stable" "https://stable.melpa.org/packages/") t)

*** How Packages Work

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html#Packaging-Basics


Whenever Emacs starts up, it automatically calls the function
‘package-initialize’ to load installed packages.  This is done after
loading the init file and before running ‘after-init-hook’.  Automatic
package loading is disabled if the user option
~package-enable-at-startup~ is nil.

This means you should NOT put package specific initialization into
your ~init.el~ except in a few ways:

- customization variables for a package can be set before a package
  has loaded;

- ~auto-mode-alist~ changes can be made in a way that does not require
  the package to be loaded before they are setup:
  : (add-to-list 'auto-mode-alist '("\\.gradle" . groovy-mode))

- mode specific customization of a package could go in a package hook
  which can be set before the package is loaded, for example:
  : (add-hook 'groovy-mode-hook (lambda () (setq tab-width 4)))

- key bindings can also be done in such a way to not cause init
  failure, even if the package is not loaded:
  : (global-set-key (kbd "C-'")     'shell-switcher-switch-buffer)

- some package specific initialization can be done with
  ~eval-after-load~


It might be easier just to move ~package-initialize~ to another point
during startup so you can ~(require)~ ELPA packages; this takes care
of a lot of the described issues:

#+begin_src emacs-lisp :eval no
  ;; basic initialization, (require) non-ELPA packages, etc.
  (setq package-enable-at-startup nil)
  (package-initialize)
  ;; (require) your ELPA packages, configure them as normal
#+end_src

#+texinfo:@heading Using with-eval-after-load For Package Config

Starting in emacs 24.4, ~with-eval-after-load~ is simpler than
~eval-after-load~:

#+begin_src emacs-lisp :eval no
  (with-eval-after-load 'abcd-mode
         (setq-default abcd-basic-offset 7) ; setting some option
         (add-to-list 'abcd-globals-list "console") ; appending to a list option
         (add-hook 'abcd-mode-hook 'prepare-some-abcd-soup) ; things to do for abcd mode buffers
         (define-key abcd-mode-map (kbd "C-c C-c") 'play-some-abcd-song) ; add some key binding for abcd mode
         )
#+end_src

** UsePackage

- https://jwiegley.github.io/use-package/

- https://github.com/jwiegley/use-package


“The ~use-package~ macro allows you to isolate package configuration
in your ~.emacs~ file in a way that is both performance-oriented and,
well, tidy.  I created it because I have over 80 packages that I use
in Emacs, and things were getting difficult to manage.  Yet with this
utility my total load time is around 2 seconds, with no loss of
functionality!”

~use-package~ is /not/ a package manager!  Although ~use-package~ does
have the useful capability to interface with package managers (see
below), /its primary purpose is for the configuration and loading of
packages/.

~use-package~ is available from Melpa and Melpa-Stable.

To install:
: M-x package-install RET use-package RET

** Slime
“The Superior Lisp Interaction Mode for Emacs”

[[file:resources/images/slime-small.png]]

- [[https://common-lisp.net/project/slime/][Slime Home]]

  “SLIME is a[n] Emacs mode for  Common Lisp development.  Inspired by existing
  systems  such  [as]  Emacs Lisp  and  ILISP,  we  are  working to  create  an
  environment for hacking Common Lisp in.”

- [[https://github.com/slime/slime][Slime on Github]]

  “SLIME extends Emacs with support for interactive programming in Common Lisp.
  The  features  are  centered  around slime-mode,  an  Emacs  minor-mode  that
  complements the  standard lisp-mode.   While lisp-mode supports  editing Lisp
  source files, slime-mode  adds support for interacting with  a running Common
  Lisp process for compilation, debugging, documentation lookup, and so on.”

- [[https://common-lisp.net/project/slime/doc/html/][Slime User Manual Version 2.22]]

  - [[https://common-lisp.net/project/slime/doc/slime.pdf][PDF]]

- [[https://github.com/slime/slime/releases][Slime Latest Release Version 2.24]]

  Slime version 2.24 released on 2019-05-27


#+texinfo: @heading SLIME Internals

#+begin_quote
SLIME is  constructed from two parts:  a user-interface written in  Emacs Lisp,
and  a supporting  server program  written in  Common Lisp.  The two  sides are
connected together with a socket and communicate using an RPC-like protocol.

The Lisp  server is primarily  written in  portable Common Lisp.   The required
implementation-specific functionality is specified  by a well-defined interface
and  implemented separately  for each  Lisp implementation.   This makes  SLIME
readily portable.
#+end_quote


#+texinfo:@heading About SLIME Mode

#+attr_texinfo: :indic b
- Slime Mode ::

  An Emacs minor-mode to enhance lisp-mode with:

  - Code evaluation, compilation, and macroexpansion.

  - Online documentation (describe, apropos, hyperspec).

  - Definition finding (aka Meta-Point aka M-.).

  - Symbol and package name completion.

  - Automatic macro indentation based on &body.

  - Cross-reference interface (WHO-CALLS, etc).

- SLDB ::

  Common Lisp debugger with an Emacs-based user interface.

- REPL :: 

  The Read-Eval-Print Loop ("top-level") is written in Emacs Lisp for tighter
  integration with Emacs.  The REPL also has builtin "shortcut" commands
  similar those of the McCLIM listener.

- Compilation notes :: 

  SLIME is able to take compiler messages and annotate them directly into
  source buffers.

- Inspector :: 

  Interactive object-inspector in an Emacs buffer.

- Compatible Implementations :: 

  - CMU Common Lisp (CMUCL)
  - Steel Bank Common Lisp (SBCL)
  - Clozure CL (a.k.a. OpenMCL)
  - LispWorks
  - Allegro CL
  - CLISP
  - Scieneer CL
  - ECL
  - Corman CL
  - ABCL

* Special Packages
** Polymode
Multiple Major Modes and How to Use SQL and Python in one Buffer

- [[https://www.masteringemacs.org/article/polymode-multiple-major-modes-how-to-use-sql-python-in-one-buffer][About Polymode]]

** Magit
‘A Git Porcelain inside Emacs’

See [[https://www.masteringemacs.org/article/introduction-magit-emacs-mode-git][“An introduction to Magit, an Emacs mode for Git”]]

Magit is an interface to the version control system Git, implemented as an
Emacs package. Magit aspires to be a complete Git porcelain; it is complete
enough to allow even experienced Git users to perform almost all of their daily
version control tasks directly from within Emacs.

- [[https://magit.vc][Magit Home]]
- [[https://magit.vc/manual/magit/index.html#SEC_Contents][Magit User Manual]]


{{{heading(Staging and Unstaging)}}}

Staging and otherwise applying changes is one of the most important features in
a Git porcelain and here Magit outshines anything else, including Git itself.
Git’s own staging interface (git add --patch) is so cumbersome that many users
only use it in exceptional cases.  In Magit staging a hunk or even just part of
a hunk is as trivial as staging all changes made to a file.

{{{subheading(Status Buffer)}}}

The most visible part of Magit’s interface is the status buffer, which displays
information about the current repository. Its content is created by running
several Git commands and making their output actionable.  Among other things,
it displays information about the current branch, lists unpulled and unpushed
changes and contains sections displaying the staged and unstaged changes.  That
might sound noisy, but, since sections are collapsible, it’s not.

{{{subheading(Stage and Unstage)}}}

To stage or unstage a change one places the cursor on the change and then types
=s= or =u=.  The change can be a file or a hunk, or when the region is active
(i.e. when there is a selection) several files or hunks, or even just part of a
hunk.  The change or changes that these commands --- and many others --- would
act on are highlighted.

{{{subheading(Apply Variants)}}}

Magit also implements several other “apply variants” in addition to staging and
unstaging.  One can discard or reverse a change, or apply it to the working
tree.  Git’s own porcelain only supports this for staging and unstaging and you
would have to do something like =git diff ... | ??? | git apply ...= to
discard, revert, or apply a single hunk on the command line.  In fact that’s
exactly what Magit does internally (which is what lead to the term “apply
variants”).

{{{heading(Advanced Features)}}}

Magit fully embraces Git. It exposes many advanced features using a simple but
flexible interface instead of only wrapping the trivial ones like many GUI
clients do. Of course Magit supports logging, cloning, pushing, and other
commands that usually don’t fail in spectacular ways; but it also supports
tasks that often cannot be completed in a single step. Magit fully supports
tasks such as:

- merging
- rebasing
- cherry-picking
- reverting
- blaming


{{{noindent}}}by not only providing a command to initiate these tasks but also
by displaying context sensitive information along the way and providing
commands that are useful for resolving conflicts and resuming the sequence
after doing so.

Magit wraps and in many cases improves upon at least the following Git
porcelain commands:

- add
- am
- bisect
- blame
- branch
- checkout
- cherry
- cherry-pick
- clean
- clone
- commit
- config
- describe
- diff
- fetch
- format-patch
- init
- log
- merge
- merge-tree
- mv
- notes
- pull
- rebase
- reflog
- remote
- request-pull
- reset
- revert
- rm
- show
- stash
- submodule
- tag


Many more Magit porcelain commands are implemented on top of Git plumbing
commands.
*** Status Buffer

{{{heading(Status)}}}

#+cindex:status
#+cindex:magit-status
To display information about the current Git repository, type =M-x magit-status
RET=.  You will be using this command a lot, and should therefore give it a
global key binding.  This is what we recommend:

: (global-set-key (kbd "C-x g") 'magit-status)

{{{subheading(Status Buffer)}}}

#+cindex:status buffer
Most Magit commands are commonly invoked from the status buffer.  It can be
considered the primary interface for interacting with Git using Magit.  Many
other Magit buffers may exist at a given time, but they are often created from
this buffer.

{{{subheading(Safe State)}}}

Return to a safe state:

: git reset --hard PRE-MAGIT-STATE

{{{subheading(Refresh Status Buffer)}}}

#+cindex:refresh status buffer
#+cindex:status buffer, refresh
Go to the status buffer, while at the same time refreshing it, by typing =C-x
g=.  (When the status buffer, or any Magit buffer for that matter, is the
current buffer, then you can also use just =g= to refresh it).

{{{subheading(Move Between Sections)}}}

Move between sections using =p= and =n=.  Note that the bodies of some sections
are hidden.  Type =TAB= to expand or collapse the section at point.  You can
also use =C-tab= to cycle the visibility of the current section and its
children.

{{{subheading(Stage Changes)}}}

#+cindex:stage changes
Move to a file section inside the section named “Unstaged changes”
and type =s= to stage the changes you have made to that file.  That file now
appears under “Staged changes”.

{{{subheading(Stage and Unstage Hunks)}}}

Magit can stage and unstage individual hunks, not just complete files.  Move to
the file you have just staged, expand it using =TAB=, move to one of the hunks
using =n=, and unstage just that by typing =u=.  Note how the staging (=s=) and
unstaging (=u=) commands operate on the change at point. Many other commands
behave the same way.

* Additional Resources
:PROPERTIES:
:appendix: t
:END:
** WikEmacs

#+cindex:WikEmacs
- http://wikemacs.org/wiki/Main_Page

** Mastering Emacs in One Year
- https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org
- http://blog.binchen.org
** How to Learn Emacs---A Hand-drawn One-pager for Beginners
- https://sachachua.com/blog/2013/05/how-to-learn-emacs-a-hand-drawn-one-pager-for-beginners/
- https://sachachua.com/blog/
** Emacs Rocks
- http://emacsrocks.com
** Planet Emacsen
- https://github.com/hober/planet.emacsen.org
- web site is currently /down/
- https://planet.emacslife.com (unofficial version)
** Awesome Emacs
- https://github.com/emacs-tw/awesome-emacs
** Using Emacs Series
- https://cestlaz.github.io/stories/emacs/
** Xah Emacs and Tutorial
- http://ergoemacs.org/index.html
- http://ergoemacs.org/emacs/emacs.html
** Emacs Mini Tutorial
- [[http://tuhdo.github.io/emacs-tutor.html][Emacs Mini Manual (PART 1) - THE BASICS]]
** r/emacs
- https://www.reddit.com/r/emacs
** Emacs StackExchange
- https://emacs.stackexchange.com
** Effective emacs
- https://a-nickels-worth.blogspot.com/2007/11/effective-emacs.html

* Equality
Equality can be tested between objects, or between the contents of objects
(using the data type of the object).
** Equality Between Objects
#+attr_texinfo: :options eq object1 object2
#+begin_defun
Tests for object equality, not content equality.  Two distinct objects that
contain the same content are not ~eq~.

- OBJECT1 :: an object; fixnums (small integers) with the same value are ~eq~.
  Symbols with the same name are ~eq~.

- OBJECT2 :: an object;

- RETURN VALUE :: =t= if OBJECT1 and OBJECT2 are the same object; =nil=
  otherwise.
#+end_defun

* Variables
** Examining Variables

- describe-variable (=C-h v=) :: Display the value and documentation of variable
  VAR

- set-variable :: Change the value of variable VAR to VALUE.  Limited to user
  options (customizable variables)

- setq :: Set the value of any variable

- eval-expression (=M-:=, =C-j=) :: To execute such an expression, type ‘M-:’
  (‘eval-expression’) and enter the expression in the minibuffer (*note Lisp
  Eval::).  Alternatively, go to the ‘*scratch*’ buffer, type in the
  expression, and then type ‘C-j’


The only way to alter the variable in future sessions is to put something in
your initialization file.

** Directory Variables

** Local Variables
#+cindex:local variables
#+cindex:buffer-local variables
#+cindex:per-buffer variables
Almost any variable can be made “local” to a specific Emacs buffer.  This means
that its value in that buffer is independent of its value in other buffers.  A
few variables are always local in every buffer.  Every other Emacs variable has
a “global” value which is in effect in all buffers that have not made the
variable local.  A few variables cannot be local to a buffer because they are
always local to each display instead.

#+findex:make-local-variable
- make-local-variable :: reads the name of a variable and makes it local to the
  current buffer.
  #+findex:make-variable-buffer-local
- make-variable-buffer-local :: marks a variable so it will become local
  automatically whenever it is set.  once a variable has been marked in this
  way, the usual ways of setting the variable automatically do
  ‘make-local-variable’ first.  We call such variables “per-buffer” variables.
  The per-buffer’s global value is the initial value of the variable for each
  new buffer.
  #+findex:kill-local-variable
- kill-local-variable :: makes a specified variable cease to be local to the
  current buffer.  The global value of the variable henceforth is in effect in
  this buffer.
  #+findex:setq-default
- setq-default :: set the global value of a variable, regardless of whether the
  variable has a local value in the current buffer.  This is is the only way to
  set the global value of a variable that has been marked with
  ‘make-variable-buffer-local’.
  #+findex:default-value
- default-value :: This function takes a symbol as argument and returns its
  default value.  The argument is evaluated; usually you must quote it
  explicitly.

*** Local Variables in Files
A file can specify local variable values to use when editing the file with
Emacs.  Visiting the file or setting a major mode checks for local variable
specifications; it automatically makes these variables local to the buffer, and
sets them to the values specified in the file.

There are two ways to specify file local variable values:

1. in the first or second line

   : -*- mode: MODENAME; VAR: VALUE; ... -*-

   You can specify any number of variable/value pairs in this way, each pair
   with a colon and semicolon.  The VALUEs are used literally, and not
   evaluated.

   You can use ‘M-x add-file-local-variable-prop-line’ instead of adding
   entries by hand.  This command prompts for a variable and value, and adds
   them to the first line in the appropriate way.

   ‘M-x delete-file-local-variable-prop-line’ prompts for a variable, and
   deletes its entry from the line.

   The command ‘M-x copy-dir-locals-to-file-locals-prop-line’ copies the
   current directory-local variables to the first line.

   Keywords that have special meanings as file variables (including the local
   variables list) are:

   - mode :: enables the specified major mode
   - coding :: specifies the coding system for character code conversion
   - unibyte :: load or compile a file of Emacs Lisp in unibyte mode if value
     is t
   - eval :: evaluate the specified Lisp expression (the value returned is
     ignored)

2. with a local variables list.

   : Local Variables:
   : <variable>: <value>
   : End:

    Instead of typing in the local variables list directly, you can use the
   command ‘M-x add-file-local-variable’.  The command ‘M-x
   delete-file-local-variable’ deletes a variable from the list.  ‘M-x
   copy-dir-locals-to-file-locals’ copies directory-local variables to the
   list.


#+texinfo:@heading Setting Minor Modes
#+cindex:minor mode, setting
To enable or disable a minor mode in a local variables list, use the ‘eval’
keyword with a Lisp expression that runs the mode command.

#+texinfo:@heading Processing Local Variables

#+vindex:enable-local-variables
The variable ‘enable-local-variables’ allows you to change the way Emacs
processes local variables.  Its default value is ‘t’, which specifies the
behavior described above.  If it is ‘nil’, Emacs simply ignores all file local
variables.  ‘:safe’ means use only the safe values and ignore the rest.  Any
other value says to query you about each file that has local variables, without
trying to determine whether the values are known to be safe.

#+vindex:enable-local-eval
The variable ‘enable-local-eval’ controls whether Emacs processes ‘eval’
variables.  The three possibilities for the variable’s value are ‘t’, ‘nil’,
and anything else, just as for ‘enable-local-variables’.  The default is
‘maybe’, which is neither ‘t’ nor ‘nil’, so normally Emacs does ask for
confirmation about processing ‘eval’ variables.

#+vindex:save-local-eval-forms
As an exception, Emacs never asks for confirmation to evaluate any
‘eval’ form if that form occurs within the variable
‘safe-local-eval-forms’.
* Lisp Data Types
#+cindex:data types
#+cindex:object
#+cindex:primitives
- object :: piece of data in a Lisp program.  Every object belongs to at least
  one /data type/.  Every object belongs to one and only one /primitive type/.
  Lisp objects are “self-typing”, that is, the primitive type of each object is
  implicit in the object itself.  Lisp “knows” what kind of object an object is
  and will not let the programmer treat it as something else.

- data type :: a set of possible objects.  Types can overlap, and objects can
  belong to two or more types.  Thus, one cannot ask for /the/ type of an
  object, but rather whether an object belongs to /a/ type or not.  Type
  declarations do not exist in Emacs Lisp.  A Lisp variable can have any type
  of value, and it remembers whatever value you store in it, type and all.  But
  see [[info:elisp#Variables with Restricted Values][Restricted Values]].

- primitive or built-in data types :: a few fundamental object types are built
  into Emacs.  From these primitives every other type is constructed.

  - integer

  - float

  - cons

  - symbol

  - string

  - vector

  - hash-table

  - subr

  - byte-code function

  - record

  - special types---see [[info:elisp#Editing Types][Editing Types]]

- predicate data-type functions :: Each primitive type has a corresponding Lisp
  function that checks whether an object is a member of that type.

** Printed Representation
#+cindex:printed representation
#+cindex:read syntax
#+cindex:Lisp printer
#+cindex:printer, Lisp
#+findex:prin1
#+cindex:hash notation
#+findex:read
#+cindex:expression
#+cindex:evaluation
#+cindex:input functions
- printed representation ::
  The /printed representation/ of an object is the format of the output
  generated by the Lisp printer, ~prin1~, for that object.  Every data type has
  a unique printed representation.

- read syntax :: The “read syntax” of an object is the format of the input
  accepted by the Lisp reader (the function ~read~) for that object.  In most
  cases, an object’s printed representation is also a read syntax for the
  object, but some types have no read syntax.  See [[info:elisp#Special Read Syntax][Special Read Syntax]].

- hash notation :: Objects without read syntax are printed in “hash notation”,
  =#<type-name object-name>=.  Hash notation cannot be read at all.  The Lisp
  reader will signal an ‘invalid-read-syntax’ error whenever it encounters
  =#<=.

- expression :: In Lisp, an /expression/ is primarily a Lisp object and only
  secondarily the /text/ that is the object’s read syntax.

- evaluation :: When one evaluates a expression interactively, the Lisp
  interpreter first /reads/ the textual representation of it, producing a Lisp
  object, and then /evaluates/ that object.  See [[info:elisp#Evaluation][Evaluation]].  Evaluation and
  reading are separate activities.  Reading returns the Lisp object represented
  by the text that is read; the object may or may not be evaluated later.

  See [[info:elisp#Input
   Functions][Input Functions]] for a description of ~read~, the basic function for reading
  objects.

** Comments
#+cindex:comment
In Lisp, an unescaped semicolon (=;=) starts a comment if it is not within a
string or character constant.  The Lisp reader discards comments; they do not
become part of the Lisp objects which represent the program within the Lisp
system.

*** Comment Conventions
- =;= ::

  Comments that start with a single semicolon, =;=, should all be aligned to
  the same column on the right of the source code.  Such comments usually
  explain how the code on that line does its job.

- =;;= ::

  Comments that start with two semicolons, ==;;==, should be aligned to the
  same level of indentation as the code.  Such comments usually describe the
  purpose of the following lines or the state of the program at that point.

  We also normally use two semicolons for comments outside functions.

  If a function has no documentation string, it should instead have a
  two-semicolon comment right before the function, explaining what the function
  does and how to call it properly.  Explain precisely what each argument means
  and how the function interprets its possible values.  It is much better to
  convert such comments to documentation strings, though.

- =;;;= ::

  Comments that start with three semicolons, =;;;=, should start at the left
  margin.  We use them for comments which should be considered a heading by
  Outline minor mode.  By default, comments starting with at least three
  semicolons (followed by a single space and a non-whitespace character) are
  considered headings, while comments starting with two or fewer are not.
  Historically, triple-semicolon comments have also been used for commenting
  out lines within a function, but this use is discouraged.  When commenting
  out entire functions, use two semicolons.

- =;;;;= ::

  Comments that start with four semicolons, =;;;;=, should be aligned to the
  left margin and are used for headings of major sections of a program.

*** Some Comment Functions
Because comments are such an important part of programming, Emacs provides
special commands for editing and inserting comments.  It can also do spell
checking on comments with Flyspell Prog mode (*note Spelling::).

- ~comment-dwim~ (=M-;=) ::

  Insert or realign comment on current line.  If the region is active, comment
  or uncomment the region instead.  In this case, supplying a positive ARG adds
  that many comment characters, or if negative, removes that many.

  #+attr_texinfo: :options comment-dwim arg
  #+begin_defun
  Call the comment command you want (“Do What I Mean”).

  If the region is active and ‘transient-mark-mode’ is on, call
  [[comment-region][~comment-region~]] (unless it only consists of comments, in which case it calls
  [[uncomment-region][~uncomment-region~]]).

  Else, if the current line is empty, call [[comment-insert-comment-function][~comment-insert-comment-function~]] if
  it is defined, otherwise insert a comment and indent it.  If the line is
  blank, the comment is indented to the same position where <TAB> would indent
  to; if the line is non-blank, the comment is placed after the last
  non-whitespace character on the line, somewhere between [[comment-column][~comment-column~]] and
  [[comment-fill-column][~comment-fill-column~]] if possible.  Point is placed after the comment
  character.

  - ARG (=C-u M-;=) :: Else if a prefix ARG is specified, call [[comment-kill][~comment-kill~]].
    The comment is saved to the kill ring, and you can reinsert it on another
    line by moving the end of that line, doing =C-y=, and then =M-;= to realin
    the comment.

  Else, call [[comment-indent][~comment-indent~]].  If a line already contains the [[comment-start][~comment-start~]]
  string, this command realigns it to the conventional alignment and moves
  point after.  Comments starting in column 0 are not moved.
  #+end_defun


If you are typing a comment and wish to continue it to another line, type =M-j=
or =C-M-j= ([[comment-indent-new-line][~comment-indent-new-line~]]).  This breaks the current line, and
inserts the necessary comment delimiters and indentation to continue the
comment.

- ~comment-line~ (=C-x C-;=) ::
  <<comment-line>>

  Comments or uncomments complete lines.

  #+attr_texinfo: :options comment-line N
  #+begin_defun
  Comment or uncomment current line and leave point after it.  If region is
  active, comment lines in active region instead.  Unlike ‘comment-dwim’, this
  always comments whole lines.

  - N :: With positive prefix, apply to N lines including current one.  With
    negative prefix, apply to -N lines above.  Also, further consecutive
    invocations of this command will inherit the negative argument.
  #+end_defun

- ~comment-region~ (=C-c C-c=) ::
  <<comment-region>>

  Add comment delimiters to all the lines in the region, even if the region is
  inactive.

  Use =C-c C-c= in C-like languages.

  #+attr_texinfo: :options comment-region begin end &optional arg
  #+begin_defun
  Comment or uncomment each line in the region.

  With just =C-u prefix arg=, uncomment each line in region BEG .. END.

  - ARG :: Numeric prefix ARG means use ARG comment characters.  If ARG is
    negative, delete that many comment characters instead.


  The strings used as comment starts are built from [[comment-start][~comment-start~]] and
  ~comment-padding~; the strings used as comment ends are built from
  ~comment-end~ and ~comment-padding~.
  #+end_defun

  For C-like modes, you can configure the exact effect of =M-;= by setting the
  variables [[c-indent-comment-alist][~c-indent-comment-alist~]] and [[c-indent-comments-syntactically-p][~c-indent-comments-syntactically-p~]].

- ~uncomment-region~ ::
  <<uncomment-region>>

  #+attr_texinfo: :options uncomment-region begin end &optional arg
  #+begin_defun
  Uncomment each line in the BEGIN .. END region.

  - ARG :: The numeric prefix ARG can specify a number of chars to remove from
    the comment delimiters.
  #+end_defun

- ~comment-indent-new-line~ (=C-M-j=, =M-j=) ::
  <<comment-indent-new-line>>

  If you are typing a comment and wish to continue it to another line, type
  ‘M-j’ or ‘C-M-j’ (‘comment-indent-new-line’).  This breaks the current line,
  and inserts the necessary comment delimiters and indentation to continue the
  comment.

  Like ‘<RET>’ followed by inserting and aligning a comment.

  This command is intended for styles where you write a comment per line,
  starting a new comment (and terminating it if necessary) on each line.  If
  you want to continue one comment across several lines, use M-x
  newline-and-indent.

  #+attr_texinfo: :options comment-indent-new-line &optional soft
  #+begin_defun
  Break line at point and indent, continuing comment if within one. This
  indents the body of the continued comment under the previous comment line.

  - SOFT :: The inserted newline is marked hard if variable ‘use-hard-newlines’
    is true, unless optional argument SOFT is non-nil.
  #+end_defun

- ~comment-insert-comment-function~ (a variable) ::
  <<comment-insert-comment-function>>

  #+attr_texinfo: :options comment-insert-comment-function
  #+begin_defvar
  Function to insert a comment when a line doesn’t contain one.
  #+end_defvar

- ~comment-kill~ ::
  <<comment-kill>>

  #+attr_texinfo: :options comment-kill arg
  #+begin_defun
  Kill the first comment on this line, if any.

  - ARG :: With prefix ARG, kill comments on that many lines starting with this
    one.
  #+end_defun

- ~comment-indent~ ::
  <<comment-indent>>

  #+attr_texinfo: :options comment-indent &optional continue
  #+begin_defun
  Indent this line’s comment to ‘comment-column’, or insert an empty comment.

  - CONTINUE :: if non-nil, use the ‘comment-continue’ markers if any.
  #+end_defun

- ~comment-set-column~ (=C-x ;=) ::

  #+attr_texinfo: :options comment-set-column arg
  #+begin_defun
  Set the comment column based on point.  With no ARG, set the comment column
  to the current column.

  - ARG :: With just minus as arg, kill any comment on this line.

    With any other ARG, set comment column to indentation of the previous
    comment and then align or create a comment on this line at that column.
  #+end_defun

- ~comment-column~ (a variable) ::
  <<comment-column>>

  #+attr_texinfo: :options comment-column
  #+begin_defvar
  Column to indent right-margin comments to.  Each mode may establish a
  different default value for this variable; you can set the value for a
  particular mode using that mode’s hook.
  #+end_defvar

- ~comment-continue~ (a variable) ::

  #+attr_texinfo: :options comment-continue
  #+begin_defvar
  Continuation string to insert for multiline comments.  This string will be
  added at the beginning of each line except the very first one when commenting
  a region with a commenting style that allows comments to span several lines.
  It should generally have the same length as [[comment-start][~comment-start~]] in order to
  preserve indentation.
  #+end_defvar

- ~comment-start~ (a variable) ::
  <<comment-start>>

  #+attr_texinfo: :options comment-start
  #+begin_defvar
  String to insert to start a new comment, or nil if no comment syntax.
  #+end_defvar

- ~comment-fill-column~ (a variable) ::
  <<comment-fill-column>>

  #+attr_texinfo: :options comment-fill-column
  #+begin_defvar
  Column to use for ‘comment-indent’.  If nil, use ‘fill-column’ instead.
  #+end_defvar

- ~comment-style~ (a variable) ::

  Its value is =indent=.

  #+attr_texinfo: :options comment-style
  #+begin_defvar
  Style to be used for ‘comment-region’.
  #+end_defvar

- ~comment-styles~ (a variable) ::

  #+attr_texinfo: :options comment-styles
  #+begin_defvar
  Comment region style definitions.

  - =plain=
  - =indent-or-triple=
  - =indent=
  - =aligned=
  - =box=
  - =extra-line=
  - =multi-line=
  - =box-multi=
  #+end_defvar

- ~c-indent-comment-alist~ (a variable) ::
  <<c-indent-comment-alist>>

- ~c-indent-comments-syntactically-p~ (a variable) :: 
  <<c-indent-comments-syntactically-p>>

*** Multi-Line Comments

** Sequences in Elisp
:PROPERTIES:
:appendix: t
:END:

#+cindex:sequence type
The /sequence/ type is the union of two other Lisp types: lists and arrays.  In
other words, any list is a sequence, and any array is a sequence.  The common
property that all sequences have is that each is an ordered collection of
elements.

#+texinfo: @heading The List

#+cindex:list
A list is a sequence of elements, but it is not a single primitive object; it
is made of /cons cells/, one cell per element.  Finding the Nth element
requires looking through N cons cells, so elements farther from the beginning
of the list take longer to access.  But it is possible to add elements to the
list, or remove elements.

#+texinfo:@heading The Array

#+cindex:array
An /array/ is a fixed-length object with a slot for each of its elements.  All
the elements are accessible in constant time.  The four types of arrays are:
- strings
- vectors
- char-tables
- bool-vectors

*** Sequence Functions

This section describes functions that accept any kind of sequence.

*** Lists in Elisp
:PROPERTIES:
:appendix: t
:END:

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lists.html#Lists][Lists in the Elisp Manual]]


#+cindex:list
A /list/ represents a sequence of zero or more elements (which may be any Lisp
objects).

Two important differences between lists and vectors is that:
- two or more lists can share part of their structure;
- you can insert or delete elements in a list without copying the whole list.


#+cindex:list
A /list/ represents a sequence of zero or more elements (which may be any Lisp
objects).

**** Cons Cells

A /cons cell/ is a primitive data object that represents an ordered pair.  That
is, it has two slots, and each slot “holds”, or “refers to”, some Lisp object.
One slot is known as the CAR, and the other is known as the CDR.
**** Lists and Cons Cells

#+cindex:cons cell
#+cindex:CAR, CDR
Lists are built up from /cons cells/.  A “list” is a series of cons cells,
linked together so that the CDR slot of each cons cell holds either the next
cons cell or the empty list.  The empty list is actually the symbol ‘nil’.
There is one cons cell for each element of the list.

By convention, the CARs of the cons cells hold the elements of the list, and
the CDRs are used to chain the list (this asymmetry between CAR and CDR is
entirely a matter of convention; at the level of cons cells, the CAR and CDR
slots have similar properties).  Hence, the CDR slot of each cons cell in a
list refers to the following cons cell.

#+texinfo:@heading Proper Lists---CDR is a List

#+cindex:proper list
#+cindex:nil
Also by convention, the CDR of the last cons cell in a list is ‘nil’.  We call
such a ‘nil’-terminated structure a “proper list”.  In Emacs Lisp, the symbol
‘nil’ is both a symbol and a list with no elements.  For convenience, the
symbol ‘nil’ is considered to have ‘nil’ as its CDR (and also as its CAR).

Hence, the CDR of a proper list is always a proper list.  The CDR of a nonempty
proper list is a proper list containing all the elements except the first.

#+texinfo:@heading Dotted Lists

#+cindex:dotted list
If the CDR of a list’s last cons cell is some value other than ‘nil’, we call
the structure a “dotted list”, since its printed representation would use
dotted pair notation

#+texinfo:@heading List Structure

#+cindex:list structure
Because most cons cells are used as part of lists, we refer to any structure
made out of cons cells as a “list structure”.

#+texinfo:@heading Read Syntax and Printed Representation

#+cindex:read syntax, list
#+cindex:printed representation, list
The read syntax and printed representation for lists are identical, and consist
of a left parenthesis, an arbitrary number of elements, and a right
parenthesis.

: (a b c)
: () or nil
: ((a b c) (d e f))

Upon reading, each object inside the parentheses becomes an element of the
list.  That is, a cons cell is made for each element.  The CAR slot of the cons
cell holds the element, and its CDR slot refers to the next cons cell of the
list, which holds the next element in the list.  The CDR slot of the last cons
cell is set to hold ‘nil’.

#+texinfo:@heading Dotted Pair Notation

#+cindex:dotted pair notation
/Dotted pair notation/ is a general syntax for cons cells that represents the
CAR and CDR explicitly.

In this syntax, =(A . B)= stands for a cons cell whose CAR is the object A and
whose CDR is the object B.  In dotted pair notation, the list =(1 2 3)= is
written as (=1 . (2 . (3 . nil)))=.

Dotted pair notation is more general than list syntax because the CDR does not
have to be a list.  However, it is more cumbersome in cases where list syntax
would work.  For ‘nil’-terminated lists, you can use either notation, but list
notation is usually clearer and more convenient.  When printing a list, the
dotted pair notation is only used if the CDR of a cons cell is not a list.

You can combine dotted pair notation with list notation to represent
conveniently a chain of cons cells with a non-‘nil’ final CDR.  You write a dot
after the last element of the list, followed by the CDR of the final cons cell.
For example, =(rose violet . buttercup)= is equivalent to =(rose . (violet
. buttercup))=.  The list =(rose violet)= is equivalent to =(rose . (violet))=.
Similarly, the three-element list =(rose violet buttercup)= is equivalent to
=(rose . (violet . (buttercup)))=.
**** Association Lists

#+cindex:association list
#+cindex:stack
An /association list/ or /alist/ is a specially-constructed list whose elements
are cons cells.  In each element, the CAR is considered a “key”, and the CDR is
considered an “associated value”.  Association lists are often used as stacks,
since it is easy to add or remove associations at the front of the list.

#+begin_src emacs-lisp :eval no
  (setq alist-of-colors
        '((rose . red) (lily . white) (buttercup . yellow)))
#+end_src

Above, ~alist-of-colors~ is an alist of three elements.  In each element, the
first object is the key, and the second is the value.
**** List Predicates
**** List Elements
**** List Variables
**** Modifying Lists
**** Sets
**** Association Lists
**** Property Lists

*** Arrays in Elisp

An /array/ object has slots that hold a number of other Lisp objects, called
the elements of the array.  Any element of an array may be accessed in constant
time.  When you create an array, other than a char-table, you must specify its
length.  You cannot specify the length of a char-table, because that is
determined by the range of character codes.

#+cindex:array types
Emacs defines four types of array, all one-dimensional:

- “strings” (*note String Type::)
- “vectors” (*note Vector Type::)
- “bool-vectors” (*note Bool-Vector Type::)
- “char-tables” (*note Char-Table Type::)


#+cindex:vector
#+cindex:char-table
#+cindex:bool-vector
Vectors and char-tables can hold elements of any type, but strings can only
hold characters, and bool-vectors can only hold ‘t’ and ‘nil’.

#+texinfo:@heading Shared Characteristics

#+cindex:characteristics, array
All four kinds of array share these characteristics:

   - The first element of an array has index zero, the second element has index
     1, and so on.  This is called “zero-origin” indexing.  For example, an
     array of four elements has indices 0, 1, 2, and 3.

   - The length of the array is fixed once you create it; you cannot change the
     length of an existing array.

   - For purposes of evaluation, the array is a constant---i.e., it evaluates
     to itself.

   - The elements of an array may be referenced or changed with the functions
     ‘aref’ and ‘aset’, respectively (*note Array Functions::).


#+texinfo:@heading Text Characters

In principle, if you want an array of text characters, you could use either a
string or a vector.  In practice, we always choose strings for such
applications, for four reasons:

   - They occupy one-fourth the space of a vector of the same elements.

   - Strings are printed in a way that shows the contents more clearly as text.

   - Strings can hold text properties.  *Note Text Properties::.

   - Many of the specialized editing and I/O facilities of Emacs accept only
     strings.  For example, you cannot insert a vector of characters into a
     buffer the way you can insert a string.  *Note Strings and Characters::.


By contrast, for an array of keyboard input characters (such as a key
sequence), a vector may be necessary, because many keyboard input characters
are outside the range that will fit in a string.

**** Functions that Operate on Arrays

* Interacting with the System
:PROPERTIES:
:appendix: t
:END:
** Processes
:PROPERTIES:
:appendix: t
:END:

#+texinfo:@heading Subprocesses

#+cindex:process
#+cindex:subprocess
#+cindex:child process
#+cindex:parent process
#+cindex:synchronous process
#+cindex:asynchronous process
Emacs Lisp programs can invoke other programs in processes of their own.  These
are called “subprocesses” or “child processes” of the Emacs process, which is
their “parent process”.  A subprocess of Emacs may be “synchronous” or
“asynchronous”, depending on how it is created.  When you create a synchronous
subprocess, the Lisp program waits for the subprocess to terminate before
continuing execution.  When you create an asynchronous subprocess, it can run
in parallel with the Lisp program.  This kind of subprocess is represented
within Emacs by a Lisp object which is also called a “process”.  Lisp programs
can use this object to communicate with the subprocess or to control it.

#+attr_texinfo: :options processp object
#+begin_defun
This function returns ‘t’ if OBJECT represents an Emacs process object, ‘nil’
     otherwise.  The process object can represent a subprocess running a
     program or a connection of any supported type.
#+end_defun

#+texinfo:@heading System Processes

#+cindex:system process
In addition to subprocesses of the current Emacs session, you can also access
other processes running on your machine.  These are /system processes/.

*** Creating Subprocesses---In General

#+cindex:new subprocess, create
There are three primitives that create a new subprocess in which to run a
program.

#+cindex:@code{call-process}
#+cindex:@code{call-process-region}
#+cindex:@code{make-process}
#+attr_texinfo: :indic code
- call-process ::

  creates a synchronous process

- call-process-region ::

  creates a synchronous process

- make-process ::

  creates an asynchronous process and returns a process object


The three functions are called in similar fashions; their common arguments are
described here first.

#+texinfo:@heading The Program to Run

In all cases, the functions *specify the program to be run*.

#+texinfo:@subheading exec-path

#+vindex:exec-path
#+vindex:PATH
#+vindex:default-directory
The filename may contain =~=, =.=, and =..=.  If the file name is relative, the
variable ‘exec-path’ contains a list of directories to search.  Emacs
initializes ‘exec-path’ when it starts up, based on the value of the
environment variable ‘PATH’.  ~nil~ in the list refers to ~default-directory~.
The variable ~exec-directory~ can also supply a directory to search.

Your ~exec-path~ has the contents:

#+name:your-exec-path
#+header: :results value :exports results
#+begin_src emacs-lisp
exec-path
#+end_src

#+attr_texinfo: :options exec-directory
#+begin_defun
The value of this variable is a string, the name of a directory that contains
     programs that come with GNU Emacs and are intended for Emacs to invoke.
     The program ‘movemail’ is an example of such a program; Rmail uses it to
     fetch new mail from an inbox.
#+end_defun

Your ~exec-directory~ has the value:

#+name:your-exec-directory
#+header: :results value :exports results
#+begin_src emacs-lisp
exec-directory
#+end_src

Use the function ‘substitute-in-file-name’ to perform environment variable
substitutions (`$HOME').

#+attr_texinfo: :options substitute-in-file-name filename
#+begin_defun
Substitute environment variables referred to in FILENAME.
‘$FOO’ where FOO is an environment variable name means to substitute
the value of that variable.

    (substitute-in-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"
#+end_defun

#+texinfo:@heading Filename Arguments

#+cindex:filename arguments
Each of the subprocess-creating functions has a BUFFER-OR-NAME argument that
specifies where the output from the program will go.  It should be a buffer or
a buffer name; if it is a buffer name, that will create the buffer if it does
not already exist.  It can also be ‘nil’, which says to discard the output,
unless a custom filter function handles it.

For synchronous processes, you can send the output to a file instead of a
buffer.

#+texinfo:@heading Standard Streams

#+cindex:standard streams
#+cindex:standard output, error, input
#+cindex:streams, standard
#+cindex:redirection, standard streams
By default, both standard output and standard error streams go to the same
destination, but all the 3 primitives allow optionally to direct the standard
error stream to a different destination.

#+texinfo:@heading Process Command-Line Arguments

All three of the subprocess-creating functions allow to specify command-line
arguments for the process to run.  The command-line arguments must all be
strings, and they are supplied to the program as separate argument strings.

- For ‘call-process’ and ‘call-process-region’, these come in the form of a
  ‘&rest’ argument, ARGS.

- For ‘make-process’, both the program to run and its command-line arguments
  are specified as a list of strings.


#+texinfo:@heading Inheriting Environment

#+cindex:subprocess environment
The subprocess inherits its environment from Emacs, but you can specify
overrides for it with ‘process-environment’.


#+vindex:default-directory
The subprocess gets its current directory from the value of
‘default-directory’.

**** Specifying Shell Arguments

#+attr_texinfo: :options shell-quote-argument argument
#+begin_defun
This function returns a string that represents, in shell syntax, an argument
     whose actual contents are ARGUMENT.  It should work reliably to
     concatenate the return value into a shell command and then pass it to a
     shell for execution.  The function is designed to work with the syntax of
     your system’s standard shell.

     Here’s an example of using ‘shell-quote-argument’ to construct a
     shell command:

          (concat "diff -u "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))
#+end_defun

#+texinfo:@heading Command-Line Argument Processing

The following two functions are useful for combining a list of individual
command-line argument strings into a single string, and taking a string apart
into a list of individual command-line arguments.

#+attr_texinfo: :options combine-and-quote-strings list-of-strings &optional separator
#+begin_defun
     This function concatenates LIST-OF-STRINGS into a single string, quoting
     each string as necessary.  It also sticks the SEPARATOR string between
     each pair of strings; if SEPARATOR is omitted or ‘nil’, it defaults to ‘"
     "’.  The return value is the resulting string.

     The strings in LIST-OF-STRINGS that need quoting are those that include
     SEPARATOR as their substring.  Quoting a string encloses it in double
     quotes ‘"..."’.  In the simplest case, if you are consing a command from
     the individual command-line arguments, every argument that includes
     embedded blanks will be quoted.
#+end_defun

#+attr_texinfo: :options split-string-and-unquote string &optional separators
#+begin_defun
     This function splits STRING into substrings at matches for the regular
     expression SEPARATORS, like ‘split-string’ does.  In addition, it removes
     quoting from the substrings.  It then makes a list of the substrings and
     returns it.
#+end_defun

*** Creating Synchronous Subprocesses

After a “synchronous process” is created, Emacs waits for the process to
terminate before continuing.  While Emacs waits for the synchronous subprocess
to terminate, the user can quit by typing ‘C-g’.  The first ‘C-g’ tries to kill
the subprocess with a ‘SIGINT’ signal; but it waits until the subprocess
actually terminates before quitting.  If during that time the user types
another ‘C-g’, that kills the subprocess instantly with ‘SIGKILL’ and quits
immediately.  The synchronous subprocess functions return an indication of how
the process terminated.

**** call-process---a primitive

#+attr_texinfo: :options call-process program &optional infile destination display &rest args
#+begin_defun
     This function calls PROGRAM and waits for it to finish.

     The current working directory of the subprocess is set to the current
     buffer’s value of ‘default-directory’ if that is local (as determined by
     ‘unhandled-file-name-directory’), or "~" otherwise.  If you want to run a
     process in a remote directory use ‘process-file’.

     #+attr_texinfo: :indic @var
     - infile :: The standard input for the new process comes from file INFILE
       if INFILE is not ‘nil’, and from the null device otherwise.
     - destination :: The argument DESTINATION says where to put the process
       output.  Here are the possibilities:
       #+attr_texinfo: :indic b
       - a buffer ::

       - a buffer name (a string) ::

       - t :: Insert the output in the current buffer, before point.

       - nill :: Discard the output

       - 0 :: Discard the output, and return ‘nil’ immediately without waiting
         for the subprocess to finish.

       - (:file FILE-NAME) :: Send the output to the file name specified,
         overwriting it if it already exists.

       - (REAL-DESTINATION ERROR-DESTINATION) :: Keep the standard output
         stream separate from the standard error stream; deal with the ordinary
         output as specified by REAL-DESTINATION, and dispose of the error
         output according to ERROR-DESTINATION.  If ERROR-DESTINATION is ‘nil’,
         that means to discard the error output, ‘t’ means mix it with the
         ordinary output, and a string specifies a file name to redirect error
         output into.

         You can’t directly specify a buffer to put the error output in; that
         is too difficult to implement.  But you can achieve this result by
         sending the error output to a temporary file and then inserting the
         file into a buffer when the subprocess finishes.

     - display :: If DISPLAY is non-‘nil’, then ‘call-process’ redisplays the
       buffer as output is inserted.  Otherwise the function ‘call-process’
       does no redisplay, and the results become visible on the screen only
       when Emacs redisplays that buffer in the normal course of events.

     - args :: The remaining arguments, ARGS, are strings that specify command
       line arguments for the program.  Each string is passed to PROGRAM as a
       separate argument.

     - Return Value :: The value returned by ‘call-process’ (unless you told it
       not to wait) indicates the reason for process termination.  A number
       gives the exit status of the subprocess; 0 means success, and any other
       value means failure.  If the process terminated with a signal,
       ‘call-process’ returns a string describing the signal.  If you told
       ‘call-process’ not to wait, it returns ‘nil’.

#+end_defun
**** call-process-region---a primitive

#+attr_texinfo: :options call-process-region start end program &optional delete destination display &rest args
#+begin_defun
     This function sends the text from START to END as standard input to a
     process running PROGRAM.  It deletes the text sent if DELETE is non-‘nil’;
     this is useful when DESTINATION is ‘t’, to insert the output in the
     current buffer in place of the input.

     #+attr_texinfo: :indic var
     - destination, display ::

       The arguments DESTINATION and DISPLAY control what to do with the output
       from the subprocess, and whether to update the display as it comes in.
       For details, see the description of ‘call-process’, above.  If
       DESTINATION is the integer 0, ‘call-process-region’ discards the output
       and returns ‘nil’ immediately, without waiting for the subprocess to
       finish.

     - args ::

       The remaining arguments, ARGS, are strings that specify command line
       arguments for the program.

     - Return Value ::

       The return value of ‘call-process-region’ is just like that of
       ‘call-process’: ‘nil’ if you told it to return without waiting;
       otherwise, a number or string which indicates how the subprocess
       terminated.
#+end_defun

#+texinfo:@heading Example using ~call-process-region~

In the following example, we use ~call-process-region~ to run the ~cat~
utility, with standard input being the first five characters in buffer =foo=
(the word =input=).  ~cat~ copies its standard input into its standard output.
Since the argument DESTINATION is ‘t’, this output is inserted in the current
buffer.

#+begin_example
---------- Buffer: foo ----------
input★
---------- Buffer: foo ----------

(call-process-region 1 6 "cat" nil t)
     ⇒ 0

---------- Buffer: foo ----------
inputinput★
---------- Buffer: foo ----------
#+end_example
**** call-process-shell-command

#+attr_texinfo: :options call-process-shell-command command &optional infile destination display
#+begin_defun
#+attr_texinfo: :indic var
- COMMAND :: This function executes the shell command COMMAND synchronously.


The other arguments are handeled as in [[*call-process---a primitive][~call-process~]].
#+end_defun

**** call-shell-region

#+attr_texinfo: :options call-shell-region start end command &optional delete destination
#+begin_defun
This function sends the text from START to END as standard input to an inferior
shell running COMMAND.  This function is similar than ~call-process-region~,
with process being a shell.

The arguments DELETE, DESTINATION and the return value are like in
~call-process-region~.
#+end_defun

**** shell-command-to-string

#+findex:shell-command-to-string
This function executes COMMAND (a string) as a shell command, then returns the
command’s output as a string.

**** process-lines

#+attr_texinfo: :options process-lines program &rest args
#+begin_defun
This function runs PROGRAM, waits for it to finish, and returns its output as a
list of strings.  Each string in the list holds a single line of text output by
the program; the end-of-line characters are stripped from each line.

The arguments beyond PROGRAM, ARGS, are strings that specify command-line
arguments with which to run the program.

This function works by calling [[*call-process---a primitive][~call-process~]], so program output is decoded in
the same way as for ~call-process~.
#+end_defun

**** process-file

#+attr_texinfo: :options process-file program &optional infile buffer display &rest args
#+begin_defun
      This function processes files synchronously in a separate process.  It is
     similar to ~call-process~, but may invoke a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Magic-File-Names.html#Magic-File-Names][file handler]] based on the
     value of the variable ~default-directory~, which specifies the current
     working directory of the subprocess.

     The arguments are handled in almost the same way as for ~call-process~,
     with the following differences:

     1. Some file handlers may not support all combinations and forms of the
        arguments INFILE, BUFFER, and DISPLAY.  For example, some file handlers
        might behave as if DISPLAY were ‘nil’, regardless of the value actually
        passed.  As another example, some file handlers might not support
        separating standard output and error output by way of the BUFFER
        argument.

     2. If a file handler is invoked, it determines the program to run based on
        the first argument PROGRAM.  For instance, suppose that a handler for
        remote files is invoked.  Then the path that is used for searching for
        the program might be different from ‘exec-path’.

     3. The second argument INFILE may invoke a file handler.  The file handler
        could be different from the handler chosen for the ‘process-file’
        function itself.  (For example, ‘default-directory’ could be on one
        remote host, and INFILE on a different remote host.  Or
        ‘default-directory’ could be non-special, whereas INFILE is on a remote
        host.)

     4. If BUFFER is a list of the form ‘(REAL-DESTINATION ERROR-DESTINATION)’,
        and ERROR-DESTINATION names a file, then the same remarks as for INFILE
        apply.

     5. The remaining arguments (ARGS) will be passed to the process verbatim.
        Emacs is not involved in processing file names that are present in
        ARGS.  To avoid confusion, it may be best to avoid absolute file names
        in ARGS, but rather to specify all file names as relative to
        ‘default-directory’.  The function ‘file-relative-name’ is useful for
        constructing such relative file names.  Alternatively, you can use
        ‘file-local-name’ (*note Magic File Names::) to obtain an absolute file
        name as seen from the remote host’s perspective.
#+end_defun
**** process-file-shell-command

#+findex:process-file-shell-command
This function is like ~call-process-shell-command~, but uses ~process-file~
internally.  Depending on ~default-directory~, COMMAND can be executed also on
remote hosts.

**** process-file-side-effects---a variable

#+attr_texinfo: :options process-file
#+begin_defvar
This variable indicates whether a call of ~process-file~ changes remote files.

By default, this variable is always set to ‘t’, meaning that a call of
~process-file~ could potentially change any file on a remote host.  When set to
‘nil’, a file handler could optimize its behavior with respect to remote file
attribute caching.  You should only ever change this variable with a
let-binding; never with ‘setq’.
#+end_defvar

*** Creating Asynchronous Subprocesses

#+cindex:asynchronous process
#+cindex:process, asynchronous
In this section, we describe how to create an “asynchronous process”.  After an
asynchronous process is created, it runs in parallel with Emacs, and Emacs can
communicate with it using the functions described in the following sections.

#+texinfo:@heading Controlling an Asynchronous Process

#+cindex:pty
#+cindex:pseudo-terminal
#+cindex:pipe
#+vindex:process-connection-type
An asynchronous process is controlled either via a “pty” (pseudo-terminal) or a
“pipe”.  The choice of pty or pipe is made when creating the process, by
default based on the value of the variable ‘process-connection-type’ (see
below).

#+texinfo:@subheading ptys

If available, ptys are usually preferable for processes visible to the user, as
in Shell mode, because they allow for job control (‘C-c’, ‘C-z’, etc.) between
the process and its children, and because interactive programs treat ptys as
terminal devices, whereas pipes don’t support these features.  The total number
of ptys is limited on many systems, and it is good not to waste them
unnecessarily.

#+texinfo:@subheading pipes

However, for subprocesses used by Lisp programs for internal purposes (i.e., no
user interaction with the subprocess is required), where significant amounts of
data need to be exchanged between the subprocess and the Lisp program, it is
often better to use a pipe, because pipes are more efficient.

**** make-process---a primitive

#+attr_texinfo: :options &rest args
#+begin_defun
This function is the basic low-level primitive for starting asynchronous
subprocesses.  It returns a process object representing the subprocess.

Compared to the more high-level ~start-process~, described below, it takes
keyword arguments, is more flexible, and allows to specify process filters and
sentinels in a single call.

- ARGS :: The arguments ARGS are a list of keyword/argument pairs.  Omitting a
  keyword is always equivalent to specifying it with value ‘nil’.  Here are the
  meaningful keywords:

  - :name NAME :: Use the string NAME as the process name; if a process with
    this name already exists, then NAME is modified (by appending ‘<1>’, etc.)
    to be unique.

  - :buffer BUFFER :: Use BUFFER as the process buffer.  If the value is ‘nil’,
    the subprocess is not associated with any buffer.

  - :command COMMAND :: Use COMMAND as the command line of the process.  The value
          should be a list starting with the program’s executable file
          name, followed by strings to give to the program as its
          arguments.  If the first element of the list is ‘nil’, Emacs
          opens a new pseudoterminal (pty) and associates its input and
          output with BUFFER, without actually running any program; the
          rest of the list elements are ignored in that case.

  - :coding CODING :: If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.  The coding system used for encoding the data written
          to the program is also used for encoding the command-line
          arguments (but not the program itself, whose file name is
          encoded as any other file name;

  - :connection-type TYPE :: Initialize the type of device used to communicate with the
          subprocess.  Possible values are ‘pty’ to use a pty, ‘pipe’ to
          use a pipe, or ‘nil’ to use the default derived from the value
          of the ‘process-connection-type’ variable.
          #+cindex:@{:stderr} parameter
          This parameter and the value of ‘process-connection-type’ are ignored
    if a non-‘nil’ value is specified for the ‘:stderr’ parameter; in that
    case, the type will always be ‘pipe’.

  - :noquery QUERY-FLAG :: Initialize the process query flag to QUERY-FLAG.

  - :stop STOPPED :: If STOPPED is non-‘nil’, start the process in the stopped
    state.

  - :filter FILTER :: Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be overridden
          later.

  - :sentinel SENTINEL :: Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          overridden later.
    #+cindex:@code{:stderr} keyword
  - :stderr STDERR :: Associate STDERR with the standard error of the process.  A
          non-‘nil’ value should be either a buffer or a pipe process
          created with ‘make-pipe-process’, described below.


#+findex:process-contact
The original argument list, modified with the actual connection information, is
available via the ~process-contact~ function.

#+vindex:default-directory
The current working directory of the subprocess is set to the current buffer’s
value of ‘default-directory’ if that is local (as determined by
‘unhandled-file-name-directory’), or "~" otherwise.  If you want to run a
process in a remote directory use ~start-file-process~.
#+end_defun

**** make-pipe-process

#+attr_texinfo: :options &rest args
#+begin_defun
This function creates a bidirectional pipe which can be attached to a child
process.  This is useful with the =:stderr= keyword of ~make-process~.  The
function returns a process object.

- ARGS :: The arguments ARGS are a list of keyword/argument pairs.  Omitting
     a keyword is always equivalent to specifying it with value ‘nil’.

     Here are the meaningful keywords:

  - :name NAME :: Use the string NAME as the process name.  As with
       ‘make-process’, it is modified if necessary to make it unique.

  - :buffer BUFFER :: Use BUFFER as the process buffer.

  - :coding CODING :: If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.

          If CODING is ‘nil’, the default rules for finding the coding
          system will apply.

  - :noquery QUERY-FLAG :: Initialize the process query flag to QUERY-FLAG.

  - :stop STOPPED :: If STOPPED is non-‘nil’, start the process in the stopped
          state.  In the stopped state, a pipe process does not accept
          incoming data, but you can send outgoing data.  The stopped
          state is set by ‘stop-process’ and cleared by
          ‘continue-process’

  - :filter FILTER :: Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be changed later.

  - :sentinel SENTINEL :: Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          changed later.


#+findex:process-contact
The original argument list, modified with the actual connection information, is
available via the ‘process-contact’ function.

#+end_defun

**** start-process

#+attr_texinfo: :options start-process name buffer-or-name program &rest args
#+begin_defun
This function is a higher-level wrapper around ‘make-process’, exposing an
interface that is similar to [[*call-process---a primitive][~call-process~]].  It creates a new asynchronous
subprocess and starts the specified PROGRAM running in it.  It returns a
process object that stands for the new subprocess in Lisp.

- NAME :: The argument NAME specifies the name
     for the process object; as with ‘make-process’, it is modified if
     necessary to make it unique.

- BUFFER-OR-NAME :: The buffer BUFFER-OR-NAME is the buffer to associate with
  the process.

- PROGRAM :: If PROGRAM is ‘nil’, Emacs opens a new pseudoterminal (pty) and
     associates its input and output with BUFFER-OR-NAME, without
     creating a subprocess.  In that case, the remaining arguments ARGS
     are ignored.

- ARGS :: The rest of ARGS are strings that specify command line arguments
     for the subprocess.
#+end_defun

**** start-file-process

#+attr_texinfo: :options start-file-process name buffer-or-name program &rest args
#+begin_defun
Like ‘start-process’, this function starts a new asynchronous subprocess
running PROGRAM in it, and returns its process object.

The difference from ‘start-process’ is that this function may invoke a file
handler based on the value of ‘default-directory’.  This handler ought to run
PROGRAM, perhaps on the local host, perhaps on a remote host that corresponds
to ‘default-directory’.  In the latter case, the local part of
‘default-directory’ becomes the working directory of the process.
#+end_defun

**** start-process-shell-command

#+attr_texinfo: :options start-process-shell-command name buffer-or-name command
#+begin_defun
This function is like ~start-process~, except that it uses a shell to execute
the specified COMMAND.

- COMMAND :: The argument COMMAND is a shell command string.


#+vindex:shell-file-name
The variable ~shell-file-name~ specifies which shell to use.

#+cindex:wildcards
#+findex:shell-quote-argument
The point of running a program through the shell, rather than directly with
~make-process~ or ~start-process~, is so that you can employ shell features
such as wildcards in the arguments.  It follows that if you include any
arbitrary user-specified arguments in the command, you should quote them with
[[*Specifying Shell Arguments][~shell-quote-argument~]] first, so that any special shell characters do _not_
have their special shell meanings.
#+end_defun

**** start-file-process-shell-command

#+attr_texinfo: :options start-file-process-shell-command name buffer-or-name command
#+begin_defun
This function is like ~start-process-shell-command~, but uses
~start-file-process~ internally.  Because of this, COMMAND can also be executed
on remote hosts, depending on ~default-directory~.
#+end_defun

**** process-connection-type---a variable

#+attr_texinfo: :options process-connection-type
#+begin_defvar
This variable controls the type of device used to communicate with asynchronous
subprocesses.  If it is non-‘nil’, then ptys are used, when available.
Otherwise, pipes are used.  The value of ‘process-connection-type’ takes effect
when ‘make-process’ or ‘start-process’ is called.  So you can specify how to
communicate with one subprocess by binding the variable around the call to
these functions.

#+cindex:@code{:stderr} parameter
Note that the value of this variable is ignored when ‘make-process’ is called
with a non-‘nil’ value of the ‘:stderr’ parameter; in that case, Emacs will
communicate with the process using pipes.  It is also ignored if ptys are
unavailable (MS-Windows).

#+findex:process-tty-name
To determine whether a given subprocess actually got a pipe or a pty, use the
function ~process-tty-name~.
#+end_defvar

* Debugging
:PROPERTIES:
:appendix: t
:END:

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Debugging.html#Debugging

- https://www.emacswiki.org/emacs/CategoryDebug

** Find Func

https://www.emacswiki.org/emacs/FindFunc

- find-func (=C-x F=) ::

     ~(find-function FUNCTION)~

     Finds the source file containing the definition of the function near point
     (selected by ‘function-called-at-point’) in a buffer and places point
     before the definition.  Set mark before moving, if the buffer already
     existed.

** Debugger Mode

- https://www.emacswiki.org/emacs/DebuggerMode


#+cindex:debugger mode
#+cindex:BacktraceBuffer
#+cindex:execution stack
/Debugger mode/ is the mode used in the BacktraceBuffer (buffer ‘*Backtrace*’).
It shows the “frames” of your execution stack.  A line starts with ‘*’ if
exiting that frame will call the debugger.

#+texinfo:@heading Debugger Keys

=C-h m= gives you information on the current mode.

#+attr_texinfo: :indic code
- b :: break point – place an asterisk (=*=) on a stack frame
- u :: remove break point
- c :: continue
- d :: single step
- j :: keep existing frames until you reach the current frame
- e :: eval another sexp that you input
- q :: quit


#+texinfo:@heading Entering debugger mode

- You can use ~M-x debug-on-entry~ to put breakpoints at the start of
  functions, and ~M-x cancel-debug-on-entry~ to remove them.

- You can put ~(debug)~ in EmacsLisp code at arbitrary points (and then eval
  that code) to put breakpoints at those places.

- You can set any of the following variables:
    #+attr_texinfo: :indic b
  - debug-on-quit ::

                     Debugger is entered when the user hits =C-g=.  This is
                     useful in debugging infinite loops and long delays.  You
                     can toggle this variable using ~M-x toggle-debug-on-quit~.

  - debug-on-error ::

                      Debugger is entered when an uncaught error happens.  This
                      is foiled by condition-case forms that catch errors.  You
                      can toggle this variable using =M-x
                      toggle-debug-on-error=.  Note that some errors are
                      ignored --- you may have to temporarily set
                      ~debug-ignored-errors~ to ‘nil’ in order to debug such
                      errors.

  - stack-trace-on-error ::

       An alternative to ~debug-on-error~.  It shows trace buffers instead of
       entering the debugger.  Example: ~(setq stack-trace-on-error
       '(buffer-read-only))~

** Edebug

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html]]

- https://www.emacswiki.org/emacs/SourceLevelDebugger


#+cindex:instrument
#+cindex:@command{edebug-defun} @code{C-u C-M-x}
#+findex:edebug-defun C-u C-M-x
#+findex:edebug-eval-top-level-form
#+findex:edebug-defun
#+vindex:edebug-all-defs
#+vindex:edebug-all-forms
~Edebug~ is a source level debugger for EmacsLisp.  It instruments code.  This
means that Emacs adds special instructions to the code when it is evaluated, to
invoke Edebug at the proper places.

- edebug-defun (=C-u C-M-x=) ::

     is the main entry point to Edebug.  Use it instead of =C-x C-e= or =C-M-x=
     to evaluate a =defun= and instrument it for debugging.  When you invoke
     command =C-u C-M-x= (~eval-defun~ with a prefix argument) on a function
     definition, it instruments the definition before evaluating it.


See the variables:
#+vindex:edebug-all-defs
#+vindex:edebug-all-forms
- ~edebug-all-defs~ and
- ~edebug-all-forms~


#+texinfo:@noindent to control how ~eval-defun~ operates.

See also the commands:
#+findex:eval-region
#+findex:eval-current-buffer
#+findex:eval-buffer:
- ~eval-region~
- ~eval-current-buffer~
- ~eval-buffer~
- ~edebug-eval-top-level-form~
- ~edebug-defun~ (an alias of ~edebug-eval-top-level-form~


~edebug-defun~ must be able to read your code.  It expects all function
definitions to start in column 0.  If they do not, hitting =C-u C-M-x= will
show you the wrong function name in the echo area.

#+texinfo:@heading Instrumented Source Code

#+cindex:execution mode, default
#+cindex:source code buffer
Once a function is instrumented, any call to the function activates Edebug.
The action that occurs depends on which /execution mode/ is active.  The
default execution mode is =step=, which stops execution.  You will be viewing a
read-only buffer of the source code that is being debugged (the /source code
buffer/).  An arrow in the left fringe indicates the line where the function is
executing.  The special commands of Edebug are available in the source code
buffer in addition to the commands of Emacs Lisp mode.

#+texinfo:@heading Stop Points

#+cindex:stop points
The places within a function where Edebug can stop execution are called “stop
points”.  These occur both before and after each subexpression that is a list,
and also after each variable reference.  When Edebug stops execution after an
expression, it displays the expression’s value in the echo area.

#+texinfo:@heading Commanly Used Edebug Commands

- SPC :: execute until the next stop point

- b :: set a breakpoint at a stop point

- g :: execute until a breakpoint is reached

- q :: exit Edebug

- ? :: display a l ist of all Edebug commands


#+texinfo:@heading Interrupt Edebug Execution

While executing or tracing, you can interrupt the execution by typing any
Edebug command.  Edebug stops the program at the next stop point and then
executes the command you typed.  For example, typing ‘t’ during execution
switches to trace mode at the next stop point.  You can use ‘S’ to stop
execution without doing anything else.

*** Features of Edebug
- Step through evaluation, stopping before and after each expression.

- Set conditional or unconditional breakpoints.

- Stop when a specified condition is true (the global break event).

- Trace slow or fast, stopping briefly at each stop point, or at each
  breakpoint.

- Display expression results and evaluate expressions as if outside of Edebug.

- Automatically re-evaluate a list of expressions and display their results
  each time Edebug updates the display.

- Output trace information on function calls and returns.

- Stop when an error occurs.

- Display a backtrace, omitting Edebug's own frames.

- Specify argument evaluation for macros and defining forms.

- Obtain rudimentary coverage testing and frequency counts.

*** Example of Edebug

Paste the following functions into the =*scratch*= buffer (starting at column
0).  Hit =C-M-x= with the cursor inside each of the function definitions.

#+name:foo-and-bar
#+begin_src elisp
  (defun foo ()
        (interactive)
        (bar))

  (defun bar ()
    (let ((a 5)
          (b 7))
      (message "%d" (+ a b))))
#+end_src

Use =M-x foo=.  This prints `12' in the echo area.

Now instrument ‘bar’ by moving the cursor into its code and hitting =C-u
C-M-x=.  The echo area shows =Edebug: bar=.

Use =M-x foo= again.  Emacs steps through the code of ‘bar’, showing you the
result of evaluating each sexp in the echo area.  Hit ‘SPC’ to step ahead or
‘e’ to evaluate another expression.  The arrow shows you which sexp will be
evaluated next:

#+begin_src elisp
  (defun bar ()
  =>(let ((a 5)
          (b 7))
      (message "%d" (+ a b))))
#+end_src

To quit the debugger, type ‘q’.

Edebug can enter any defun whose source can be found with [[*Find Func][FindFunc]] by hitting
‘i’ which steps into the next function to be evaluated.  This instruments the
function and will be debugged every time it is run.

You can disable edebug on a function by evaluating the function again using
=C-M-x= without a PrefixArgument.

You can see the code coverage of the defun at point with ~C-x X =~ or =M-x
edebug-display-freq-count=.

*** Instrumenting for Edebug

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Instrumenting.html#Instrumenting


#+findex:edebug-instrument-callee
#+findex:edebug-step-in
#+attr_texinfo: :indic command
- I (edebug-instrument-callee) ::

     instruments the definition of the function or macro called by the list form
     after point.

- i (edebug-step-in) ::

     steps into the call after instrumenting the function


#+texinfo:@heading User-Defined Macros

#+cindex:user-defined macro, instrument
Edebug knows how to instrument all the standard special forms, ‘interactive’
forms with an expression argument, anonymous lambda expressions, and other
defining forms.  However, Edebug cannot determine on its own what a
user-defined macro will do with the arguments of a macro call, so you must
provide that information using Edebug specifications.  [[info:elisp#Edebug%20and%20Macros][Edebug and Macros]].

#+texinfo:@heading Syntax Errors

#+cindex:invalid-read-syntax error
If Edebug detects a syntax error while instrumenting, it leaves point at the
erroneous code and signals an =invalid-read-syntax= error.  One potential
reason for such a failure to instrument is that some macro definitions are not
yet known to Emacs.  To work around this, load the file which defines the
function you are about to instrument.

#+texinfo:@heading Remove Instrumentation

#+cindex:instrumenation, remove
To remove instrumentation from a definition, simply re-evaluate its definition
in a way that does not instrument.  There are two ways of evaluating forms that
never instrument them: from a file with ~load~, and from the minibuffer with
~eval-expression~ (=M-:=).

*** Edebug Execution Modes

#+cindex:execution modes
Edebug supports several execution modes for running the program you are
debugging, called /execution modes/.  The current Edebug execution mode
determines how far Edebug continues execution before stopping and how much
Edebug displays the progress of the evaluation before it stops.  Normally, you
specify the Edebug execution mode by typing a command to continue the program
in a certain mode.  All except for =S= resume execution of the program.  In
general, the execution modes earlier in the above list run the program more
slowly or stop sooner than the modes later in the list.

| Command | Mode           | Function                  | Effect                                                                   |
|---------+----------------+---------------------------+--------------------------------------------------------------------------|
| S       | Stop           | edebug-stop               | don’t execute any more of the program, but wait for more Edebug commands |
| SPC     | Step           | edebug-step-mode          | stop at the next stop point encountered                                  |
| n       | Next           | edebug-next-mode          | stop at the next stop point encountered after an expression              |
| t       | Trace          | edebug-trace-mode         | pause (normally one second) at each Edebug stop point                    |
| T       | Rapid Trace    | edebug-Trace-fast-mode    | update the display at each stop point, but don’t actually pause          |
| g       | Go             | edebug-go-mode            | See Breakpoints                                                          |
| c       | Continue       | edebug-continue-mode      | pause one second at each breakpoint, and then continue                   |
| C       | Rapid Continue | edebug-Continue-fast-mode | move point to each breakpoint, but don’t pause                           |
| G       | Go non-stop    | edebug-Go-nonstop-mode    | ignore breakpoints. Stop program with =S=, or editing command            |
|---------+----------------+---------------------------+--------------------------------------------------------------------------|

**** Set Initial Execution Mode

#+cindex:execution mode, initial
#+vindex:edebug-initial-mode
#+findex:edebug-set-initial-mode C-x C-a C-m
- ~edebug-initial-mode~ ::

     Default execution mode is =step=

     When you enter a new Edebug level, Edebug will normally stop at the first
     instrumented function it encounters (=Step=).

- edebug-set-initial-mode (=C-x C-a C-m=) ::

     If you prefer to stop only at a break point, or not at all (for example,
     when gathering coverage data), change the value of ‘edebug-initial-mode’
     from its default ‘step’ to ‘go’, or ‘Go-nonstop’, or one of its other
     values (*note Edebug Options).

**** Waiting Between Execution Steps

#+attr_texinfo: :indic code
- edebug-sit-for-seconds ::

     This option specifies how many seconds to wait between execution steps in
     trace mode or continue mode.  The default is 1 second.

*** Edebug Jumping

#+cindex:jump
The commands described in this section execute until they reach a specified
location.  All except ‘i’ make a temporary breakpoint to establish the place to
stop, then switch to go mode.  Any other breakpoint reached before the intended
stop point will also stop execution.

| Command | Function            | Description                                                    |
|---------+---------------------+----------------------------------------------------------------|
| h       | edebug-goto-here    | Proceed to the stop point near where point is                  |
| [N] f   | edebug-forward-sexp | Run the program for one [N] expression(s)                      |
| o       | edebug-step-out     | Run the program until the end of the containing sexp           |
| i       | edebug-step-in      | Step into the function or macro called by the form after point |
|---------+---------------------+----------------------------------------------------------------|

*** Miscellaneous Edebug Commands

| Command | Function                 | Description                                                          |
|---------+--------------------------+----------------------------------------------------------------------|
| C-]     | abort-recursive-edit     | Abort one level back to the previous command level                   |
| Q       | edebug-top-level-nonstop | Like ‘q’, but don’t stop even for protected code                     |
| r       | edebug-previous-result   | Redisplay the most recently known expression result in the echo area |
| d       | edebug-backtrace         | Display a backtrace, excluding Edebug’s own functions for clarity    |
|---------+--------------------------+----------------------------------------------------------------------|

*** Edebug Breaks
There are three other ways (other than stop points) to stop Edebug execution
once it has started:
#+cindex:breaks
- breakpoints,
- the global break condition, and
- source breakpoints.

**** Breakpoints
While using Edebug, you can specify “breakpoints” in the program you are
testing: these are places where execution should stop.  You can set a
breakpoint at any stop point, as defined in *note Using Edebug.  Re-evaluating
or reinstrumenting a definition removes all of its previous breakpoints.
Edebug always stops or pauses at a breakpoint, except when the Edebug mode is
Go-nonstop.  In that mode, it ignores breakpoints entirely.

To find out where your breakpoints are, use the ‘B’ command, which moves point
to the next breakpoint following point, within the same function, or to the
first breakpoint if there are no following breakpoints.  This command does not
continue execution---it just moves point in the buffer.

| Command | Function                          | Description                                                                                                  |
|---------+-----------------------------------+--------------------------------------------------------------------------------------------------------------|
| b       | edebug-set-breakpoint             | Set a breakpoint at the stop point at or after point                                                         |
| u       | edebug-unset-breakpoint           | Unset the breakpoint (if any) at the stop point at or after point                                            |
| x COND  | edebug-set-conditional-breakpoint | Set a conditional breakpoint which stops the program only if evaluating COND produces a non-‘nil’ value      |
| B       | edebug-next-breakpoint            | Move point to the next breakpoint in the current definition                                                  |
|---------+-----------------------------------+--------------------------------------------------------------------------------------------------------------|

#+texinfo:@heading Conditional Breakpoints

#+cindex:conditional breakpoint
#+cindex:breakpoint, conditional
A “conditional breakpoint” tests a condition each time the program gets there.
Any errors that occur as a result of evaluating the condition are ignored, as
if the result were ‘nil’.

To set a conditional breakpoint, use ‘x’, and specify the condition expression
in the minibuffer.  Setting a conditional breakpoint at a stop point that has a
previously established conditional breakpoint puts the previous condition
expression in the minibuffer so you can edit it.

#+texinfo:@subheading Making a Breakpoint Temporary

#+cindex:temporary breakpoint
You can make a conditional or unconditional breakpoint “temporary” by using a
prefix argument with the command to set the breakpoint.  When a temporary
breakpoint stops the program, it is automatically unset.

**** Global Break Condition

#+cindex:global break condition
#+cindex:break condition, global
A “global break condition” stops execution when a specified condition is
satisfied, no matter where that may occur.  Edebug evaluates the global break
condition at every stop point; if it evaluates to a non-‘nil’ value, then
execution stops or pauses depending on the execution mode, as if a breakpoint
had been hit.  If evaluating the condition gets an error, execution does not
stop.

The global break condition is the simplest way to find where in your code some
event occurs, but it makes code run much more slowly.  So you should reset the
condition to ‘nil’ when not using it.

#+attr_texinfo: :indic code
- edebug-global-break-condition ::

     The variable in which the condition expression is stored.

- edebug-set-global-break-condition ::

     You can specify a new expression using the ‘X’ command from the source
     code buffer while Edebug is active, or using ‘C-x X X’ from any buffer at
     any time, as long as Edebug is loaded

**** Source Breakpoints

#+cindex:source breakpoint
#+cindex:breakpoint, source
All breakpoints in a definition are forgotten each time you reinstrument it.
If you wish to make a breakpoint that won’t be forgotten, you can write a
“source breakpoint”, which is simply a call to the function ‘edebug’ in your
source code.  You can, of course, make such a call conditional.  If no
instrumented code is being executed when ‘edebug’ is called, that function
calls ‘debug’.

*** Edebug Views

#+cindex:outside window configuration
The outside window configuration is the collection of windows and contents that
were in effect outside of Edebug.

| Command | Function                  | Description                                                                       |
|---------+---------------------------+-----------------------------------------------------------------------------------|
| v       | edebug-view-outside       | Switch to viewing the outside window configuration                                |
| C-x X w |                           | return to Edebug                                                                  |
| p       | edebug-bounce-point       | Temporarily display the outside current buffer with point at its outside position |
| w       | edebug-where              | Move point back to the current stop point in the source code buffer               |
| W       | edebug-toggle-sae-windows | Toggle whether Edebug saves and restores the outside window configuration         |
| C-u W   |                           | Toggle saving and restoring of the selected window only                           |
|---------+---------------------------+-----------------------------------------------------------------------------------|

*** Edebug Evaluation

While within Edebug, you can evaluate expressions as if Edebug were not
running.

| Command | Function               | Description                                                            |
|---------+------------------------+------------------------------------------------------------------------|
| e EXP   | edebug-eval-expression | Evaluate expression EXP in the context outside of Edebug               |
| M-: EXP | eval-expression        | Evaluate expression EXP in the context of Edebug itself                |
| C-x C-e | edebut-eval-last-sexp  | Evaluate the expression before point, in the context outside of Edebug |
|---------+------------------------+------------------------------------------------------------------------|

*** Edebug Evaluation List Buffer

#+cindex:evaluation list buffer
#+cindex:@code{*edebug*} buffer
You can use the “evaluation list buffer”, called ‘*edebug*’, to evaluate
expressions interactively.  You can also set up the “evaluation list” of
expressions to be evaluated automatically each time Edebug updates the display.

You can evaluate expressions in the evaluation list window with ‘C-j’ or ‘C-x
C-e’, just as you would in ‘*scratch*’; but they are evaluated in the context
outside of Edebug.

The expressions you enter interactively (and their results) are lost when you
continue execution; but you can set up an “evaluation list” consisting of
expressions to be evaluated each time execution stops.

In the ‘*edebug*’ buffer you can use the commands of Lisp Interaction mode
(*note Lisp Interaction) as well as these special commands:

| Command | Function                    | Description                                                                                      |
|---------+-----------------------------+--------------------------------------------------------------------------------------------------|
| E       | edebug-visit-eval-list      | Switch to the evaluation list buffer ‘*edebug*’                                                  |
| C-j     | edebug-eval-print-last-sexp | Evaluate the expression before point, in the outside context, and insert the value in the buffer |
| C-x C-e | edebug-eval-last-sexp       | Evaluate the expression before point, in the context outside of Edebug                           |
| C-c C-u | edebug-update-eval-list     | Build a new evaluation list from the contents of the buffer                                      |
| C-c C-d | edebug-delete-eval-item     | Delete the evaluation list group that point is in                                                |
| C-c C-w | edebug-where                | Switch back to the source code buffer at the current stop point                                  |
|---------+-----------------------------+--------------------------------------------------------------------------------------------------|

*** Insert a Direct Call to Edebug

#+begin_src elisp
  (defmacro stop-here (fn)
         "Call edebug here. FN is assumed to be a symbol of the function you are in."
         `(if (consp (get ,fn 'edebug))
             (edebug)))

  (defun clear-edebug (fn-sym)
    "Remove 'edebug property from FN-SYM, a function symbol."
    (put fn-sym 'edebug nil))
#+end_src

#+begin_src elisp
   ;; An example of use:
  (defun fact (n)
    (cond ((= n 0) )
          ((= n 1) 1)
          ((>  n 1) (progn (stop-here 'fact) (* n (fact (1- n)))))
          (t nil)))
#+end_src

If you eval the above and then ~edebug-defun~ while the point is on =fact=,
you’ll first stop at =fact= but then when you enter ‘g’ for ‘go’ it will next
stop after the ~(* n… )~ which is what I want.

And note you could also put a condition around `stop-here` for example:

: ((>  n 1) (progn (if (= n 3) (stop-here 'fact)) (* n (fact (1- n)))))

*** Trace Buffer

https://www.gnu.org/software/emacs/manual/html_node/elisp/Trace-Buffer.html#Trace-Buffer

#+cindex:trace buffer
#+cindex:execution trace
#+cindex:trace recording
#+cindex:@code{*edebug-trace*}
Edebug can record an execution trace, storing it in a buffer named
=*edebug-trace*=.  This is a log of function calls and returns, showing the
function names and their arguments and values.

#+vindex:edebug-trace
- ~edebug-trace~ :: To enable trace recording, set ~edebug-trace~ to a non-nil
                    value.


Making a trace buffer is not the same thing as using =trace execution mode=
(see Edebug Execution Modes).

#+texinfo:@heading Trace Recording

When trace recording is enabled, each function entry and exit adds lines to the
trace buffer.  A function entry record consists of =::::{=, followed by the
function name and argument values.  A function exit record consists of =::::}=,
followed by the function name and result of the function.  The number of =:='s
in an entry shows its recursion depth.

** Debug Messages
:PROPERTIES:
:header-args: :eval no
:END:

- https://www.emacswiki.org/emacs/DebugMessages


Sometimes you want to find out where a particular error, warning or just plain
annoying message in Messages is coming from.

This piece of advice allows you to see the function call sequence that resulted
in each message in the Messages buffer:

#+begin_src elisp
  (defadvice message (before who-said-that activate)
      "Find out who said that thing. and say so."
      (let ((trace nil) (n 1) (frame nil))
        (while (setq frame (backtrace-frame n))
          (setq n     (1+ n)
                trace (cons (cadr frame) trace)) )
        (ad-set-arg 0 (concat "<<%S>>:\n" (ad-get-arg 0)))
        (ad-set-args 1 (cons trace (ad-get-args 1))) ))
#+end_src

To deactivate this, call

#+begin_src elisp
  (ad-disable-advice 'message 'before 'who-said-that)
     (ad-update 'message)
#+end_src

To get timestamps:

#+begin_src elisp
  (defadvice message (before when-was-that activate)
      "Add timestamps to `message' output."
      (ad-set-arg 0 (concat (format-time-string "[%Y-%m-%d %T %Z] ")
                            (ad-get-arg 0)) ))
#+end_src

And to deactivate this, call:

#+begin_src elisp
  (ad-disable-advice 'message 'before 'when-was-that)
      (ad-update 'message)
#+end_src

** Elisp Tracing

- https://www.emacswiki.org/emacs/EmacsLispTracing


#+texinfo:@heading Commands
#+cindex:trace
#+cindex:tracing

#+attr_texinfo: :indic b
- M-x trace-function

- M-x trace-function-background

- M-x untrace-function

- M-x untrace-all

** Elisp Benchmarking

- https://www.emacswiki.org/emacs/EmacsLispBenchmark


#+cindex:benchmark
#+cindex:benchmarking
Emacs comes with ~GIT:emacs-lisp/benchmark.el~ by DaveLove that can display the
elapsed time of running an EmacsLisp expression.  It observes the timing from
running a form once or repeatedly.  Any time spent by Emacs on
=GarbageCollection= is also determined.  These features are available
interactively with ~M-x benchmark~ or programmatically with ~benchmark-run~.

** Elisp Profiler

- https://www.emacswiki.org/emacs/EmacsLispProfiler


#+cindex:profiler
#+cindex:@code{elp.el}
Emacs comes with ~GIT:emacs-lisp/elp.el~ by Barry Warsaw that can display the
elapsed time of running an EmacsLisp function.  It is possible to instrument
more than one function, so it displays the results as a table in a buffer
called =*Elp Profiling Results*=.  It tracks the total timing for each call of
an instrumented function and determines the average time for each call.

** Emacs Native Profiler

https://www.emacswiki.org/emacs/EmacsNativeProfiler
#+cindex:native profiler
#+cindex:profiler library

The =profiler= library provides CPU & memory profiling for all Emacs functions.

Unlike =EmacsLispProfiler= you do not have to specify which functions or
packages you wish to profile (however ELP remains complementary as it records
overall time taken, which includes time spent waiting for external processes to
return, which is something that the native profiler will not report on).

** Elisp Logging

- https://www.emacswiki.org/emacs/Log4E_Logging_For_Elisp

- https://github.com/aki2o/log4e


~log4e.el~ provides a logging framework for Elisp.
* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Table Listings
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo: @listoffloats Table

* Concept Index
:PROPERTIES:
:INDEX:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:    vr
:unnumbered: t
:END:

* Program Index
:PROPERTIES:
:unnumbered: t
:index:    pg
:END:

* Footnotes

[fn:1]For example, Mac OS is case-insensitive by default, but can be configured
to be case-sensitive.

* Build Tools
:PROPERTIES:
:appendix: t
:custom_id: build-tools
:from-file: Template
:END:
** Makefile					:dependencies:env_vars:perl:
:PROPERTIES:
:appendix: t
:dependency1: make
:dependency2.0: AWS User account at https://aws.amazon.com
:dependency2.1: AWS cli v2 in PATH https://docs.aws.amazon.com/cli/index.html
:dependency2.2: See how to Install AWS CLI v2 at https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html
:dependency2.3: aws credentials: access token and secret access token stored in ~/.aws/credentials
:dependency2.4: AWS S3 buckets set up for serving a static web page
:dependency3: GitHub Account with personal access token stored in GITHUB_TOKEN
:dependency4: texinfo @6.7._
:dependency5: Emacs, Org-mode, Babel language 'shell' enabled
:env_var1: SYNC_ORG_TEMPLATE: holds the full path to this Template.org file
:env_var2: GITHUB_TOKEN: holds the GitHub personal access token
:env_var3: EDITOR: must hold a reference to a working emacsclient server
:env_var4: COLORS
:END:

#+name:Makefile
#+header: :tangle Makefile
#+begin_src makefile

###############################################################################
### USER-DEPENDENT VARIABLES
### USE ENVIRONMENT VARIABLES WHENEVER POSSIBLE

# NOTE: All environment variables need to be exported PRIOR to starting the
# Emacs server as EDITOR in your shell startup files; otherwise, they will not
# be available to Emacs.
# When I moved from using Bash to Zsh, I inadvertently changed the order of
# import, and started the Emacs server before importing, and caused a horrible
# bug which caused the program to work on one computer but fail on another.

# The absolute path to this Template file
TEMPLATE := $(SYNC_ORG_TEMPLATE)

# Use emacsclient as $EDITOR; make sure it is set in a shell startup file and
# the server has been started.
EDITOR	  := $(EDITOR)

# User’s personal GitHub token for authentication to GitHub
# DO NOT HARD-CODE THIS VALUE
GITHUB_TOKEN := $(GITHUB_TOKEN)

# The AWS Command Line Interface (AWS CLI) is an open source tool
# that enables you to interact with AWS services using commands in
# your command-line shell.  It must be present on your system.  Run the 'make'
# command 'install-aws-cli' to install it if you do not have it.  Be sure to
# run 'aws configure' after installing it.  This will place your AWS
# credentials into ~/.aws/credentials.
AWS := aws
S3  := $(AWS) s3

# The AWS region of choice; this can also be in .aws/config
REGION := --region us-west-2

### END OF USER-DEPENDENT VARIABLES
###############################################################################
### MAKE-GENERATED VARIABLES

### PROJ AND ORG
# ORG is the name of this Org file with extension .org
# PROJ is the project name---the Org file name without extension.

### NOTE: there can be only one Org file in the project directory;
# so far this has not been a problem, but it might be.

ORG  := $(shell ls *.org)
PROJ := $(basename $(ORG))

### NOTE: S is needed only for the Template file because of the way it is nested
# one level deep in the Templates GitHub repo, which uses the plural form
# of Templates, whereas this file uses the singular form, Template.  So when
# the homepage link is updated, the curl command must be told to use the plural
# form.	 This is obviously a hack only for my own use and can be removed once
# I clean up this anomaly.

ifeq ($(PROJ),$(basename $(notdir $(TEMPLATE))))
S := s
endif

# The AWS S3 bucket to use to store the html source file; it is found at the
# key #+bucket towards the beginning of the file and should include the appropriate
# suffix (.com, .net, .org, etc)
BUCKET       := $(shell $(EDITOR) --eval \
	       '(with-current-buffer (find-file-noselect "$(ORG)") \
		  (save-excursion \
		    (goto-char (point-min)) \
		    (re-search-forward "^\#[+]bucket:\\(.*\\)$$") \
		    (match-string-no-properties 1)))')
S3_BUCKET    := s3://$(BUCKET)
HTTPS_BUCKET := https://$(BUCKET)

### DIR, SRC
# DIR is the .info name found at '#+texinfo_filename:<DIR>.info' (at
# the bottom of this file in the export configuration settings)
# without its extension, used as the INFO filename and the name of the
# HTML export directory; this code uses the lowercased PROJ name if
# there is no '#+texinfo_filename'.
# SRC is HTML directory based upon the DIR name

DIR := $(shell $(EDITOR) --eval \
	'(with-current-buffer (find-file-noselect "$(ORG)") \
		(save-excursion \
		(goto-char (point-min)) \
		(re-search-forward "^\#[+]\\(?:texinfo_filename\\|TEXINFO_FILENAME\\):\\(.*\\).info$$" nil t) \
		(match-string-no-properties 1)))')
ifeq ($(DIR),nil)
	DIR := $(shell echo $(PROJ) | tr "[:upper:]" "[:lower:]")
endif

SRC := $(DIR)/

### VERS: v1.2.34/
# VERS is the version number of this Org document.
# When sync is run after the version number has been updated, then VERS
# picks up the newly-changed value.  VERS used to be staticly imbedded
# when the Makefile was tangled, but it needs to be dynamic for
# development.

# QUERY: should this number be formatted like this, or should it be just the numbers?
# The reason it includes them is the S3PROJ obtains the name from the S3 bucket, and
# it includes them.  But it only includes them because I have made it so.  Not a good
# reason just by itself.  The ending slash is not actually a part of the version, but
# comes from the way the 'aws2 ls' command returns its values.	So VERS should probably
# not include the trailing slash, although it doesn’t hurt anything.

VERS := v$(shell $(EDITOR) --eval \
	'(with-current-buffer (find-file-noselect "$(ORG)") \
		(save-excursion \
		(goto-char (point-min)) \
		(re-search-forward "^\#[+]\\(?:macro\\|MACRO\\):version Version \\(\\(?:[[:digit:]]+[.]?\\)\\{3\\}\\)") \
		(match-string-no-properties 1)))')/

### AWS
# PROJ_LIST contains the list of projects currently uploaded to
# the S3 bucket; each item contains the name of the project and its
# current version.

PROJ_LIST := $(strip $(filter-out PRE, $(shell $(AWS) s3 ls $(S3_BUCKET))))

### PROJ_LIST
# The name of the current project as obtained from S3: 'proj-v1.2.34/'
# If there is no current project in the S3 bucket, then assign a value equal to
# the Org project and version instead.
### S3VERS
# The version of this project currently installed in the S3 bucket: 'v1.2.34/'
# If there is no current version in the S3 bucket, then assign the version from
# this Org file instead.

S3PROJ := $(filter $(DIR)%,$(PROJ_LIST))
ifeq ($(S3PROJ),$(empty))
	S3PROJ := $(DIR)-$(VERS)
endif

S3VERS := $(subst $(DIR)-,,$(filter $(DIR)%, $(PROJ_LIST)))
ifeq ($(S3VERS), $(empty))
	S3VERS := $(VERS)
endif

### GITHUB
# USER is the current user's GitHub login name.

# The user name used to be statically embedded into the Makefile
# during tangle, but in an effort to make the Makefile dynamically
# indepedent, dynamic code has replaced the static code.  The code
# that placed the static name in the Makefile was a 'node' script that
# ran in a separate Org process during tangle.	An unfortunate fact of
# 'make' is that 'make' strips the quote marks from the string
# obtained from the 'curl' command when the 'make shell' command
# returns the string.	 This makes the string malformed JSON and
# unparsable by most JSON parsers, including 'node’.	However,
# 'perl'’s core module JSON::PP (but not JSON::XS) has facilities to
# parse very malformed JSON strings.	Therefore, this dynamic code
# uses 'perl' and the core module JSON::PP to parse the 'curl' string
# into a 'perl' JSON object which can return the login name.	This
# code should work with any version of 'perl' without having to
# install any modules.

USER := $(shell \
	  curl -sH "Authorization: token $(GITHUB_TOKEN)" https://api.github.com/user \
	  | \
	  perl -MJSON::PP -e \
	      '$$/ = ""; \
	       my $$json = JSON::PP->new->loose->allow_barekey->decode(<STDIN>); \
	       print $$json->{login};' \
	  )

### TOOLS & RESOURCES
# tools is a directory holding tangled scripts, such as cmprpl
TOOLS	:= tools
CMPRPL	:= $(TOOLS)/cmprpl
SAVE	:= resources

### TEXINFO
TEXI	:= $(PROJ).texi
INFO	:= $(DIR).info
PDF	:= $(PROJ).pdf
INDEX	:= index.html
HTML	:= $(DIR)/$(INDEX)
DIR_OLD	:= $(DIR)-old

### AWS S3
DST_OLD	:= $(S3_BUCKET)/$(S3PROJ)
DST_NEW	:= $(S3_BUCKET)/$(DIR)-$(VERS)
EXCL_INCL:= --exclude "*" --include "*.html"
GRANTS	:= --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
S3SYNC	:= $(S3) sync --delete $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
S3MOVE	:= $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)
S3COPY  := $(S3) cp $(INDEX) $(S3_BUCKET) $(REGION) $(GRANTS)

###############################################################################

default: check texi info html pdf

PHONY: default all check values boot \
	  texi info html pdf \
	  open-org open-texi open-html open-pdf \
	  clean dist-clean wiped-clean \
	  help sync update \
	  install-aws-cli \
	  index-html upload-index-html

values: check
	  @printf "$${BLUE}Values...$${CLEAR}\n"
	  @echo TEMPLATE:	$(TEMPLATE)
	  @echo EDITOR:		$(EDITOR)
	  @echo USER:		$(USER)
	  @echo ORG:		$(ORG)
	  @echo PROJ:		$(PROJ) $S
	  @echo BUCKET:		$(BUCKET)
	  @echo S3_BUCKET:	$(S3_BUCKET)
	  @echo HTTPS_BUCKET:	$(HTTPS_BUCKET)
	  @echo VERS:		$(VERS)
	  @echo S3PROJ:		$(S3PROJ)
	  @echo S3VERS:		$(S3VERS)
	  @echo DIR:		$(DIR)
	  @echo DIR_OLD:	$(DIR_OLD)
	  @echo SRC:		$(SRC)
	  @echo DST_OLD:	$(DST_OLD)
	  @echo DST_NEW:	$(DST_NEW)
	  @echo PROJ_LIST:	$(PROJ_LIST)

check:
	  @printf "$${BLUE}Checking dependencies...$${CLEAR}\n"

	  @[[ -z $(BUCKET) ]] && \
	     { printf "$${RED}$(BUCKET) $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${CYAN}BUCKET: $${GREEN}$(BUCKET)$${CLEAR}\n";

	  @[[ -z $${GITHUB_TOKEN} ]] && \
	     { printf "$${RED}GITHUB_TOKEN $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${CYAN}GITHUB_TOKEN: $${GREEN}SET$${CLEAR}\n";

	  @[[ (-d ~/.aws) && (-f ~/.aws/credentials) && (-f ~/.aws/config) ]] && \
	     printf "$${CYAN}AWS credentials and config: $${GREEN}SET$${CLEAR}\n" || \
	     { printf "$${RED}~/.aws 'credentials' and 'config' must be set.$${CLEAR}\n"; exit 1; }

	  @[[ "$(shell $(EDITOR) --eval '(member (quote texinfo) org-export-backends)')" = "(texinfo)" ]] && \
		printf "$${CYAN}Texinfo backend: $${GREEN}INSTALLED.$${CLEAR}\n" || \
		{ printf "$${YELLOW}Texinfo backend:$${CLEAR} $${RED}NOT INSTALLED; it must be installed.$${CLEAR}\n"; exit 1; }

	  @[[ $(shell $(EDITOR) --eval '(symbol-value org-confirm-babel-evaluate)') == "t" ]] && \
		{ printf "$${YELLOW}org-confirm-babel-evaluate:$${CLEAR} $${RED}T; set to NIL.$${CLEAR}\n"; exit 1; } || \
		printf "$${CYAN}org-confirm-babel-evaluate: $${GREEN}OFF.$${CLEAR}\n\n"

open-org: $(ORG)
	  @$(EDITOR) -n $(ORG)
$(ORG):
	  @echo 'THERE IS NO $(ORG) FILE!!!'
	  exit 1

texi: $(TEXI)
$(TEXI): $(ORG)
	 @echo Making TEXI...
	 @$(EDITOR) -u --eval \
		"(with-current-buffer (find-file-noselect \"$(ORG)\" t) \
			(save-excursion \
			(org-texinfo-export-to-texinfo)))"
	 @echo Done making TEXI.
open-texi: texi
	 @$(EDITOR) $(TEXI)

info: $(INFO)
$(INFO): $(TEXI)
	 @echo Making INFO...
	 @makeinfo $(TEXI)
	 @echo Done making INFO.
open-info: info
	 @$(EDITOR) $(INFO)

html: $(HTML)
$(HTML): $(TEXI)
	 @echo Making HTML INFO..
	 @makeinfo --html -o $(DIR) $(TEXI)
	 @echo Done making HTML.
	 $(CMPRPL) $(DIR) $(DIR_OLD)
open-html: html
	 @open $(HTML)

# If pdftexi2dvi produces an error, it may still produce a viable PDF;
# therefore, use --tidy.  If it produces an error, try to link the PDF;
# if it does not produce an error, the PDF will be added to the top dir
# and there will be no attempt to link.
pdf: $(PDF)
$(PDF): $(TEXI)
	 @echo Making PDF INFO...
	 @-pdftexi2dvi --quiet --build=tidy $(TEXI) || ln -s $(PROJ).t2d/pdf/build/$(PDF) $(PDF)
	 @echo Done making PDF.
open-pdf: pdf
	 @open $(PDF)

sync:	$(HTML)
	@echo Syncing version $(VERS) onto $(S3VERS)...
	$(S3SYNC)
	@echo Done syncing.
	[[ $(VERS) != $(S3VERS) ]] && { echo Moving...; $(S3MOVE); echo Done moving.;  make homepage; } || :

# This is a target-specific variable for updating the “description”
# key on the GitHub repo page with the current version number.	It
# first makes a curl call to the GitHub project repo, finds the
# “description” line, pulls out the description only (leaving the old
# version) and then prints the value with the current version number.
# This value is used by the “homepage:” target in the PATCH call.
# This method is arguably harder to code but faster to run than using
# Perl with the JSON::PP module.

homepage: description = $(shell \
	curl -s \
		-H "Authorization: token $(GITHUB_TOKEN)" \
		https://api.github.com/repos/$(USER)/$(PROJ)$S | \
		(perl -ne 'if (/^\s*\"description\":\s*\"(.*): v(?:(?:[[:digit:]]+[.]?){3})/) {print $$1}'))

### NOTE the use of the S variable at the end of PROJ; this is to handle
# the singular case of the GitHub repo using the plural form, Templates
# whereas the the Template.org file uses the singular form.
homepage: $(ORG) upload-index-html
	  @echo Updating homepage...
	  @echo DESCRIPTION: $(description)
	  @echo VERS: $(VERS)
	  @curl -i \
		-H "Authorization: token $(GITHUB_TOKEN)" \
		-H "Content-Type: application/json" \
		-X PATCH \
		-d "{\"homepage\":\"$(HTTPS_BUCKET)/$(DIR)-$(VERS)\",\
		     \"description\":\"$(description): $(VERS)\"}" \
		https://api.github.com/repos/$(USER)/$(PROJ)$S
	  @echo Done updating homepage.

index-html: $(INDEX)
$(INDEX): $(ORG)
	@echo making index.html...
	$(EDITOR) --eval \
	"(with-current-buffer (find-file-noselect \"$(ORG)\") \
		(save-excursion \
		(org-link-search \"#project-index-title\") \
		(org-export-to-file (quote html) \"index.html\" nil t)))"
	@echo Done making index.html.

upload-index-html: $(INDEX)
	 @echo Uploading index.html...
	 $(S3COPY)
	 @echo Done uploading index.html

update: $(ORG)
	@echo Updating $(ORG)...
	$(EDITOR) -u --eval '\
	(progn \
	(with-current-buffer (find-file-noselect "$(TEMPLATE)") \
	     (save-excursion \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-copy-subtree))) \
	(with-current-buffer (find-file-noselect "$(ORG)") \
	     (save-excursion \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-yank) \
	     (org-cut-subtree) \
	     (save-buffer) \
	     (kill-buffer) \
	     (setq org-confirm-babel-evaluate nil) \
	     (org-babel-tangle-file "$(ORG)"))))'
	 @echo Done updating $(ORG).

install-aws-cli:
	  curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg" && \
	  sudo installer -pkg AWSCLIV2.pkg -target / && \
	  which aws && aws --version
	  rm -rf AWSCLIV2.pkg

clean:
	  -rm *~
	  -for file in *.??*; \
	  do \
		  ext=$${file#$(PROJ).}; \
		  [[ ! $${ext} =~ org|texi|info|pdf|html ]] && rm -rv $${file}; \
	  done

dist-clean: clean
	  -rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)
	  -for dir in *; \
	  do \
		  [ -d $$dir -a $$dir != "$(DIR_OLD)" -a $$dir != $(SAVE) ] && \
		  rm -vr $$dir; \
	  done

wipe-clean: dist-clean
	  -rm -rf Makefile Readme.md $(DIR_OLD)
	  git checkout Makefile README.md

git-ready: dist-clean
	  git checkout Makefile
	  git checkout README.md
	  git status

help:
	  @echo '"make default" makes the .texi file, the .info file, \
	  the html files, and the .pdf file.'
	  @echo

	  @echo '"make check" checks for prerequistes'
	  @echo '"make values" runs check and prints variable values'
	  @echo

	  @echo '"make sync" syncs the html files in the AWS S3 bucket BUCKET; \
	  you must have your AWS S3 bucket name in the env var AWS_S3_BUCKET; \
	  You must have your AWS credentials installed in ~/.aws/credentials'
	  @echo

	  @echo '"make texi" makes the .texi file'
	  @echo '"make info" makes the .info file'
	  @echo '"make html" makes the html distribution in a subdirectory'
	  @echo '"make pdf" makes the .pdf file'
	  @echo

	  @echo '"make open-org" opens the ORG program using emacsclient for editing'
	  @echo '"make open-texi" opens the .texi file using emacsclient for review'
	  @echo '"make open-html" opens the distribution index.html file \
	  in the default web browser'
	  @echo '"make open-pdf" opens the .pdf file'
	  @echo

	  @echo '"make install-aws-cli" installs the "aws cli v2" command-line tools'
	  @echo 'You also need to run "aws configure" and supply your Access Key and Secret Access Key'

	  @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	  @echo '"make dist-clean" cleans, removes the html distribution, \
	  and removes the build directory'
	  @echo '"make wipe-clean" wipes clean the directory, including old directories'
	  @echo '"make boot" tangles all of the files in Template'

#+end_src

*** TODO Next
1. The CloudFront configuration needs to be updated recognize the new version
   directory that is created as part of the ~sync~ operation.

2. Update the GitHub HOME website link for each new sync operation.

3. Store on GitHub a version of each other format upon a sync operation (i.e.,
   the INFO and PDF versions)

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation.	 This
is to make sure the ~cmprpl~ source code exists in the ~tools/~ directory
before running the Makefile target =html=.  It also makes sure there is a
Makefile on an initial export.	The following code is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The AWS ~sync~ command relies upon time stamps to determine whether two
programs are identical or not, as well as content.  If two otherwise identical
files have different time stamps, ~sync~ will assume they are different and
will process the newer.	 However, the ~texinfo~ ~makeinfo --html~ command
produces all new files even if some files (or most files) remain unchanged.
This means that all files will be uploaded to the AWS S3 bucket on every
iteration, even though the majority of the files are actually unchanged.

The ~cmprpl~ source code attempts to resolve the issue of identical exported
code having different time stamps, thus defeating the benefit provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: =$DIR_NEW=.  If
it doesn’t, then it is in an improper state and the program stops with an error
message.

The program then checks if an old directory exists, =$DIR_OLD=.	 If one
doesn’t, then one is created by copying the current new directory.  This
provides a baseline for comparisons going forward.  The program exits at that
point.	It is very important that the =$DIR_OLD= directory not be deleted going
forward.

Given that =$DIR_OLD= exists, the program then loops through all files in
=$DIR_NEW= and compares them to the files in =$DIR_OLD=.  If the files are
identical, the =$DIR_OLD= file replaces the =$DIR_NEW= file while retaining the
old time stamp (using the ~-p~ option of ~cp~.	If a file is different, then
the =$DIR_NEW= file replaces the =$DIR_OLD= file, thus giving it updated
content and an updated time stamp.  If the file does not exist in the
=$DIR_OLD= directory, then it is added.

The program then loops through all of the files in the old directory and deletes
any that do not exist in the new directory.  Now both directories should be in
sync.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  DIR_NEW=$1
  DIR_OLD=$2

  [[ -d $DIR_NEW ]] || { echo "ERROR: $DIR_NEW does not exist"; exit 1; }
  [[ -d $DIR_OLD ]] || { echo "CREATING: $DIR_OLD does not exist"; cp -a $DIR_NEW $DIR_OLD; exit 0; }

  for newfile in $DIR_NEW/*
  do
      oldfile=$DIR_OLD/$(basename $newfile)
      if [[ -e $oldfile ]]
      then
	 if cmp -s $newfile $oldfile
	 then
	     printf "${GREEN}copying OLD to NEW${CLEAR}: "
	     cp -vp $oldfile $newfile
	 else
	     printf "${PURPLE}copying NEW to OLD${CLEAR}: "
	     cp -vp $newfile $oldfile
	 fi
      else
	  printf "${BLUE}creating NEW in OLD${CLEAR}: "
	  cp -vp $newfile $oldfile
      fi
  done

  for oldfile in $DIR_OLD/*
  do
      newfile=$DIR_NEW/$(basename $oldfile)
      if [[ ! -e $newfile ]]
      then
	  printf "${RED}removing OLD${CLEAR}: "
	  rm -v $oldfile
      fi
  done
#+end_src


** Update Utility Commands
*** Get Parsed Org Tree
This function looks for an Org file in the present working directory, and if it
finds one returns a parsed tree using ~org-element-parse-buffer~.  It returns
=nil= if there is no Org file or if the found file is not in ~org-mode~.

#+name:get-parsed-org-tree
#+header: :results silent
#+begin_src emacs-lisp
(defun get-parsed-org-tree (&optional org-dir)
  "This function takes an optional directory name, changes to
that directory if given, otherwise uses the pwd, and finds an Org
file and returns its parsed tree, or nil if none found."
  (when org-dir
      (cd (file-name-as-directory org-dir)))
  (let ((buf (car-safe (find-file-noselect "*.org" nil nil t))))
    (if buf
	(with-current-buffer buf (org-element-parse-buffer))
      nil)))
#+end_src
*** Check for CID
This code checks whether an Org file contains a =custom_id= of a particular
value.  It accepts a ~cid-value~ and an optional directory.  If the directory
is not given, then it defaults to the current directory.  If throws an error if
the directory does not exist.  It returns =nil= if the given directory does not
contain an Org file.  It returns =t= if the Org file contains a node property
of =custom_id= and value ~cid-value~, or =nil= if not.  It uses
~get-parsed-org-tree~.

#+name:org-tree-cid-p
#+header: :results silent
#+begin_src emacs-lisp
(defun org-tree-cid-p (cid-value &optional org-dir)
  "Check whether an org file contains a custom_id of CID"
  (let ((tree (get-parsed-org-tree org-dir)))
    (car (org-element-map tree 'property-drawer
	   (lambda (pd) (org-element-map (org-element-contents pd) 'node-property
			  (lambda (np)
			    (and
			     (string= "custom_id" (org-element-property :key np))
			     (string= cid-value (org-element-property :value np))))))
	   nil t))))
#+end_src

#+name:run-org-tree-cid-p
#+header: :var cid="build-tools"
#+header: :var dir="/usr/local/dev/programming/MasteringEmacs"
#+header: :var gpot=get-parsed-org-tree()
#+header: :var otcp=org-tree-cid-p()
#+header: :results value
#+header: :eval never-export
#+begin_src emacs-lisp
(org-tree-cid-p cid dir)
#+end_src

#+call: run-org-tree-cid-p(dir="/usr/local/dev/programming/MasteringEmacs")

*** Add Bucket
This command utility takes two arguments:
1. The name of an Org file (e.g., "MasteringEmacs.org"); and
2. The name of an AWS S3 bucket


It checks whether the Org file in the present working directory has a
"#+bucket: keyword". If it does, then it simply returns nil. If it does not,
then it adds that bucket name as a keyword (e.g. "#+bucket:pinecone-forest") to
the Org file right after where the =version= macro is located, and saves the
file. It returns a message upon succuess.

#+name:add-bucket-fn
#+header: :eval never-export
#+header: :var parsed-tree=get-parsed-org-tree()
#+begin_src emacs-lisp
  ;;; Add a keyword named 'bucket' just after the version macro.
  ;;; This function should be run from within the directory containing the Org file.
  (defun add-bucket (s3-bucket)
    "Add the name of the associated AWS S3 bucket to an Org templated file in the PWD."
    (with-current-buffer (car (find-file-noselect "*.org" nil nil t))
      (goto-char (point-min))
      (let* ((tree parsed-tree)
	     ;; find the beginning position of the first headline to act as a limit
	     (hl1 (org-element-map tree (quote headline) (lambda (hl) (org-element-property :begin hl)) nil t)))
	;; Check for the presence of a bucket keyword before the first headline
	(unless (re-search-forward "^#\\+bucket:" hl1 t)
	  ;; If no bucket keyword is found, search for a keyword MACRO with the value 'version'
	  (org-element-map tree (quote keyword)
	    (lambda (kw) (when (and (string= "MACRO" (org-element-property :key kw))
				    (string-match-p "version" (org-element-property :value kw)))
			   ;; return the end position of the MACRO; subtract an empty line if there is one
			   (goto-char (- (org-element-property :end kw) (org-element-property :post-blank kw)))
			   (insert "#+bucket:" s3-bucket)
			   (newline)
			   (basic-save-buffer)
			   (message (format "Added bucket %s" s3-bucket))))
	    nil t)))))
#+end_src
** Bucket Index HTML
The bucket should contain a master ~index.html~ file that links to each of the
individual project ~index.html~ files.  The master ~index.html~ file will be
placed at the root of the bucket, ~https://<bucket-name>.com/~, and the bucket
must be set up to serve this ~index.html~ when the user hits the root.

*** Get Bucket Name
 This code searches for the keyword-value pair =bucket:<BUCKET-NAME>= that
 should be located towards the beginning of the file, and returns the value
 =BUCKET-NAME= or nil if not found.

#+name: get-bucket-name
#+header: :results value
#+begin_src emacs-lisp
   (save-excursion
     (goto-char (point-min))
     (re-search-forward "^#\\+bucket:\\s*?\\(.*\\)$" nil t)
     (match-string-no-properties 1))
#+end_src

For some reason, ~get-bucket-name~ does not work when called from the headline
[[#project-index-links][=Links for bucket=]] below when creating =index.html=, even if it returns as
~(prin1 ...)~ and is set up to ~:return output~; the call receives =nil=. The
following code from ~bucket-name~, however, works. I don't know why.

#+name: bucket-name
#+header: :results output
#+header: :var bucket-name=get-bucket-name()
#+begin_src emacs-lisp
(prin1 bucket-name)
#+end_src

*** Bucket HTTPS URL
This code calls ~get-bucket-name~ and returns the value returned as a URL string or
nil.

#+name: bucket-https-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "https://" b ".com")
#+end_src

*** S3 Bucket URL
This code calls ~get-bucket-name~ and returns the AWS S3 bucket url.

#+name: s3-bucket-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "s3://" b ".com")
#+end_src

*** Bucket Projects List
This code uses the ~s3-bucket-url~ result to obtain the list of projects in the
bucket.  It does this by calling the AWS S3 high-level command ~ls~ and then
removing the =PRE= string in each result.  The result that is returned is a
single string that can be separated into individual links by breaking the
string on spaces.

#+name: bucket-projects-list
#+header: :results output
#+header: :var bucket=s3-bucket-url()
#+begin_src sh
/usr/local/bin/aws s3 ls ${bucket} | sed -ne 's/^.*PRE //p'
#+end_src

*** Bucket Project Links
This code uses the result from ~bucket-projects-list~ to create an unordered
list of links written to bucket projects, written in Org-mode syntax. It is
executed by a =#+call:= in [[*Bucket Index][*Bucket Index]] during an HTML export of that subtree
to a file called =index.html=.

#+name: bucket-project-links
#+header: :var b-url=bucket-https-url()
#+header: :var projects=bucket-projects-list()
#+header: :results output raw
#+begin_src emacs-lisp
(seq-do (lambda (u) (princ (format "- [[%s/%sindex.html][~%s~]]
" b-url u u))) (split-string projects))
#+end_src

*** Bucket Index
    :PROPERTIES:
    :custom_id: project-index-title
    :export_file_name: index.html
    :export_subtitle: {{{version}}} created {{{upload-date}}}
    :END:
#+html_doctype: html5
#+options: toc:nil html5-fancy:t

#+html: <hr>

**** Links for bucket call_bucket-name()
     :PROPERTIES:
     :unnumbered: t
     :custom_id: project-index-links
     :END:

#+call: bucket-project-links()
** Samples
#+begin_comment
(cd "~/Dev/Emacs/MasteringEmacs/")
"/Users/pine/Dev/Emacs/MasteringEmacs/"

(defun add-bucket (org bucket)
  "Add a bucket keyword BUCKET to the org file ORG."
  (interactive "fFile: \nsBUCKET: ")
  (with-current-buffer (find-file-noselect org)
    (let* ((tree (org-element-parse-buffer))
	   (ins (car (org-element-map tree (quote section)
		 (lambda (s)
		   (org-element-map s (quote keyword)
		     (lambda (kw) (when (equal "MACRO" (org-element-property :key kw)) (1- (org-element-property :end kw))))
		     nil nil :keyword))
		 nil t nil nil))))
      (goto-char ins)
      (insert (format "#+bucket:%s\n" bucket))
      ())))

(add-bucket "MasteringEmacs.org" "pinecone-forest")
nil

(defun hl-region (raw-hl)
  "Obtain the begin and end positions for a headline."
  (with-current-buffer (find-file-noselect (getenv "SYNC_ORG_TEMPLATE"))
    (let* ((tree (get-parsed-tree))
	   (hl (car-safe (org-element-map tree 'headline
			   (lambda (hl) (when
					    (string= raw-hl
						     (org-element-property :raw-value hl))
					  (org-element-context)))
			   nil nil t))))
      (cons
       (org-element-property :begin hl)
       (org-element-property :end hl))
      )))

(hl-region "Build Tools")

(4888 . 29646)

(defun get-hl-with-prop (org-dir hl-prop)
  "Given a directory containing an Org template file and a custom_id property name, return the headline containing that custom_id, or nil if none."
  (progn
    (cd org-dir)
    (let ((org-buf (car-safe (find-file-noselect "*.org" nil nil t))))
      (if org-buf
	  (with-current-buffer org-buf
	    (let ((tree (org-element-parse-buffer)))
	      (org-element-map tree 'headline
		(lambda (hl)
		  (let ((cid (org-element-property :CUSTOM_ID hl)))
		    (when (string= hl-prop cid)
		      (and
		       (message (format "Found the headline %s containing property %s." (org-element-property :raw-value hl) hl-prop))
		       hl))))
		nil t)))
	(and
	 (message (format "The directory %s does not contain an Org file." org-dir))
	 nil)))))

(get-hl-with-prop "~/Dev/Templates/Org" "build-tools")

(headline (:raw-value "Build Tools" :begin 4888 :end 29646 :pre-blank 0 :contents-begin 4902 :contents-end 29645 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 1 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 4888 :FROM-FILE "Template" :CUSTOM_ID "build-tools" :APPENDIX "t" :title "Build Tools"))









;;; Add a keyword named 'bucket' just after the version macro.
;;; This function should be run from within the directory containing the Org file.
(defun add-bucket (org-file s3-bucket)
  "Add the name of the associated AWS S3 bucket to an Org templated file."
  (with-current-buffer (find-file-noselect org-file)
    (goto-char (point-min))
    (let* ((tree (org-element-parse-buffer))
	   ;; find the beginning position of the first headline to act as a limit
	   (hl1 (org-element-map tree (quote headline) (lambda (hl) (org-element-property :begin hl)) nil t)))
      ;; Check for the presence of a bucket keyword before the first headline
      (unless (re-search-forward "^#\\+bucket:" hl1 t)
	;; If no bucket keyword is found, search for a keyword MACRO with the value 'version'
	(org-element-map tree (quote keyword)
	  (lambda (kw) (when (and (string= "MACRO" (org-element-property :key kw))
				  (string-match-p "version" (org-element-property :value kw)))
			 ;; return the end position of the MACRO; subtract an empty line if there is one
			 (goto-char (- (org-element-property :end kw) (org-element-property :post-blank kw)))
			 (insert "#+bucket:" s3-bucket)
			 (newline)
			 (basic-save-buffer)
			 (message (format "Added bucket %s" s3-bucket))))
	  nil t)))))

(add-bucket "MasteringEmacs.org" "pinecone-forest.com")
nil

"Added bucket pinecone-forest.com"









(keyword (:key "MACRO" :value "version Version 0.0.108" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...))
("TITLE" "SUBTITLE" "AUTHOR" "DATE" "MACRO" "TEXINFO" "TEXINFO" "CINDEX" "CINDEX" "CINDEX" "CINDEX" "CINDEX" ...)







((keyword (:key "MACRO" :value "version Version 0.0.107" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...)))
#+end_comment

* Build Scripts
  :PROPERTIES:
  :custom_id: build-scripts
  :from-file: Template
  :END:
** Create and Update Projects
*** Create New Project
 Copy this project template file into a new directory, update its title, author,
 and AWS S3 bucket, and tangle the bootstrap Makefile and initial Readme, then
 create a new git repository and create an initial git commit. Finally, save the
 project in GitHub, and there add a description and link to its AWS S3 bucket.

 #+name:create-new-project
 #+header: :tangle /usr/local/dev/bin/org-template.el
 #+begin_src emacs-lisp
   (defun create-new-project (project title author &optional bucket)
     "Create a new project in a new directory."
     (message "NEW PROJECT=%s TITLE=%s AUTHOR=%s BUCKET=%s" project title author bucket)
     (mkdir project t)
     (let ((projfile (concat project "/" project ".org")))
       (copy-file (getenv "SYNC_ORG_TEMPLATE") projfile)
       (with-current-buffer (find-file-noselect projfile)
         (goto-char (point-min))
	     (re-search-forward "^#[+]title:\s*\\(TITLE\\)$")
	     (replace-match title t nil nil 1)
	     (re-search-forward "^#[+]author:\s*\\(AUTHOR\\)$")
	     (replace-match author t nil nil 1)
	     (re-search-forward "^#[+]macro:\s*version Version \\(.*\\)$")
	     (replace-match "0.0.0" t nil nil 1)
	     (when bucket
	         (re-search-forward "^#[+]bucket:\s*\\(.*\\)$")
	       (replace-match bucket t nil nil 1))
	     (re-search-forward "^#[+]texinfo_printed_title:\\(PRINTED TITLE\\)$")
	     (replace-match (concat project "---" title) t nil nil 1)
	     (save-buffer)
	     (org-babel-goto-named-src-block "project-readme")
	     (org-babel-tangle (quote (4)))
	     (org-babel-goto-named-src-block "boot-template")
	     (org-babel-tangle (quote (4)))
         (kill-buffer))))
 #+end_src

*** Update Old Project
**** Add a Custom_Id
 This code checks a project file F to see if it contains a =property: value=
 pair (P, V) in a property drawer right under the headline HL. If it does not,
 it adds one. This code assumes the project file contains the heading HL for
 which it searches. It will throw an error if such a heading is not found.

 #+name: add-pv-to-hl
 #+header: :tangle /usr/local/dev/bin/org-template.el
 #+begin_src emacs-lisp
    (defun add-pv-to-hl (f hl p v)
      "In file F add a property P with value V into a property
    drawer (creating one if necessary) at headline HL."
       (with-current-buffer (find-file-noselect f)
	 (save-excursion (goto-char (point-min))
	 (re-search-forward (concat "^*\s*" hl))
	 (beginning-of-line 2)
	 (let* ((e (org-element-at-point))
		(et (org-element-type e)))
	   (unless (string= et "property-drawer")
	       (message "Adding property drawer to headline %s" hl)
	       (org-insert-property-drawer))
	   (unless (org-entry-get (point) p)
	     (message "Adding property %s with value %s" p v)
	     (org-entry-put (point) p v)
	     (save-buffer))))))
 #+end_src

**** Replace Build Tools

#+name: replace-utilities
#+header: :tangle /usr/local/dev/bin/org-template.el
#+begin_src emacs-lisp

  (defun project-tree (proj-buf)
    "With a buffer PROJ-BUF, return an Org-parsed tree"
    (with-current-buffer proj-buf
      (org-element-parse-buffer 'headline)))




  (defun find-hl (proj-tree cid)
    "With an Org-parsed tree PROJ-TREE, find a headline with a
  particular property drawer custom_id of CID."
    (let* ((cid-hl (org-element-map proj-tree 'headline
            (lambda (e) (let ((lev (org-element-property :level e))
                              (bt (org-element-property :CUSTOM_ID e)))
                          (and (= lev 1)
                               (string= bt cid)
                               e)))
            nil t))
           (car cid-hl))
      (cons (org-element-property :begin cid-hl)
            (org-element-property :end cid-hl))))


#+end_src

The ~replace-build-tools~ function replaces a section of an old templated file
with the corresponding section from the source template file found in
=SYNC_ORG_TEMPLATE=, which is presumably newer. It must be run from within the
directory holding the older templated file, and the original template file must
be identified by the environment variable =SYNC_ORG_TEMPLATE=.

This function works by parsing the buffers by headlines and then using
~org-element-map~ to find a level 1 headline containing a custom id of CID.
Once it finds such a headline, it records that section's beginning and ending
points. It does this for both the old template file and the template file. Then
it deletes that section from the old template file, and inserts the
corresponding section from the root template file.

#+name: replace-build-tools
#+header: :tangle /usr/local/dev/bin/org-template.el
#+begin_src emacs-lisp

    (defun replace-build-tools (cid)
      "Replaces a section of an Org template file identified by the
    custom_id CID with the corresponding section of the root
    template identified by the environment variable.

    OLD-BUF is the Org template in the current working directory.
    SYNC_ORG_TEMPLATE must be set."
      (let* ((old-buf (car (find-file-noselect "./*.org" nil nil t)))
	     (sync-buf (find-file-noselect (getenv "SYNC_ORG_TEMPLATE")))
	     (old-tree (project-tree old-buf))
	     (sync-tree (project-tree sync-buf))
	     (old-be (find-hl old-tree cid))
	     (sync-be (find-hl sync-tree cid)))
	  (set-buffer old-buf)
	  (delete-region (car old-be) (cdr old-be))
	  (goto-char (car old-be))
	  (insert-buffer-substring sync-buf (car sync-be) (cdr sync-be))
	  (save-buffer)))



#+end_src

*** Run Create and Update

**** Run Create
 This shell script is installed into $DEV/bin and is run by typing the shell
 command =new-org-template <...ARGS>= from the command-line to set up a new Org
 project at a particular point in your directory structure.  The main code is
 elisp, described above in [[*Create New Project][Create New Project]] and [[*Update Old Project][Update Old Project]].

 After a new project is installed into the directory structure, a git repo is
 established, as well as a new GetHub repo, and the initial commit is pushed up.

 #+name:run-create-and-update
 #+header: :tangle /usr/local/dev/bin/new-org-template
 #+header: :shebang "#!/usr/bin/env zsh"
 #+begin_src sh -n
   # run-org-template
   # $1 := project
   # $2 := title
   # $3 := author
   # [$4 := bucket] (default := pinecone-forest)

   USAGE="$0 <project> <title> <author> [<bucket>]\n"

   if [[ $1 =~ ^-(h|-?help)$ || ( $# < 3 || $# > 4 ) ]]; then
       printf "USAGE:\n$USAGE"
       exit 0;
   fi

   # verify command-line args contain only letters, digits, underscores and spaces
   RE="^[_a-zA-Z][_a-zA-Z0-9 ]+$"
   for arg in "$@"; do
       printf "$arg..."
       [[ $arg =~ $RE ]] || { printf ": ERROR\n"; exit 1; }
       printf "ok\n"
   done

   # bucket is optional
   if [[ -z $4 ]]; then
       bucket='pinecone-forest'
   else
       bucket=$4
   fi

   # the main code is in an elisp file
   ${EDITOR} --eval "(progn
                         (load-file \"/usr/local/dev/bin/org-template.el\")
                         (create-new-project \"$1\" \"$2\" \"$3\" \"$bucket\"))"

   # create a new Git repo and GitHub repo
   cd "$1"
   rm *~
   git init
   git add -A
   git commit -m "Initial commit"
   git log | cat
   git remote add origin git@github.com:wlharvey4/"$1".git

   curl -i -H "Authorization: token ${GITHUB_TOKEN}" \
	-d "{\"name\":\"$1\",\"description\":\"$2: v0.0.0/\"}" \
	https://api.github.com/user/repos

   git push origin master

   cd ..
   tree -a -L 1 "$1"
 #+end_src

**** Run Update

 #+header: :tangle /usr/local/dev/bin/update-org-template
 #+header: :shebang "#!/Applications/MacPorts/Emacs.app/Contents/MacOS/Emacs --script"
 #+begin_src emacs-lisp
   (load-file "/usr/local/dev/bin/org-template.el")

   (setq old-template (car (file-expand-wildcards "*.org" t)))

   (add-pv-to-hl old-template "Build Tools"   "custom_id" "build-tools")
   (replace-build-tools "build-tools")

   (add-pv-to-hl old-template "Build Scripts" "custom_id" "build-scripts")
   (replace-build-tools "build-scripts")
 #+end_src

** Ignore
  #+name:update-org-project
  #+begin_src emacs-lisp
    (defun get-parsed-tree (buf)
      "Given a buffer BUF, return a parsed tree."
      (with-current-buffer buf
	(org-element-parse-buffer 'headline)))

    (defun oep (p e)
      "Given a property P and element E, return that property's value."
      (org-element-property p e))

    (defun start-end (buf prop)
      "Given a buffer BUF and a property PROP, return the starting and ending points."
      (org-element-map
	  (get-parsed-tree buf)
	  'headline
	  (lambda (e) (when (string= (oep :CUSTOM_ID e) prop)
			(list
			 (oep :begin e)
			 (oep :end e))))
	  nil t))

    (defun update-old-project (&optional title author bucket)
      "Update an old project with new code."
      (with-current-buffer (car (find-file-noselect "./*.org" nil nil t))
	(save-excursion
	(goto-char (point-min))
	;; (when title
	;;   (re-search-forward "^#[+]title:\s*\\(.*\\)$")
	;;   (replace-match title t nil nil 1))
	;; (when author
	;;   (re-search-forward "^#[+]author:\s*\\(.*\\)$")
	;;   (replace-match author t nil nil 1))
	;; (when bucket
	;;   (re-search-forward "^#[+]bucket:\s*\\(.*\\)$")
	;;   (replace-match bucket t nil nil 1))
	(let* ((curbuf (current-buffer))
	      (orgsyncbuf (find-file-noselect (expand-file-name "Template.org" "/usr/local/dev/Templates/Org")))
	      (start-end-curbuf (start-end curbuf "build-tools"))
	      (start-end-sync (start-end orgsyncbuf "build-tools")))
	  (list start-end-curbuf start-end-sync)))))
  #+end_src

  #+begin_src emacs-lisp :results raw
  (update-old-project)
  #+end_src

  #+RESULTS:
  ((4928 36833) (4928 36833))

*** Create and Update Script                                   :dependencies:
    :PROPERTIES:
    :dependency1: org-template must be in $DEV/bin
    :dependency2: SYNC_ORG_TEMPLATE must be set as an environment variable
    :dependency3: "COLORS from profile"
    :dependency4: tree command
    :dependency5: git command
    :END:
 This code is a script file to create a new project from this template, and also
 to update a project with updated scripts. It is tangled into the ~$DEV/bin~
 directory and is called from the command line as ~org-template <project>
 [<author>] [git]~ or as ~org-template -u | --update~. Its create mode takes one
 required, and up to two optional arguments. The required argument is the name
 of the project. One optional argument is the name of the author. The other
 optional argument is the term =git=, meaning to initialize a =git= repository
 for the project. To update a project, call ~org-template --update~ from the
 project root.

 Here are the steps it takes:

 1. It checks for a call to =-h|--help=, and if found, prints the USAGE message.

 2. It next checks for =-u|--update=, and if found, calls the ~template-update~
    function. Otherwise, it calls the ~template-create~ function.

 3. It creates a new directory in the current working directory using the
    =project= argument.

 4. It copies this template into it (using the environment variable
    =SYNC_ORG_TEMPLATE= to find it) as a new Org file using, again, the name of
    the project.

 5. It then updates the title to the project name, the date, sets the version
    number to =0.0.0=, and optionally adds the author, using the =author=
    argument if it was given.

 6. It then deletes this script from the new Org project file, as it is not
    needed by a project file.

 7. It then tangles Boot Makefile and the default ~README.md~ into the project.

 8. If the term ='git'= is supplied as an argument, it initializes a new Git
    repository, creating a basic ~.gitignore~ file in it, adding the Org file
    and the ~README.md~ file and finally making an initial Git commit.

 9. Last, it prints an outline of the project’s structure using the ~tree~
    command.


 #+caption:Create Script
 #+name:create-update-script
 #+header: :mkdirp yes
 ##+header: :tangle /usr/local/dev/bin/org-template
 #+header: :shebang "#!/usr/bin/env bash"
 #+begin_src sh -n
   # org-template: create and update projects

   USAGE='
   '"$0..."'
   org-template -h | --help
   org-template <Project> [<Author>] [git]
   org-template -u | --update
   '

   template-create () {
       mkdir -v "$1"
       printf "copy "
       cp -v ${SYNC_ORG_TEMPLATE} "$1/$1.org"
       printf "${CLEAR}\n"

       sed -i '' -Ee '/^\#\+(title|TITLE):/ s/TITLE/'"$1"'/' \
	   -Ee '/^\#\+(date|DATE):\s*(.*)$/ s/$2/$(date '"+%F %R"')/' \
	   -Ee '/^\#\+(macro|MACRO):version Version/ s/[[:digit:].]+/0.0.0/' \
	   -Ee '/^\#\+(texinfo_printed_title|TEXINFO_PRINTED_TITLE):/ s/PRINTED TITLE/'"$1"'/' \
	   "$1/$1.org"

       [[ $# -ge 2 ]] && \
	   sed -i '' -Ee '/^\#\+(author|AUTHOR):/ s/AUTHOR/'"$2"'/' "$1/$1.org"

       printf "${CYAN}"
       ${EDITOR} --eval \
       "(with-current-buffer (find-file-noselect \"$1/$1.org\")
	  (save-excursion
	   (goto-char (point-min))
	   (re-search-forward \"#[+]name:project-readme$\")
	   (org-babel-tangle (quote (4)))
	   (search-forward \"** Create Script\")
	   (org-cut-subtree)
	   (save-buffer)
	   (re-search-forward \"^#[+]name:boot-template$\")
	   (org-babel-tangle (quote (4)))))"
       printf "${CLEAR}\n"

       if [[ (($# -eq 2) || ($# -eq 3)) && (($2 == 'git') || ($3 == 'git')) ]]
       then
	   cd $1 && {
	       rm *~
	       printf "${YELLOWBOLD}"
	       git init
	       printf "${CLEAR}"

	       echo "\
   .gitignore
   Makefile
   ,*~
   .*~
   ,*.texi
   ,*.info
   ,*.html
   ,*-old
   tools" > .gitignore

	       git add .
	       git commit -m "Initial commit of Project $1"
	   }
	   cd ..
       fi
       rm "$1"/*~

       printf "${PURPLEBOLD}\n"
       pwd
       printf "${CLEAR}"
       tree -aI .git $1

       return 0
   }

   template-update() {
       ${EDITOR} -u --eval \
		"(progn
		  (with-current-buffer (find-file-noselect (getenv \"SYNC_ORG_TEMPLATE\"))
		   (save-excursion
		    (goto-char (point-min))
		    (org-link-search \"#build-tools\")
		    (org-copy-subtree 2)))
		  (with-current-buffer (car (find-file-noselect \"./*.org\" nil nil t))
		   (save-excursion
		     (goto-char (point-min))
		     (org-link-search \"#build-tools\")
		     (org-paste-subtree 1 nil t t)
		     (org-cut-subtree 2)
		     (save-buffer))))"

       return 0;
   }

   main () {
       case $1 in
	   create)

	       printf "${PURPLE}"
	       read -n 1 -p "Create new project: $2 (y/n) ?"
	       printf "${CLEAR}\n\n"
	       [[ $REPLY =~ [yY] ]] && template-create "$2" || exit 0
	       ;;

	   update)

	       template-update
	       ;;
       esac
       exit 0
   }


   if [[ $1 =~ ^-(h|-help)$ ]]; then
	   printf "HELP:\n$USAGE"
	   exit 0
   fi

   if [[ $1 =~ ^-(u|-update)$ ]]; then
	   printf "UPDATE:\n"
	   main update
   fi

   [[ ($# -ge 1) && ($# -le 3) ]] && { printf "CREATE:\n";  main create $1; } || {
       printf "${RED}ARGUMENTS ERROR:${CLEAR}$USAGE\n"
       exit 1
   }

 #+end_src
** Project Readme
This adds the README.md template to a project. It should be customized uniquely
for the project.

#+name:project-readme
#+header: :tangle README.md
#+begin_src markdown
# TITLE
## Subtitle
## Author
## Date
## Version
# ABSTRACT
This is the Org Template file.	It is the parent of all other Org Info blogs,
and provides the source code for processing them in various different ways.
# INTRODUCTION
# CHAPTER
## Section
### Subsection
#+end_src

** Switch Emacs Init
This script allows the user to switch into using a different Emacs
initialization setup.  The script first lists the currently-selected
initialization setup, then it lists the available initialization setups, then
requests the user's choice.  After obtaining the choice, it changes the
symbolic link in =~/.emacs.d= to that chosen by the user.  Emacs is then killed
and restarted using the ~desktop-save~ feature.

Each initialization setup is a complete =~/.emacs.d= subtree, which must be set
up by the user, with its name given after a dash, such as =~/.emacs.d-original=
or =~/.emacs.d-cfbt= (“Clojure for the Brave and True”).

#+name:switch-emacs-init
#+header: :mkdirp yes
#+header: :shebang "#!/usr/bin/env bash"
#+header: :tangle /usr/local/dev/bin/switch-emacs-init
#+begin_src sh
  printf "${GREEN}"
  ls -l ~/.emacs.d | cut -f 12- -d ' '
  printf "${CLEAR}"
  echo
  select choice in $(ls -1d ~/.emacs.d-*) "abort"
  do
      echo -n 'You chose '
      printf " ${B_YELLOW}${F_BLACK}$choice${CLEAR}  "
      [[ $choice = "abort" ]] && exit 0
      rm ~/.emacs.d
      printf "${CYAN}"
      ln -vs $choice ~/.emacs.d
      echo
      printf "${RED}"
      read -N 1 -p "Restart Emacs now? (y/n) "
      printf "${CLEAR}\n"
      [[ $REPLY =~ y|Y ]] || { echo "Not restarting"; break; }
      echo "Restarting..."
      emacsclient --eval '(progn (desktop-save "~/.emacs.d-original/")(kill-emacs))'
      break
  done
  /Applications/MacPorts/EmacsMac.app/Contents/MacOS/Emacs --eval '(progn (server-start)(desktop-read "~/.emacs.d-original/"))' &
#+end_src

** Update RC Files
This code synchronizes the following configuration files:
- /etc/profile
- /etc/bashrc
- /etc/tmux.conf
- ~/.bash_profile
- ~/.bashrc
- ~/.tmux.conf


It first verifies that the files differ; then it will copy a newer file over an
older file.  If a  local file is updated with a newer  template file, then this
program updates the  Emacs ~server-socket-dir~ variable, if such  exists.  If a
template   is	updated	  with	 a   newer  local   file,   then   delete   the
~server-socket-dir~ value.

#+name:syncrc
#+header: :mkdirp yes
#+header: :tangle /usr/local/dev/bin/syncrc
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src shell
  [ -v TEMPLATES ] || {
      printf "${RED}ERROR: missing \$TEMPLATES env var${CLEAR}\n"
      exit 1
  }

  [ -v COMP ] || {
      printf "${RED}ERROR: missing \$COMP env var${CLEAR}\n"
      exit 1
  }

  set -e

  ## usage: syncrc [-f system|rc -t rc|system -h]
  ## if no options, process by natural age
  ## if -f and -t options, force update from ... to ...
  usage () {
	printf "\n${GREEN}USAGE: ${YELLOW}syncrc \
  ${WHITEBOLD}[${CYAN}-f ${MAGENTA}system|rc \
  ${CYAN}-t ${MAGENTA}rc|system \
  ${WHITEBOLD}]${CLEAR}\n"

	printf "${GREEN}force sync rc files \
  ${CYAN}'-f'${GREEN}rom ${MAGENTA}system|rc \
  ${CYAN}'-t'${GREEN}o ${MAGENTA}rc|system\
  ${CLEAR}\n\n"
	exit $1
  }

  # force update of either system or rc file
  touchup () {
    printf "In touchup with \$from: $from\n";
	case $from in
	    "system") printf "${WHITEBOLD}Touching $1..."; sudo touch $1; printf "${CLEAR}" ;;
	    "rc")     printf "${WHITEBOLD}Touching $2..."; touch $2; printf "${CLEAR}" ;;
	esac
  }

  # compare files to determine which one is newer
  comp () {
	[[ -e $1 && -e $2 ]] && { # only process if both files exist
	if ! cmp -s $1 $2
	then
	    [[ -n $from ]] && { # force update if $from is non-zero length
		touchup $1 $2
	    } || { :; }
	    [[ $1 -nt $2 ]] && { # system file is newer
		[[ -d $(dirname "$2") ]] || { # make sure rc dir exists
		    mkdir -vp $(dirname "$2")
		} || { :; }

		printf "${YELLOW}system is newer than rc${CLEAR}\n"
		echo; ls -l $1 $2; echo
			  printf "${BLUE}";
			  cp -ipv "$1" "$2";
			  printf "${CLEAR}"

			  ## delete the value of the emacs server-socket-dir in the rc file
			  grep -q "EMACS_SERVER_SOCKET_DIR=" "$2" && {
				  #printf "${WHITE}UNSETTING socket_dir...${CLEAR}\n"
				  sed -i'.bak' -Ee '/(EMACS_SERVER_SOCKET_DIR)=.*$/ s!!\1=TBD!' "$2"
			  } || { :; }

		  } || {
		    [[ "$2" -nt "$1" ]] && { # rc file is newer
		      printf "${YELLOW}rc is newer than system${CLEAR}\n"
		      echo; ls -l $2 $1; echo
		      [[ -w "$1" ]] && { # check if the system file is writable
			printf "${PURPLE}"
			cp -ipv "$2" "$1"
			printf "${CLEAR}"
		      } || {
			printf "${RED}You must authenticate... ${CLEAR}"
			printf "${PURPLE}"
			sudo cp -ipv "$2" "$1"
			printf "${CLEAR}"
		      }

		      ## update the value of the emacs server-socket-dir in the system file
		      grep -q "EMACS_SERVER_SOCKET_DIR=" "$1" && {
			socket_dir=$(${EMACS} -Q --batch --eval '(progn (require (quote server))(princ (file-name-as-directory server-socket-dir)))')
			printf "${WHITE}SETTING socket_dir=${socket_dir}${CLEAR}...\n"
			sed -i'.bak'-$$ -Ee '/(EMACS_SERVER_SOCKET_DIR)=.*$/ s!!\1='"$socket_dir"'!' "$1"
		      } || { :; }

		      } || {
			printf "${REDBOLD}ERROR: the files don't match but are the same age?${CLEAR}\n"
		      }
	      }
	else
	      printf "${CYAN}No difference.${CLEAR}\n"
	fi
	} || {
	    tocreate=$( if test -e "$1"; then echo "$2"; else echo "$1"; fi; )
	    printf "${WHITE}one file: ${RED}${tocreate} ${WHITE}does not exist...Create?${CLEAR}"
	    read -sn 1
	    if [[ $REPLY == [yY] ]]
	    then
		echo " Creating"
		outof=$( if test -e "$1"; then echo $1; else echo "$2"; fi; )
		mkdir -pv $(dirname "${tocreate}")
		cp -ivp "${outof}" "${tocreate}"
	    else
		echo " Not creating"
	    fi
	}
    } # end of comp()

    declare -a rcfiles=(/private/etc/profile /private/etc/bashrc /private/etc/tmux.conf ~/.bash_profile ~/.bashrc ~/.tmux.conf)

    ## see usage() abaove
    while getopts "f:t:h" opt
    do
	  case $opt in
	    'f') from=${OPTARG} ;;
	    't') to=${OPTARG}	;;
	    'h') usage 0	;;
	    '?') printf "${RED}ERROR ${CLEAR}\n"; usage 1; ;;
	     ,*) printf "OPTIND: ${RED}${OPTIND}${CLEAR}\n"; usage 1; ;;
	  esac
    done

    ## OPTIND must be either 1 (no options) or 5 (2 options)
    if [[ $OPTIND -gt 1 && $OPTIND -ne 5 ]]
    then
	  printf "${RED}ERROR: need both -f and -t${CLEAR}\n"
	  usage 1
    fi

    ## check for correct combination of from and to
    if [[ -n $from ]]
    then
	  if [[ $from == "system" ]]
	  then
	    if [[ $to != "rc" ]]
	    then
		printf "${RED}ERROR: incorrect combination: $from -- $to${CLEAR}\n"
		usage 1
	    fi
	  elif [[ $from == "rc" ]]
	  then
	    if [[ $to != "system" ]]
	    then
		printf "${RED}ERROR: incorrect combination: $from -- $to${CLEAR}\n"
		usage 1
	    fi
	  else
	    printf "${RED}ERROR; incorrect combination: $from -- $to${CLEAR}\n"
	    usage 1
	  fi
    fi

    ## everything checks out; now process the files
    for file in "${rcfiles[@]}"
    do
	  printf "Considering ${GREEN}$file... ${CLEAR}"

	  case $file in
	      ,*etc?profile)   comp $file $TEMPLATES/rc/etc/${COMP}/profile   ;;
	      ,*etc?bashrc)    comp $file $TEMPLATES/rc/etc/${COMP}/bashrc    ;;
	      ,*etc?tmux.conf) comp $file $TEMPLATES/rc/etc/${COMP}/tmux.conf ;;
	      ,*bash_profile)  comp $file $TEMPLATES/rc/${COMP}/bash_profile  ;;
	      ,*bashrc)	       comp $file $TEMPLATES/rc/${COMP}/bashrc	      ;;
	      ,*tmux?conf)     comp $file $TEMPLATES/rc/${COMP}/tmux.conf     ;;
	  esac
    done
#+end_src

** Boot Template
:PROPERTIES:
:dependency1: EMACS:=:/Applications/MacPorts/Emacs.app/Contents/MacOS/Emacs or similar
:dependency2: EDITOR:=:emacsclient
:dependency3: =SYNC_ORG_TEMPLATE= defined as $DEV/Templates/Org/Template.org
:END:
Although running the command ~org-babel-tangle~ (=C-c C-v t=) from within Emacs
will install  everything, it would  be nice to have  a simple Makefile  that is
downloaded with this  file that could be  invoked to do the  same thing without
starting Emacs and Org-mode and keying in the ~org-babel-tangle~ command.  This
little Makefile should be stored on  GitHub along with the ~Template.org~ file.
When  the source  is extracted  to a  directory, then  running this  Makefile's
default rule  as simply ~make~  will extract the ~preprocess.el~  script, which
updates  =DEV= and  then  extracts the  full Makefile.   Because  this file  is
tangled along with the full Makefile, it simply gets tacked onto the end of the
big Makefile as an additional rule.   Now, running ~make~ runs the default rule
from the  main Makefile, which is  to extract everything, then  export to TEXI,
INFO, HTML, and PDF forms.

It is assumed that an Emacs server is running, and that the $EDITOR environment
variable is set to use ~emacsclient~.

#+name:boot-template
#+header: :tangle Makefile
#+begin_src makefile
boot:
	$(EDITOR) -u --eval \
		"(with-current-buffer (car (find-file-noselect \"./*.org\" nil nil t)) \
                        (save-excursion \
			(goto-char (point-min)) \
			(re-search-forward \"^#[+]name:preprocess.el$$\") \
			(org-babel-tangle (quote (4))) \
                        (save-buffer)))"
	./tools/preprocess.el
#+end_src

** Preprocess Env Vars
The environment variable DEV can be in different locations and will be spelled
differently based on how the local machine is set up.  For instance, on one
system, it will be at ~$HOME/Dev~ while in another system it will be at
~/usr/local/dev~.  However, the =:tangle= keyword does not expand variables in
the form ~${DEV}~, but rather requires absolute paths, like ~/usr/local/dev~.
Therefore, this program works like a preprocessor for environment variables set
up as part of =:tangle= lines, changing them to their system environment
variable values prior to tangling.  It lives in the ~tools~ directory.

#+name:preprocess.el
#+header: :mkdirp t
#+header: :tangle tools/preprocess.el
#+header: :shebang "#!/opt/local/bin/emacs --script"
#+begin_src emacs-lisp
  (with-current-buffer (car (find-file-noselect "./*.org" nil nil t))
    (save-excursion
    (goto-char (point-min))
    (let ((re-search-str "\\(?::tangle\\|load-file \\(?:[\\]*\\)?[\"]\\)\s*\\(.*?/[dD]ev\\)/")
          (dev (getenv "DEV")))
      (while
              (re-search-forward re-search-str nil t)
              (replace-match dev t nil nil 1)))
    (save-buffer)
    (require 'org)
    (org-babel-tangle)))
#+end_src

* Macro Definitions
#+macro: heading @@texinfo:@heading @@$1
#+macro: subheading @@texinfo:@subheading @@$1
#+macro: dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+macro: noindent @@texinfo:@noindent @@
#+macro: option @@texinfo:@option{@@$1@@texinfo:}@@

* Export Setup                                                     :noexport:
#+texinfo_filename:mastering_emacs.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Emacs
#+texinfo_dir_title:Mastering
#+texinfo_dir_desc:notes about mastering Emacs
#+texinfo_printed_title:Mastering Emacs

* Options
#+options: H:4 toc:nil

* Local Variables                                                  :noexport:
# Local variables:
# fill-column: 79
# eval: (electric-quote-local-mode)
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
