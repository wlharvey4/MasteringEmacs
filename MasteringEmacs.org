# -*- mode: org; -*-

#+title:Mastering Emacs---Notes and Outline
#+subtitle:{{{version}}} {{{date}}}
#+author:Pinecone062
#+date:2022-01-20 08:19
#+macro:version Version 0.0.201
#+macro:upload-date (eval (current-time-string))
#+bucket:pinecone-forest.com

/{{{title}}}/ {{{version}}} compiled {{{date}}}

#+texinfo:@insertcopying

#+begin_smallquotation
Emacs outshines all other editing software in approximately the same
way that the noonday sun does the stars. It is not just bigger and
brighter; it simply makes everything else vanish.
#+texinfo:@author Neal Stephenson, "In the Beginning was the Command Line"
#+end_smallquotation

- [[https://www.gnu.org/software/emacs/][Gnu Emacs Home]]

- [[http://git.savannah.gnu.org/cgit/emacs.git][Emacs Source Repository]]

- [[https://www.masteringemacs.org/][Mastering Emacs]]

- [[https://www.gnu.org/software/emacs/manual/][Emacs Online Reference Manual]]

- [[https://www.gnu.org/software/emacs/manual/elisp.html][Emacs Online Lisp Reference Manual]]

- [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf][Emacs Reference Card]]

- [[https://www.gnu.org/software/emacs/refcards/pdf/survival.pdf][Emacs Survival Card]]



* Overview
** In The Beginning
   + [[http://project.cyberpunk.ru/lib/in_the_beginning_was_the_command_line/][In the Beginning was the Command Line]]
   + Emacs began in 1976 https://www.gnu.org/software/emacs/manual/html_node/efaq/Origin-of-the-term-Emacs.html#Origin-of-the-term-Emacs

   + Came from an editor called Teco

#+attr_texinfo: :author Andy Wingo, http://wingolog.org/archives/2009/01/07/a-brief-history-of-guile
#+attr_texinfo: :tag From “A Brief History of Guile”
#+begin_quote
Emacs, when it was first created in its GNU form in 1984, was a new take on the
problem of “how to make a program”.  The Emacs thesis is that it is delightful
to create composite programs based on an orthogonal kernel written in a
low-level language together with a powerful, high-level extension language.
#+end_quote

** Some Implementations
:CP:
#+CINDEX: xemacs
#+CINDEX: sxemacs
:END:
   + XEmacs fork
     - [[http://www.xemacs.org]]
     - [[https://www.jwz.org/doc/lemacs.html]]
   + SXEmacs fork of XEmacs
     - [[http://www.sxemacs.org]]
   + and Gnu Emacs
     - [[https://www.gnu.org/software/emacs/]]
** Starter Packages
:CP:
#+CINDEX: starter packages
#+CINDEX: packages, starter
:END:
*** Emacs Wiki Starter Kits List

+ https://www.emacswiki.org/emacs/StarterKits
+ http://wikemacs.org/wiki/Starter_Kits

*** Phil Hagelberg “Technomancy”’s emacs-starter-kit and better-defaults

“Because the Emacs defaults are not so great sometimes.”

+ https://github.com/technomancy/emacs-starter-kit

+ https://github.com/technomancy/better-defaults

*** Eric Schulte’s Emacs Starter Kit

+ https://eschulte.github.io/emacs-starter-kit/
+ http://eschulte.github.io/emacs24-starter-kit/

*** Steve Purcell’s .emacs.d
:CP:
#+CINDEX:Steve Purcell @code{.emacs.d}
#+CINDEX:Purcell, Steve
:END:

[[https://www.youtube.com/watch?v=Gq0hG_om9xY][Steve Purcell interview by Sacha Chua]]

Steve Purcell's ~emacs~ config file is not meant to be a ``starter'' file, but
is famous in the community.  Purcell does not maintain it as a starter file,
but only for his own purposes.  He knows that it is forked and circulated, and
so allows it to be used for educational purposes I suppose.  He is a (the?)
maintainer of MELPA, and has written and reviewed a lot of elisp code.

“An Emacs configuration bundle with batteries included”

+ [[https://github.com/purcell/emacs.d]]

*** Bozhidar Batzov’s Prelude
:CP:
#+CINDEX: Batzov Prelude
#+CINDEX: Prelude from Batzov
:END:
    + [[https://github.com/bbatsov/prelude]]

*** Awesome Emacs
:CP:
#+CINDEX: Awesome Emacs
:END:
    + [[https://github.com/emacs-tw/awesome-emacs]]

*** Doom Emacs

“An Emacs configuration for the stubborn martian vimmer”

#+begin_quote
Doom is a configuration framework for GNU Emacs tailored for Emacs bankruptcy
veterans who want less framework in their frameworks and the performance of a
hand rolled config (or better). It can be a foundation for your own config or a
resource for Emacs enthusiasts to learn more about our favorite OS.
#+end_quote

#+cindex:doom-emacs
+ https://github.com/hlissner/doom-emacs

*** Xah Emacs List of Starter Kits

+ http://ergoemacs.org/misc/list_of_emacs_starter_kits.html

*** An Emacs Starter Kit for the Social Sciences

- https://kieranhealy.org/resources/emacs-starter-kit/

*** Emacs Starter Kits

- https://riptutorial.com/emacs/topic/1960/starter-kits

** Lisp
*** eLisp Introduction
    + [[https://www.gnu.org/software/emacs/manual/eintr.html]]
:CP:
#+CINDEX: elisp
:END:
** Emacs as OS
*** C Core
When you run Emacs you are in fact  launching a tiny C core responsible for the
low-level interactions with your operating system’s ABI.  That includes mundane
things like  file-system and network  access; drawing  things to the  screen or
printing control codes to the terminal.
*** Elisp Interpreter
:CP:
#+CINDEX: elisp interpreter
#+CINDEX: ui thread
#+CINDEX: uptime
#+CINDEX: @code{M-x emacs-uptime}
:END:
The cornerstone of Emacs though is the elisp interpreter — without it, there is
no Emacs; speed  and asynchrony are the two main  issues.  The interpreter runs
in a single thread  and intensive tasks will lock the UI  thread. But there are
workarounds.

When  you write  elisp you  are not  just  writing snippets  of code  run in  a
sandbox,  isolated from  everything  — you  are altering  a  living system;  an
operating system running on an operating  system.  Every variable you alter and
every function  you call is  carried out by the  very same interpreter  you use
when you edit text.

Emacs  is  a hacker’s  dream  because  it is  one  giant,  mutable state.   Its
simplicity is  both a blessing and  a curse. You can  re-define live functions;
change variables left and right; and you  can query the system for its state at
any time — state that changes with every key stroke as Emacs responds to events
from your keyboard to your network  stack. Emacs is self-documenting because it
is the document. There  are no other editors that can do  that. No editor comes
close.

And yet Emacs never  crashes — not really, anyway. Emacs  has an uptime counter
to prove  that it doesn’t  (~M-x emacs-uptime~)  — multi-month uptimes  are not
uncommon.

So when you ask Emacs a question – as I will show you how to do later – you are
asking your Emacs  what its state is.  Because of this, Emacs  has an excellent
elisp debugger and un-limited access to  every facet of Emacs’s own interpreter
and state — so  it has excellent code completion too. Any  time you encounter a
lisp expression  you can tell  Emacs to evaluate it,  and it will:  from adding
numbers to setting variables to downloading packages.
*** Concepts
**** Buffer
:CP:
#+CINDEX: buffer
:END:
In Emacs, all files are buffers, but not all buffers are files.

Emacs uses these buffers for more than  just editing text. It can also act like
an I/O device  and talk to another process,  such as a shell like  bash or even
Python.

Almost all of Emacs’s own commands act  on buffers.  So when you tell Emacs to,
for example, search & replace it will actually search and replace on a buffer –
maybe the active  buffer you’re writing in, or perhaps  a temporary duplicate –
and not an internal data structure like you might think.

In Emacs, the buffer is the /data structure/.

This is an extremely powerful concept because the very same commands you use to
move  around  and edit  in  Emacs  are almost  always  the  same ones  you  use
behind-the-scenes in elisp. So once you memorize Emacs’s own user commands, you
can use them in a simple function call to mimic what you’d do by hand.
**** Windows and Frames
:CP:
#+CINDEX: windows
#+CINDEX: frames
:END:
The /frame/ is the window and the /window/  is the frame.  That is, a frame has
at least one  window, but can have  multiple windows, and each  window can have
one /buffer/.  That is, a /buffer/ must  be viewed in a /window/, which must be
in a /frame/.  A /frame/ is made up of /window/ panes.

You are  free to create as  many frames as you  like, and to tile  up the frame
into as many windows  as you like.  This allows you to  see multiple buffers on
the screen at one time.
**** Modeline Echo Area Minibuffer
:CP:
#+CINDEX: modeline
#+CINDEX: minibuffer
#+CINDEX: echo area
:END:
Emacs uses the /modeline/ to communicate facts about Emacs and the buffer you
are in.  This is equivalent to a /status bar/.  Many different kinds of
information can be displayed in the modeline.

The /minibuffer/ is below the modeline.  This is where errors and general
information is displayed.  It is nearly identical to a normal buffer; the
one-line minibuffer will expand to multiple lines if necessary.  It is how you
communicate with Emacs.

The /echo area/ and the /minibuffer/ share the same spot on the screen.
**** Point and Mark
:CP:
#+CINDEX: point
#+CINDEX: mark
#+CINDEX: region
#+CINDEX: transient mark mode
:END:
/Point/ is  your current cursor position  in a buffer.  Each  buffer tracks its
own point separately,  so each buffer has a different  position for point.  The
``current buffer'' is  that buffer which currently ``has the  point.''  This is
the buffer that you can write and move  around in.  Only one buffer can ever be
the ``current buffer'' at any one time.

The point  is one part of  a duo called /point  and mark/.  The point  and mark
represent the boundaries of a /region/, which is a contiguous block of text.
Emacs can show you the region.  This is called /transient mark mode/.

The mark saves a location for the user’s convenience. Most editing commands
should not alter the mark.

To remember a location for internal use in the Lisp program, store it in a Lisp
variable. Example:

: (let ((beg (point))) (forward-line 1) (delete-region beg (point))).

- set-mark POS ::

  Set this buffer’s MARK to POS. The user will see that the MARK has moved, and
  the previous MARK position will be lost. Normally, when a new mark is set,
  the old one should go on the stack. This is why most applications should use
  ‘push-mark’, not ‘set-mark’.

- push-mark &optional LOCATION NOMSG ACTIVATE ::

  Set mark at LOCATION (point, by default) and push old mark on mark ring.
  Display ‘Mark set’ unless the optional second arg NOMSG is non-nil. In
  Transient Mark mode, activate mark if optional third arg ACTIVATE non-nil.

***** Global Mark Ring
#+cindex:global mark ring
#+cindex:mark ring, global
#+cindex:ring, global mark
In addition to the ordinary mark ring  that belongs to each buffer, Emacs has a
single *global mark ring*.

Each time you set a mark, this is  recorded in the global mark ring in addition
to the current buffer’s  own mark ring, if you have  switched buffers since the
previous  mark setting.  Hence,  the global  mark ring  records  a sequence  of
buffers that you have been in, and, for  each buffer, a place where you set the
mark.

- =C-x C-SPC= -- ~pop-global-mark~ ::

  Jumps to the buffer  and position of the latest entry in  the global ring. It
  also rotates  the ring,  so that  successive uses  of C-x  C-SPC take  you to
  earlier buffers and mark positions.

#+attr_texinfo: :options pop-global-mark
#+begin_defun
  Pop off global mark ring and jump to the top location.
#+end_defun

#+attr_texinfo: :options global-mark-ring-max
#+begin_defvar
  Maximum size of  global mark ring. Default value is  16. Start discarding off
  end if gets this big.
#+end_defvar

**** Killing Yanking and CUA
/Killing/ is cutting, /yanking/ is pasting, and copying is known as /saving to
the kill ring/.
**** Init Files
     + ~.emacs.d~
     + ~init.el~
     + ~.emacs~
**** Modes
Major modes in Emacs control how  buffers behave.  Each buffer will always have
a major  mode.  You are  free to change  a buffer’s major  mode at any  time by
typing the command for another one.  Each buffer can have just one major mode.

Minor modes, by contrast, are typically optional add-ons that you enable for
some (or all) of your buffers.

The major mode is  always displayed in the modeline. Some  minor modes are also
displayed in the modeline,  but usually only the ones that  alter the buffer or
how you interact with it in some way.

* Introduction
From the blog /Mastering Emacs/.  Check out the [[https://www.masteringemacs.org/all-articles][index of articles]].
See also the [[https://www.masteringemacs.org/reading-guide][Reading Guide]].

* Help
- =C-h ...= :: Prefix for all things helpish.

- =C-h a= :: [[*apropos-command][~apropos-command~]] search for commands (interactive functions);
  with a prefix argument, search for non-interactive functions also.

- =M-x apropos= :: search for functions and variables

- =C-h d= :: [[*apropos-documentation][~apropos-documentation~]]

#+attr_texinfo: :options apropos-documentation pattern [do-all]
#+begin_defun
Show symbols whose documentation contains matches for PATTERN.

- PATTERN ::
  - word; search for matches for that word as a substring;
  - list of words separated by spaces; search for matches for any two or more
    of thos words;
  - regexp;

- ~internal-doc-file-name~ :: =<emacs-path>/etc/DOC=
  By default this command only searches in the file specified by this variable.
  When invoked with a =C-u= prefix, or if the variable ~apropos-do-all~ is
  non-nil, it searches ALL currently defined documentation strings.
#+end_defun

- =C-h f= :: [[*describe-function][~describe-function~]]

- =C-h v= :: [[*describe-variable][~describe-variable~]]

- =C-h o= :: [[*describe-symbol][~describe-symbol~]]

- =C-h F= :: [[*Info-goto-emacs-command-node][~Info-goto-emacs-command-node~]]

- =C-h i= :: ~info~

** Help Mode

Help buffers provide the same commands as View mode.  A few special commands
are also provided:

- <RET> ~help-follow~ :: follow a cross-reference at point

- <TAB> ~forward-button~ :: move point forward to the next hyperlink

- S-<TAB> ~backward-button~ :: move point back to the previous hyperlink

- =C-c C-c= ~help-follow-symbol~ :: show all documentation about the symbol at
  point

- =C-c C-f=  ~help-go-forward~ ::
- r :: go forward to the next help topic

- =C-c C-b= ~help-go-back~ ::
- l :: got back to the previous help topic

** Apropos

By default, all ~apropos~ command except ~apropos-documentation~ list their
results in alphabetical order.  See [[apropos-sort-by-scores][~apropos-sort-by-scores~]] to change.

Following the conventions for naming Emacs commands, here are some words that
you’ll find useful in apropos patterns.  By using them in ‘C-h a’, you will
also get a feel for the naming conventions.

#+begin_example
char, line, word, sentence, paragraph, region, page, sexp, list,
defun, rect, buffer, frame, window, face, file, dir, register,
mode, beginning, end, forward, backward, next, previous, up, down,
search, goto, kill, delete, mark, insert, yank, fill, indent, case,
change, set, what, list, find, view, describe, default.
#+end_example

*** apropos

  #+attr_texinfo: :options apropos pattern &optional do-all
  #+begin_defun
  [[help:apropos][apropos.el]]

  Find all meaningful Lisp symbols whose names contain a match for the apropos
  pattern =PATTERN=.

  - =PATTERN= is either ::
    - a word to match; if a word, search for matches of that word as a
      substring;
    - a space-separated list of words of which at least two must match
    - a regular expression

  - =DO-ALL= ::
    if non-nil, or if the user option ‘apropos-do-all’ is non-‘nil’, then
    ~apropos~ also shows key bindings for the functions that are found.

  - RETURN ::
    The function returns a list of elements that look like this:

    #+begin_example
    (SYMBOL SCORE FUNCTION-DOC VARIABLE-DOC
     PLIST-DOC WIDGET-DOC FACE-DOC GROUP-DOC)
    #+end_example

    - SCORE ::
      an integer measure of how important the symbol seems to be as a match

    - REST ::
      Each of the remaining elements is a documentation string, or ‘nil’, for
      SYMBOL as a function, variable, etc.

    - =*apropos*= buffer ::
      It also displays the symbols in a buffer named ‘*Apropos*’, each with a
      one-line description taken from the beginning of its documentation
      string.
  #+end_defun

*** apropos-command

- =[C-u] C-h a=


  #+attr_texinfo: :options apropos-command pattern &optional do-all var-predicate
  #+begin_defun
  Interactive; show commands (interactively callable functions) that match
  PATTERN.

  - =PATTERN= ::
    - word; search for matches for that word as a substring;
    - list of words; search for matches for any two or more of those words;
    - regexp

  - =DO-ALL= :: =C-u= prefix, or ~apropos-do-all~ is non-nil, also show
    noninteractive functions.

  - =VAR-PREDICATE= :: when non-nil, show only variables, and only those that
    satisfy the predicate =VAR-PREDICATE=.
  #+end_defun

*** apropos-documentation

- =C-h d=


#+attr_texinfo: :options apropos-documentation pattern &optional do-all
#+begin_defun
Show symbols whose documentation contains matches for PATTERN.  This function
lists its results in order of relevance by default.  To list them in
alphabetical order, change ~apropos-documentation-sort-by-scores~ to nil.

- PATTERN ::

  =PATTERN= can be a word, a list of words (separated by spaces), or a regexp
  (using some regexp special characters).  If it is a word, search for matches
  for that word as a substring.  If it is a list of words, search for matches
  for any two (or more) of those words.
#+end_defun

Note that by default this command only searches in the file specified by
‘internal-doc-file-name’; i.e., the etc/DOC file.  With C-u prefix, or if
‘apropos-do-all’ is non-nil, it searches all currently defined documentation
strings.

*** apropos variables

- ~apropos-do-all~ :: if non-nil, most apropos commands behave as if they had
  been given the prefix argument.

- ~apropos-sort-by-scores~ <<apropos-sort-by-scores>> :: if non-nil, ~apropos~
  command try to guess the relevance of each result, and display the most
  relevant ones first.

- =M-x apropos-user-option= :: search for user-customizable variables; with a
  prefix argument, search for non-customizable variables too.

- =M-x apropos-variable= :: search for (all) variables; with a prefix argument,
  search for customizable variables also.  This ignores the ~apropos-do-all~
  variable.

- =M-x apropos-local-variable= :: search for buffer-local variables

- =M-x apropos-local-value= :: search for buffer-local variables whose values
  match the specified pattern

** Info

- ~info~ =C-h i= ::

  #+findex:info
  #+attr_texinfo: :options info &optional file-or-node buffer
  #+begin_defun
  Enter =Info=, opening the top-level ~dir~ file or FILE-OR-NODE if given.

  In interactive use, a non-numeric prefix argument directs this command to
  read a file name from the minibuffer.  A numeric prefix argument N selects
  ~*info<N>~.
  #+end_defun

  runs the command ~info~.  Enter =Info=, the documentation browser.  Optional
  argument FILE-OR-NODE specifies the file to examine.  The default is the
  top-level directory of Info.  When called from a program, this argument may
  specify an Info node of the form:
  : (FILENAME)NODENAME

  #+vindex:Info-directory-list
  #+attr_texinfo: :options Info-directory-list
  #+begin_defvar
  The search path for Info files.  The top-level Info directory is made by
  combining all the files nmaed ~dir~ in all the directories in this path.
  #+end_defvar

  #+vindex:Info-default-directory-list
  #+attr_texinfo: :options Info-default-directory-list
  #+begin_defvar
  Default list of directories to search for Info documentation files. They are
  searched in the order they are given in the list. This variable
  ‘Info-default-directory-list’ is used as the default for initializing
  ‘Info-directory-list’ when Info is started, unless the environment variable
  INFOPATH is set. Normally, you should either set INFOPATH or customize
  ‘Info-additional-directory-list’, rather than changing this variable.
  #+end_defvar

  #+attr_texinfo: :options Info-additional-directory-list
  #+begin_defvar
  List of additional directories to search for Info documentation files. These
  directories are searched after those in ‘Info-directory-list’.
  #+end_defvar

** Describe
The ~describe-mode~ function provides information about major modes.

- ~describe-mode~ (=C-h m=)
- variable ~major-mode~

#+attr_texinfo: :options describe-mode &optional buffer
#+begin_defun
  This command  displays the documentation  of the current buffer’s  major mode
  and  minor  modes.  It  uses  the  documentation  function  to  retrieve  the
  documentation strings of the major and minor mode commands.

  If called from Lisp with a non-=nil= =BUFFER= argument, display documentation
  for the major and minor modes of that buffer.
#+end_defun

** Documentation
#+cindex:documentation strings
#+cindex:help facilities
GNU Emacs has  convenient built-in help facilities, most of  which derive their
information  from   *documentation  strings*  associated  with   functions  and
variables. This chapter describes how to access *documentation strings* in Lisp
programs.  Documentation  strings  are  specified in  the  definitions  of  the
functions and variables they apply to.

This section also describes =ElDoc= mode, and some help commands:

- ~Info-goto-emacs-command-mode~
- ~documentation-property~
- ~documentation~
- ~describe-function~
- ~describe-variable~
- ~describe-symbol~

*** Writing Documentation Strings

- The command ~checkdoc-minor-mode~

#+attr_texinfo: :options checkdoc-minor-mode &optional arg
#+begin_defun
  Toggle automatic docstring checking (=Checkdoc= minor mode).

  If called interactively, toggle ‘Checkdoc minor mode’. If the prefix argument
  is positive,  enable the  mode, and if  it is zero  or negative,  disable the
  mode.

  If called from Lisp,  toggle the mode if ARG is ‘toggle’.  Enable the mode if
  ARG is nil,  omitted, or is a positive  number. Disable the mode if  ARG is a
  negative number.

  The  mode’s hook  is called  both when  the mode  is enabled  and when  it is
  disabled.
#+end_defun

- The variable ~emacs-lisp-docstring-fill-column~

  - A documentation string  is written using the Lisp syntax  for strings, with
    double-quote characters surrounding the text.

  - Every  command, function,  or variable  intended  for users  to know  about
    should have a documentation string.

  - An internal variable or  subroutine of a Lisp program might  as well have a
    documentation string. Documentation strings take  up very little space in a
    running Emacs.

  - Format the documentation  string so that it  fits in an Emacs  window on an
    80-column screen. It is  a good idea for most lines to be  no wider than 60
    characters. The  first line should  not be wider  than 67 characters  or it
    will look bad in the output of ~apropos~.

    You  can  fill  the  text  if  that  looks  good.  Emacs  Lisp  mode  fills
    documentation      strings     to      the      width     specified      by
    ~emacs-lisp-docstring-fill-column~.  However,  you  can  sometimes  make  a
    documentation string much  more readable by adjusting its  line breaks with
    care. Use blank lines between sections if the documentation string is long.

  - The first  line of the  documentation string should  consist of one  or two
    complete sentences  that stand  on their  own as  a summary.  ~M-x apropos~
    displays just  the first line, and  if that line’s contents  don’t stand on
    their own, the result looks bad. In particular, start the first line with a
    capital letter and end it with a period.

    For a  function, the first line  should briefly answer the  question, “What
    does  this function  do?” For  a variable,  the first  line should  briefly
    answer the question, “What does this value mean?”

    Don’t limit the documentation string to one  line; use as many lines as you
    need to explain the details of how  to use the function or variable. Please
    use complete sentences for the rest of the text too.

  - The first line should mention all  the important arguments of the function,
    and should mention  them in the order  that they are written  in a function
    call.  If the  function has  many  arguments, then  it is  not feasible  to
    mention them  all in the  first line; in that  case, the first  line should
    mention the first few arguments, including the most important arguments.

  - When a function’s documentation string  mentions the *value* of an argument
    of the function, use  the argument name in capital letters as  if it were a
    name  for that  *value*. Thus,  the  documentation string  of the  function
    ~eval~ refers to its first argument  as ‘FORM’, because the actual argument
    name is ~form~.

    Also write  metasyntactic variables  in capital letters,  such as  when you
    show the decomposition of a list or vector into subunits, some of which may
    vary; e.g. ‘KEY’ and ‘VALUE’.

  - Never change  the case  of a  Lisp *symbol* when  you mention  it in  a doc
    string. If the symbol’s  name is ~foo~, write “foo”, not  “Foo” (which is a
    different symbol).

    This might  appear to  contradict the policy  of writing  function argument
    values, but there is no real contradiction; the argument *value* is not the
    same thing as the  *symbol* that the function uses to  hold the *value*.

    If this puts  a lower-case letter at  the beginning of a  sentence and that
    annoys you, rewrite the sentence so that  the symbol is not at the start of
    it.

  - *Do not* start or end a documentation string with whitespace.

  - *Do not* indent subsequent lines of a documentation string so that the text
    is lined up in the source code with  the text of the first line. This looks
    nice  in  the   source  code,  but  looks  bizarre  when   users  view  the
    documentation.   Remember  that   the  indentation   before  the   starting
    double-quote is not part of the string!

  - When a documentation string refers to a Lisp *symbol*, write it as it would
    be printed (which usually means in  lower case), surrounding it with curved
    single quotes  (‘..’). There are  two exceptions:  write t and  nil without
    surrounding punctuation.

    Documentation  strings can  also  use an  older single-quoting  convention,
    which  quotes  symbols  with  =grave=  accent  =`=  and  =apostrophe=  ='=:
    `like-this' rather than ‘like-this’. This older convention was designed for
    now-obsolete  displays in  which grave  accent and  apostrophe were  mirror
    images.  Documentation using  this convention  is converted  to the  user’s
    preferred format when it is copied into a help buffer.

    Help mode  automatically creates  a hyperlink  when a  documentation string
    uses a *single-quoted* symbol name, if  the symbol has either a function or
    a variable definition. You  do not need to do anything  special to make use
    of this  feature. However, when a  symbol has *both* a  function definition
    and a variable definition,  and you want to refer to just  one of them, you
    can specify  which one by  writing one  of the words  ‘variable’, ‘option’,
    ‘function’, or ‘command’,  immediately before the symbol  name. (Case makes
    no difference in recognizing these indicator words.)

    For example, if you write:
    : This function sets the variable `buffer-file-name'.
    then  the  hyperlink will  refer  only  to  the variable  documentation  of
    buffer-file-name, and not to its function documentation.

    If a  symbol has a  function definition  and/or a variable  definition, but
    those are irrelevant to the use of the symbol that you are documenting, you
    can write the words ‘symbol’ or ‘program’ before the symbol name to prevent
    making any hyperlink. For example,
    : If the argument KIND-OF-RESULT is the symbol `list',
    : this function returns a list of all the objects
    : that satisfy the criterion.
    does not  make a hyperlink  to the  documentation, irrelevant here,  of the
    function list.

    Normally,  no   hyperlink  is   made  for   a  variable   without  variable
    documentation. You  can force a  hyperlink for such variables  by preceding
    them with one of the words ‘variable’ or ‘option’.

    To make a hyperlink to Info  documentation, write the single-quoted name of
    the Info  node (or  anchor), preceded  by ‘info  node’, ‘Info  node’, ‘info
    anchor’  or ‘Info  anchor’. The  Info file  name defaults  to ‘emacs’.  For
    example,
    : See Info node `Font Lock' and Info node `(elisp)Font Lock Basics'.

    Finally,  to create  a  hyperlink  to URLs,  write  the single-quoted  URL,
    preceded by ‘URL’. For example,
    : The home page for the GNU project has more information (see URL
    : `https://www.gnu.org/').

  - Don’t write key  sequences directly in documentation  strings. Instead, use
    the ‘\\[…]’ construct to stand for them.

    For   example,   instead   of    writing   ‘C-f’,   write   the   construct
    ‘\\[forward-char]’.

  - In documentation strings  for a major mode,  you will want to  refer to the
    key bindings of that mode’s local  map, rather than global ones. Therefore,
    use the construct ‘\\<…>’ once in the documentation string to specify which
    key map to  use. Do this before  the first use of ‘\\[…]’.  The text inside
    the ‘\\<…>’ should be the name  of the variable containing the local keymap
    for the major mode.

    It is not practical to use ‘\\[…]’  very many times, because display of the
    documentation string  will become slow.  So use  this to describe  the most
    important commands in your major mode,  and then use ‘\\{…}’ to display the
    rest of the mode’s keymap.

  - For consistency,  phrase the  verb in  the first  sentence of  a function’s
    documentation string as an imperative—for instance, use “Return the cons of
    A and B.” in preference to “Returns the  cons of A and B.” Usually it looks
    good  to do  likewise  for  the rest  of  the  first paragraph.  Subsequent
    paragraphs usually  look better if  each sentence  is indicative and  has a
    proper subject.

  - The  documentation string  for a  function  that is  a yes-or-no  predicate
    should start with words such as  “Return t if”, to indicate explicitly what
    constitutes  truth. The  word “return”  avoids starting  the sentence  with
    lower-case “t”, which could be somewhat distracting.

  - Write documentation  strings in the active  voice, not the passive,  and in
    the  present tense,  not  the  future. For  instance,  use  “Return a  list
    containing  A and  B.”  instead of  “A  list  containing A  and  B will  be
    returned.”

  - When you  define a variable that  represents an option users  might want to
    set, use ~defcustom~.

  - The documentation  string for a  variable that  is a yes-or-no  flag should
    start with words such as “Non-nil means”, to make it clear that all non-nil
    values are equivalent and indicate explicitly what nil and non-nil mean.

**** Text Quoting Style

- User option ~text-quoting-style~

The value of this user option is a symbol that specifies the style Emacs should
use for single quotes in the wording of help and messages.

  - =curve= :: If  the option’s value is  curve, the style is  ‘like this’ with
    curved single quotes.

  - =straight=  :: If  the value  is straight,  the style  is 'like  this' with
    straight apostrophes.

  - =grave= :: If the  value is grave, quotes are not  translated and the style
    is `like this' with grave accent  and apostrophe, the standard style before
    Emacs version 25.

  - nil :: The default  value nil acts like curve if  curved single quotes seem
    to be displayable, and like grave otherwise.

#+attr_texinfo: :options {User option} text-quoting-style
#+begin_defvr
  Style to use  for single quotes in  help and messages. Its value  should be a
  symbol.

  It  works  by  substituting  certain  single  quotes  for  grave  accent  and
  apostrophe. This is done in help output (but not for display of Info manuals)
  and  in functions  like ‘message’  and ‘format-message’.  It is  not done  in
  ‘format’.
#+end_defvr

*** Emacs ~documentation-property~ Command

- The commnand ~documentation-property~
#+vindex:doc-directory
#+vindex:DOC
#+cindex:function-documentation property
#+cindex:variable-documentation property

#+attr_texinfo: :options documentation-property symbol property &optional verbatim
#+begin_defun
  This  function returns  the *documentation  string* recorded  in =SYMBOL=  's
  property list under property =PROPERTY=. It is most often used to look up the
  *documentation strings* of variables.

  This  differs from  ~get~ in  that  it can  refer  to strings  stored in  the
  ‘etc/DOC’ file;  and that it  evaluates documentation properties  that aren’t
  strings.

  For function documentation, use the ~documentation~ function.
#+end_defun

  - In a /function definition/ (a ~lambda~ or ~defun~ form), the *documentation
    string*  is specified  after  the  argument list,  and  is normally  stored
    directly in the function object.

  - You can  also put  /function documentation/ in  the /function-documentation
    property/ of a function name.

  - In a /variable definition/ (a ~defvar~ form), the *documentation string* is
    specified after the  initial value. The string is stored  in the variable’s
    /variable-documentation property/.

  - To save  memory, the  documentation for  preloaded functions  and variables
    (including primitives)  is kept  in a  file named  ~DOC~, in  the directory
    specified by ~doc-directory~.

    : "/Applications/MacPorts/Emacs.app/Contents/Resources/etc/DOC"

*** ElDoc Mode

- =M-x eldoc-mode=

ElDoc mode is a buffer-local minor mode that helps with looking up Lisp
documentation.  When enabled, the echo area displays information about a
function or variable in the text where point is.  If point is on a documented
variable, it displays the first line of that variable’s doc string.  Otherwise
it displays the argument list of the function called in the expression point is
on.

*** Emacs ~Info-goto-emacs-command-node~ Command

- The command ~Info-goto-emacs-command-node~

#+attr_texinfo: :options Info-goto-emacs-command-node command
#+begin_defun
  Go to the Info node in the Emacs manual for command COMMAND.

  The command is found by:

  - looking up in Emacs manual’s indices or
  - in another manual found via COMMAND’s =info-file= property or
  - the variable ~Info-file-list-for-emacs~
#+end_defun

*** The ~documentation~ Command

- The command ~documentation~

#+attr_texinfo: :options documentation function &optional verbatim
#+begin_defun
  This function  returns the *documentation  string* of =FUNCTION=.  It handles
  macros,  named  keyboard macros,  and  special  forms,  as well  as  ordinary
  functions.

  If   =FUNCTION=  is   a   symbol,   this  function   first   looks  for   the
  =function-documentation=  property of  that  symbol; if  that  has a  non-nil
  value, the documentation comes from that value (if the value is not a string,
  it is evaluated).

  If  =FUNCTION= is  not a  symbol, or  if it  has no  =function-documentation=
  property,  then documentation  extracts the  *documentation string*  from the
  actual function definition, reading it from a file if called for.
#+end_defun

*** documentation example

See [[info:elisp#Accessing Documentation][Access to Documentation Strings]] for an example of using these functions in
ELisp code.

Here  is   an  example  of   using  the  two  functions,   ~documentation~  and
~documentation-property~, to  display the  *documentation strings*  for several
symbols in a *Help* buffer.

#+caption:Definition of @code{describe-symbols}
#+name:describe-symbols
#+begin_src elisp -n
  (defun describe-symbols (pattern)
    "Describe the Emacs Lisp symbols matching PATTERN.
  All symbols that have PATTERN in their name are described
  in the *Help* buffer."
    (interactive "sDescribe symbols matching: ")
    (let ((describe-func
	   (lambda (s)
	     ;; Print description of symbol.
	     (if (fboundp s)             ; It is a function.
		 (princ
		  (format "%s\t%s\n%s\n\n" s
		    (if (commandp s)
			(let ((keys (where-is-internal s)))
			  (if keys
			      (concat
			       "Keys: "
			       (mapconcat 'key-description
					  keys " "))
			    "Keys: none"))
		      "Function")
		    (or (documentation s)
			"not documented"))))

	     (if (boundp s)              ; It is a variable.
		 (princ
		  (format "%s\t%s\n%s\n\n" s
		    (if (custom-variable-p s)
			"Option " "Variable")
		    (or (documentation-property
			  s 'variable-documentation)
			"not documented"))))))
	  sym-list)

      ;; Build a list of symbols that match pattern.
      (mapatoms (lambda (sym)
		  (if (string-match pattern (symbol-name sym))
		      (setq sym-list (cons sym sym-list)))))

      ;; Display the data.
      (help-setup-xref (list 'describe-symbols pattern) (interactive-p))
      (with-help-window (help-buffer)
	(mapcar describe-func (sort sym-list 'string<)))))
#+end_src

*** describe-function

- ~describe-function~ (=C-h f=)

This is the only way to get the documentation of a command that is not bound to
any key. It  describes the function called by the  innermost Lisp expression in
the buffer around point.

#+attr_texinfo: :options describe-function function
#+begin_defun
  Display the full documentation of =FUNCTION=.

  - =FUNCTION= :: a symbol
#+end_defun

*** describe-variable

- ~describe-variable~ (=C-h v=)

#+attr_texinfo: :options describe-variable variable &optional buffer frame
#+begin_defun
  Display  the  full  documentation  of  =VARIABLE=  (a  symbol).  Returns  the
  documentation as a string, also.

  - =VARIABLE=  ::  a symbol; default to  using the current buffer  and current
    frame;

  - =BUFFER=  :: if  =VARIABLE= has  a buffer-local  value in  =BUFFER=, it  is
    displayed along with the global value.

  - =FRAME=  ::  if  =VARIABLE=  has a  buffer-local value  in  =FRAME=, it  is
    displayed along with the global value.
#+end_defun

*** describe-symbol

#+cindex:documentation, full
- The command ~describe-symbol~ (=C-h o=)

#+attr_texinfo: :options describe-symbol &optional buffer frame
#+begin_defun
  Display the full documentation of =SYMBOL=. Will show the info of =SYMBOL= as
  a function, variable, and/or face.

  - =SYMBOL= ::  the symbol to use;  default to the current buffer and selected
    frame.

  - =BUFFER= :: use =BUFFER=  to show the information about =SYMBOL=

  - =FRAME= :: use =FRAME= to show the information about =SYMBOL=
#+end_defun

*** Info-goto-emacs-command-node

#+attr_texinfo: :options Info-goto-emacs-command-node command
#+begin_defun
  Go to the =Info= node in the Emacs manual for command =COMMAND=.

  The command is  found by looking up  in Emacs manual’s indices  or in another
  manual   found  via   =COMMAND=’s  ‘info-file’   property  or   the  variable
  ~Info-file-list-for-emacs~.
#+end_defun

*** Bindings

- The command ~describe-bindings~ (=C-h b=)

#+attr_texinfo: :options describe-bindings &optional prefix buffer
#+begin_defun
  Display a buffer  showing a list of all defined  keys, and their definitions.
  The keys are displayed in order of precedence.

  - =PREFIX=  :: If  non-=nil=,  display  only bindings  that  start with  that
    prefix.

  - =BUFFER=  :: Specify  which buffer’s  bindings to  display (default  is the
    current buffer).  Can be a buffer or buffer name.
#+end_defun

*** Key Bindings in Documentation

When  *documentation strings*  refer  to  key sequences,  they  should use  the
current,  actual /key  bindings/. They  can do  so using  certain special  text
sequences described below.  Accessing *documentation strings* in  the usual way
substitutes current key binding information for these special sequences.

This works by calling ~substitute-command-keys~

#+attr_texinfo: :options substitute-command-keys string
#+begin_defun
  Substitute key descriptions for command names in =STRING=.

  - =\[COMMAND]= ::

    Each substring of  the form =\[COMMAND]= is replaced by  either a keystroke
    sequence that  invokes =COMMAND=, or =M-x  COMMAND= if =COMMAND= is  not on
    any keys.

  - =\{MAPVAR}= ::

    Each substring  of the  form =\{MAPVAR}=  is replaced by  a summary  of the
    value of =MAPVAR= as a keymap.

  - =\<MAPVAR>= ::

    Each substring of the form =\<MAPVAR>= specifies the use of =MAPVAR= as the
    keymap for future =\[COMMAND]= substrings.

  - grave accent =`= :: Each is replaced by left quote;

  - apostrophe ='= :: Each is replaced by right quote;

  - =\== :: quotes the following character and is discarded

  - *RETURN*   :: Returns  the original =STRING= if no  substitutions are made.
    Otherwise, return a new string (without any text properties).
#+end_defun

#+texinfo: @heading Examples of @code{substitute-command-keys}

#+begin_src elisp
  (substitute-command-keys
     "To abort recursive edit, type `\\[abort-recursive-edit]'.")

  ;; ⇒ "To abort recursive edit, type ‘C-]’."

  (substitute-command-keys
     "The keys that are defined for the minibuffer here are:
    \\{minibuffer-local-must-match-map}")

  ;; ⇒ "The keys that are defined for the minibuffer here are:

  ;; ?               minibuffer-completion-help
  ;; SPC             minibuffer-complete-word
  ;; TAB             minibuffer-complete
  ;; C-j             minibuffer-complete-and-exit
  ;; RET             minibuffer-complete-and-exit
  ;; C-g             abort-recursive-edit
  ;; "

  (substitute-command-keys
     "To abort a recursive edit from the minibuffer, type \
  `\\<minibuffer-local-must-match-map>\\[abort-recursive-edit]'.")

  ;; ⇒ "To abort a recursive edit from the minibuffer, type ‘C-g’."
#+end_src

** Doc and Data Directory

#+cindex:DOC
#+cindex:documentation, preloaded functions & variables
To  save  memory,  the  documentation for  preloaded  functions  and  variables
(including  primitives)  is kept  in  a  file  named  =DOC=, in  the  directory
specified by  ~doc-directory~. This  is usually  the same  as ~data-directory~.
This directory contains a lot of other useful information as well.

~doc-directory~ ’s value on your system is:

#+begin_src emacs-lisp :exports results
  (print doc-directory)
#+end_src

This directory contains the following files:

#+begin_src emacs-lisp :exports results :results list
  (directory-files doc-directory)
#+end_src

* Installation---Configuration---Customization---Starting
** Installing Emacs

*** What is Your Version
#+CINDEX: version
To check your Emacs' version from the shell, type:

#+caption:Your Emacs Version using the Shell
#+name:your-emacs-version-via-shell
#+header: :exports both :results output
#+begin_src sh
emacs --version
#+end_src

#+TEXINFO: @heading Emacs Version using Emacs

The version can be checked from within Emacs, using:
: M-x emacs-version ; or
: M-x version ; an alias for 'emacs-version'

#+attr_texinfo: :options emacs-version &optional here
#+begin_defun
  Return string describing the version of Emacs that is running.

  - HERE :: If optional argument HERE is non-nil, insert string at point.
#+end_defun

#+caption:Your Emacs Version using Emacs
#+name:your-emacs-version-via-emacs
#+header: :exports both :results output
#+begin_src emacs-lisp
(print (emacs-version))
#+end_src

#+TEXINFO: @heading System Configuration

To check the system configuration, refer to the value of
=system-configuration=.

#+attr_texinfo: :options system-configuration
#+begin_defvar
  Value is string indicating configuration Emacs was built for.

  Use  this variable  in programs  to choose  actions according  to the  system
  configuration.
#+end_defvar

#+caption: Value of the 'system-configuration' Variable
#+name:system-configuration-variable
#+header: :exports both :results value
#+begin_src emacs-lisp
system-configuration
#+end_src

*** Emacs on Mac OS
:CI:
#+CINDEX: Mac OS, installing
:END:
Mac OSX, in particular, seems to attract  a great deal of conflicting advice on
how  to best  run Emacs;  the best  advice  I can  offer is  to try  out a  few
different approaches and find one that fits you.

:CI:
#+CINDEX: Mac OS, unofficial builds
:END:
 + Unofficial build  --- One approach (though  there are several) is  to use an
   unofficial build of Emacs.

**** Emacs For Mac OSX
#+CINDEX: Emacs For Mac OSX
#+CINDEX: Mac OSX, flavors
[[http://emacsformacosx.com/][Emacs For Mac OSX]]

   - Pure Emacs! No extras! No nonsense!
   - About These Emacs Builds
     * I build three different release flavors of Emacs:
       1. Official releases --- These should be more stable but are not released
            very often.
       2. Pretests --- These are much more  stable and are meant for vetting the
                      code for last minute bugs before a final release.
       3. Nightlies ---  These are bleeding edge builds and  may have bugs. They
                       are built directly from the [[http://git.savannah.gnu.org/cgit/emacs.git/][public Git repository]]. I try
                       to build these nightly.
     * The scripts I run basically just  configure and build right from the GNU
       source --- I  don't add any patches or any  extraneous lisp packages.  I
       do include  the old  Carbon icon  on the  disk image  because I  like it
       better than the new Cocoa icon but it is not enabled by default.
     * Emacs is built on  various versions of Mac OS X: 10.6,  10.7 and 10.9 as
       of this writing. The 10.6 builds  also build 32-bit and PowerPC binaries
       (only Emacs 24 builds PowerPC ---  Emacs dropped support for it in Emacs
       25).  The  later OSes  only build  64-bit builds.  All the  binaries are
       combined  into a  single executable  and a  small Ruby  launcher chooses
       which binary to run based on the machine's OS and architecture.
     * Why not just use  a fat binary? Because fat binaries can  only hold 1 of
       each architecture and Emacs has multiple x86_64 architectures binaries.
     * Why are there multiple x86_64 binaries? Because the Emacs source does OS
       feature detection at compile time instead  of at run-time. So if I build
       Emacs on  10.9 then it  will contain hard-coded  calls to 10.9  APIs and
       will not run on 10.6. If I compile  it on 10.6, then it will also run on
       10.9, but it won't take advantage of any of the features in 10.9.
     * Because  of  the unstable  nature  of  nighly  builds, and  (sadly)  the
       relative fragility  of OS X  running on VMs,  there may be  days missing
       here and there.
     * *Note:* Recent Emacs builds (since 2009-12-09) have 64 bit Intel support
       in the Universal Binary. Yay!
     * *Also  Note:* Recent  Emacs builds  (since 2012-12-16)  have been  built
       against Mac OS 10.7 (Lion) and have  Lion full screen support if you are
       running on Lion  or Mountain Lion. They also have  better retina display
       support and are code signed. Also Yay!
     * *Also  Also  Note:*  Recent  Emacs  builds  (since  2016-08-15)  include
       ~gnutls~ (except on Mac OS 10.6 ---  Homebrew doesn't work on 10.6 and I
       don't want to spend a lot of  time compiling ~gnutls~ on a platform that
       is  barely  used).    You  can  now  use  https  urls   in  the  package
       configuration. Yay!
     * *Also Also  Also Note:*  Recent Emacs builds  (since 2018-04-10)  do not
       include  ~gnutls~  on  10.8  and lower.   Unfortunately  the  method  of
       downloading  ~gnutls~ (Homebrew)  stopped  working  because the  servers
       stopped  supporting old  SSL versions  and  10.8's SSL  libs aren't  new
       enough.  The  Emacs 26.0.91-1  pretest  is  the  last version  that  has
       ~gnutls~ on Mac OS 10.8.

#+CINDEX: Mac OSX, build scripts
   - The Build Scripts
     * Get them here: https://github.com/caldwell/build-emacs
     * I rewrote the build scripts in 2014 to make them more modular so I could
       easily control them with Jenkins. I  also moved them from shell to Ruby,
       which cleaned things up tremendously. They still aren't documented super
       well, but they should be easier to read, at least.

#+CINDEX: Mac OSX, tips and tricks
#+CINDEX: Mac OSX, @code{Emacs.app}
    - Tips  and  Tricks  --  Here  are  some tips  and  tricks  on  setting  up
      ~Emacs.app~ on  Mac OS X.  These  are based on my  personal experience of
      using ~Emacs.app~ for the past 10 years  or so; there may be better ways,
      but these work for me.

@@texinfo:@heading Running @code{Emacs.app} from the command line with @command{emacs}@@

Call this script @@texinfo:@command{emacs}@@ and put it somewhere in your
@@texinfo:@env{PATH}@@ (@@texinfo:@code{~/bin}@@ or
@@texinfo:@code{/usr/local/bin}@@):

#+BEGIN_EXAMPLE
#!/bin/sh
/Applications/Emacs.app/Contents/MacOS/Emacs "$@"
#+END_EXAMPLE

@@texinfo: @heading Using @command{emacsclient}@@

 1. Make sure the latest @@texinfo:@code{emacsclient}@@ binary is in your path:

#+BEGIN_EXAMPLE
ln -s /Applications/Emacs.app/Contents/MacOS/bin/emacsclient /usr/local/bin
# or ~/bin if you prefer
#+END_EXAMPLE

 2. Call this script @@texinfo:@command{ec}@@ and  put it somewhere in your @@texinfo:@env{PATH}@@
    (@@texinfo:@code{~/bin}@@ or @@texinfo:@code{/usr/local/bin}@@):

#+BEGIN_EXAMPLE
#!/bin/sh
which osascript > /dev/null 2>&1 && osascript -e 'tell application "Emacs" to activate'
emacsclient -c "$@"
#+END_EXAMPLE

 3.  Add   @@texinfo:@command{alias  emacs=ec}@@   or  @@texinfo:@command{alias
    emacsclient=ec}@@   to  your   @@texinfo:@code{.bashrc}@@.   Or   just  use
    @@texinfo:@command{ec}@@ directly.

@@texinfo:@heading Using Emacs as the @command{mergetool} for @command{git}@@

 1. Add add this snippet to your @@texinfo:@code{.gitconfig}@@:

#+BEGIN_EXAMPLE
[merge]
        tool = ediff
[mergetool "ediff"]
        cmd = emacs --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
#+END_EXAMPLE

 2. If you want to use @@texinfo:@command{emacsclient}@@, add this snippet
    instead:

#+BEGIN_EXAMPLE
[merge]
  tool = ediff
[mergetool "ediff"]
  cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
#+END_EXAMPLE

@@texinfo:@heading Changing the Modifier Keys@@

@@texinfo:@subheading Easy@@
The easiest way is to use the Customize interface: ~M-x customize-group RET ns RET~.

@@texinfo:@subheading Hard@@
If you don't like Customize and want to do it manually, the following variables
control the modifier keys:

 - ns-alternate-modifier
 - ns-command-modifier
 - ns-control-modifier
 - ns-function-modifier
 - ns-option-modifier (just a different name for ns-alternate-modifier)
 - ns-right-alternate-modifier
 - ns-right-command-modifier
 - ns-right-control-modifier
 - ns-right-option-modifier

Each variable can be set to ~'control~, ~'meta~, ~'alt~, ~'super~, or ~'hyper~.

In addition ~ns-alternative-modifier~ (and  ~ns-option-modifier~) can be set to
~'none~, which  lets it get interpreted  by the OS so  it can be used  to input
special characters.

The ~ns-right-*~  variables are set to  ~'left~ by default which  makes them the
same as their ~left~ counterpart.

@@texinfo:@heading Verifying the Binary Integrity@@

This  site serves  the binaries  via SSL  and while  the binaries  are not  GPG
signed, the application is code signed. You can verify the signature like this:
 : codesign -dvv /Applications/Emacs.app

Or, if you haven't installed emacs yet, but have mounted the disk image:
 : codesign -dvv /Volumes/Emacs/Emacs.app

Look for the following in the output:

#+BEGIN_EXAMPLE
Authority=Developer ID Application: Galvanix
Authority=Developer ID Certification Authority
Authority=Apple Root CA
#+END_EXAMPLE

~Galvanix~  is my  consulting partnership  and is  what I  registered my  Apple
developer account under. If you see that, the binary is intact.

**** Build Emacs from Source on OSX
#+begin_src sh
git clone git://git.savannah.gnu.org/emacs.git
cd emacs
./autogen.sh
./configure --with-ns
make install
cd nextstep
open Emacs.app 
#+end_src

**** Emacs-Mac by Mitsuharu Yamamoto
- https://bitbucket.org/mituharu/emacs-mac/overview
- https://github.com/railwaycat/homebrew-emacsmacport

**** Emacs Plus
- https://github.com/railwaycat/homebrew-emacsmacport

**** Emacs For Mac OS Wiki
:CI:
#+CINDEX: wiki, mac os
:END:
[[https://www.emacswiki.org/emacs/EmacsForMacOS][EmacsForMacOS Wiki]]

***** Distributions

****** Vanilla
These builds are based on the development version of GNU Emacs and do not
contain any additional packages or patches.  Popular Mac keyboard shortcuts are
available though (e.g. ~Command-O~ for opening a file); these are mapped to the
~Super~ modifier (i.e., the Apple/Command key functions as ~Super~).

#+CINDEX: EmacsForMacOS
[[http://emacsformacosx.com/][EmacsForMacOS]]

****** Extras

******* Mitsuhara Yamamoto's Mac Port
#+CINDEX: Mac Port
[[https://bitbucket.org/mituharu/emacs-mac/][Mac Port]]

 Based on the latest stable release of GNU Emacs (26.1 as of 2018-06-14) and
 claims to incorporate most of the features of Carbon Emacs and the
 Carbon+AppKit port from Emacs 22.3. It has improved ~C-g~ support, an emulation
 of ‘select’ that doesn’t require periodic polling, full screen support,
 subpixel font rendering, and smooth (pixel) scrolling.  See the [[https://bitbucket.org/mituharu/emacs-mac/][readme]] for more
 details. Available via Homebrew and MacPorts (as emacs-mac-app), as discussed
 below, or prebuilt binaries.

******* Aquamacs
#+CINDEX: Aquamacs
- [[http://aquamacs.org/][Aquamacs]]

- [[https://github.com/davidswelt/aquamacs-emacs/][Github Aquamacs-Emacs]]

Is a convenient distribution based on GNU Emacs 25.1.

Aquamacs comes preconfigured with a large number of packages and differs from
other Emacsen in that it feels more like a Mac OS X application.

OS X standard keyboard shortcuts are supported, files open in separate windows
or tabs, nice fonts are available, and it has a convenient drag&drop
installer.

Hundreds of file types are supported (C, Java, HTML, Python, Ruby, AppleScript,
XML, R (Splus), LaTeX (AUCTeX) etc.).

All these extra modes come included and readily configured – no InitFile
hacking.

Spell checking is easy to install (e.g., CocoAspell) and asian input methods
are also supplied, and options to deal with the missing Meta key on Mac
keyboards.

Aquamacs is based on Cocoa, the modern user interface framework in OS X.

It is a ready-to-use Universal App for PPC and Intel Macs that works well on
all recent Mac OS X versions.  Recommended for Mac users who want an Emacs that
is tailored to the Mac.

Experimental versions based on GNU Emacs 25 are also available.

******* Emacs Modified for macOS
- [[https://vigou3.gitlab.io/emacs-modified-macos/][Emacs Modified for macOS]]

*Emacs Modified for macOS* is a distribution of GNU Emacs 26.1 (released May
28, 2018) bundled with a few select packages for R developers and LaTeX users.
The distribution is based on the latest stable release of GNU Emacs compiled by
David Caldwell and distributed on Emacs for Mac OS X.

******** Philosophy
This distribution of Emacs is based on the NeXTstep port part of the official
sources of GNU Emacs. Other than the additions mentioned above and the minor
configurations found in the site-start.el file, this is a stock distribution of
Emacs. Users of Emacs on other platforms will appreciate the similar look and
feel of the application.

******** vs. Aquamacs
#+CINDEX: Aquamacs
Those looking for a more Mac-like version of Emacs may consider Aquamacs. I
used Aquamacs myself for two years, but I got tired of disabling the newer
“features” in each release of the application. For me Aquamacs insists too much
on opening new frames and on playing with fonts. Moreover, ESS is not kept up
to date on a regular basis.

****** Building From Source
- To download emacs using git, use this command:
  : git clone git://git.savannah.gnu.org/emacs.git
- Tarball Available from the [[http://savannah.gnu.org/projects/emacs/][GNU Savannah emacs]] page.  Click on “Download Area”
  under “Quick Overview”.

******* Building
- There are many options for building emacs (such as whether to build for the
  X11 GUI or the Cocoa GUI), which are discussed in the INSTALL file.
- There is also a script (~emacs/mac/make-package~) to create a Mac OS X
  package for use by the installer.
- The “normal” way to build Emacs under Mac OS X is:
#+BEGIN_EXAMPLE
./configure --with-ns
 make install
#+END_EXAMPLE
- When the build is complete, you should see ~Emacs.app~ in
  ~./nextstep/Emacs.app~.  Simply copy it to your applications folder and open
  it to run.
- For more detailed instructions, see the ~nextstep/INSTALL~ file.
- Additionally, you may benefit from reading the build script here: http://github.com/ieure/emacs-nightly.

**** iTerm Wiki for Emacs
:CI:
#+CINDEX: iTerm
:END:
[[https://www.emacswiki.org/emacs/iTerm2#toc11][iTerm Wiki for Emacs --- Super and Hyper Keys]]

***** Why getting Super and Hyper working in a terminal is not straightforward
The reason for this has to do a lot with DEC terminal history and the keys that
were available  in some of the  earliest possible terminals.  The  DEC terminal
became the default basis of emulation for most software.

Contrast  this with  the [[https://en.wikipedia.org/wiki/Space-cadet_keyboard][Space-cadet]]  keyboard  that influenced  the design  of
Emacs, made  for MIT Lisp  machines.  It  included several modifier  keys which
allowed multiple  character sets  as well  as a large  macro space  for binding
commands to key combinations.   Two modifier keys to the left  of the space bar
on the Space-cadet keyboard include the *Super* and *Hyper* keys.

While insanely  useful for the  experienced user,  fewer people worked  on Lisp
machines  compared  to  the  widespread  availability  of  VT-series  character
terminals. All  command line and  serial-terminal interaction you’ll  ever find
supports VT-100.

In GUI mode most emacsen will bind the Windows or Option key to *Super*U. Or if
you’re a Mac  user, you might have swapped  *Alt* and *⌘* so the  *Meta* key is
closest to the spacebar and easier to reach.

When  you press  a key  on your  keyboard your  terminal emulator  will send  a
character  or  an escape  sequence  down  the  connection.   For DEC  or  xterm
terminals, some keys may not send signals.  iTerm2 can make use of any key that
OSX will respond to and you can  customize it to run commands locally, remotely
or send signals down the terminal connection to the remote machine.

***** Testing escape codes
First,  connect  your  remote  machine  and  issue  the  cat  command  with  no
parameters. Depending on  your OS, termcap on the remote  and the codepage your
keyboard is set  to, you’ll see either  a character or an  escape sequence when
you type something.

Let’s see how the Latin letter ~O~ works when pressed with modifier keys.
 + When I press ~o~, I get an ~o~.
 + But when I press ~ALT+o~, I get ~^[o~
 + When I press ~CTRL+ALT+o~, I get ~^[^O~
 + And when I press ~SHIFT+ALT+o~, I get ~^[O~

These combos are being  read by the remote machine and being  fed to ~STDIN~ to
~cat~ (and ~cat~ is reading them back  as output).  They’re also the most basic
escape sequences, as ~^~ is the code for ~COMMAND~, and ~^[~ is for ~ALT/META~,
known  as the  escape sequence  ~^[~ .   For terminals  and IBM  PCs, the  ~^[~
signifies some sort  of terminal code, signifying a keypress  or some action to
be taken  on the terminal  or the  remote.  If your  keyboard has a  D-pad, try
hitting  ~<up> <down>  <right>~ and  ~<left>~.  Usually  these will  be ~^[[A~,
~^[[B~, ~^[[C~ and ~^[[D~, respectively.

You can press ~C-c~ to get out of ~cat~

Now let’s  try sending a  more complicated escape  sequence using some  keys on
your keyboard and fool Emacs on the  remote into thinking you pressed a *Hyper*
key combo.
 + Go into your iTerm2 settings for your connection profile.
 + In the Keys panel, let’s set a key combo for ~Ctrl+⌘+Option+A~, which is the
   three leftmost keys next to the space bar plus the letter ~A~.
 + I’m pretty confident your remote termcap probably does not have an entry for
   ~^[[1;P9~, so let’s start off with that code.
 + Your setting should look like this:
   + Keyboard Shortcut :: ~^+Option+Control+a~
   + Action :: Send Escape Sequence
   + Escape :: ~[1;P9~
 + Let’s get Emacs to listen for this key.  Evaluate the following Lisp code in
   an Emacs session (I  took the liberty of adding escapes for  the rest of the
   keys):
 + Now we can bind Hyper to something.  Let’s try this:
   + ~(global-set-key (kbd "H-a") 'dired)~
 + Now when  you press ~Ctrl+⌘+Option+A~, ~dired~ should pop  up.  Proceed with
   adding the rest  of the keys and  escape codes in your  iTerm2 setup.  Also,
   you can use the ~cat~ command to  check your work and ensure that the proper
   escape sequences are reaching the remote machine.
 + You can also  make combinations with ~Control~ and ~META~  such as ~C-c H-o~
   with this technique.  For ~C-c H-o~ you would hit ~C-c~ and then release the
   keys, then ~Ctrl+⌘+Option+o~ for the ~H-o~ part.
 +  Now  you can  make  loads  more keybindings  for  all  your favorite  Emacs
   commands.

** System Information

- system-type :: The value of this variable  is a symbol indicating the type of
  operating system Emacs is running on.

  - aix (IBM)
  - berkeley-unix (BSD and variants)
  - cygwin (POSIX layer on MS-Windows)
  - darwin (macOS)
  - gnu (GNU kernel of HURD and Mach)
  - gnu/linux (Gnu/Linux system using Linux kernel)
  - gnu/kfreebsd (GNU (glibc-based) system using FreeBSD kernel)
  - hpux (HP HPUX)
  - nacl (Google Native Client NaCl)
  - ms-dos (MS-DOS)
  - usg-unix-v (AT&T Unix System V)
  - windows-nt (Microsoft Windows, 9X and later, Windows 10)

- system-configuration ::  This variable  holds the standard  GNU configuration
  name for the hardware/software configuration of your system, as a string.
  : "x86_64-apple-darwin19.6.0"

- system-name :: This function returns the  name of the machine you are running
  on, as a string.
  : LOLH.lolh

- initial-window-system :: variable identifying  type of windowing system being
  used.
  : ns

- mail-host-address ::  When  non-nil, it is used instead  of ‘system-name’ for
  purposes of  generating email  addresses.  It is  used when  constructing the
  default value of ‘user-mail-address’.

- invocation-name :: This variable holds the program name under which Emacs was
  invoked.  The value is a string, and does not include a directory name.
  : Emacs

- invocation-directory :: This variable holds  the directory in which the Emacs
  executable was located when it was run,  or ‘nil’ if that directory cannot be
  determined.
  : "/Applications/Emacs.app/Contents/MacOS/"

- emacs-pid :: This function returns the process ID of the Emacs process, as an
  integer.
  : 51831

- process-environment ::  This variable is  a list of strings,  each describing
  one environment variable.  The functions  ‘getenv’ and ‘setenv’ work by means
  of this variable.

  - getenv var["string"]; returns the value of the environment variable VAR, as
    a string
  - setenv  var["string"]   &optional  value  substitute;  ‘setenv’   works  by
    modifying ‘process-environment’;  binding that variable with  ‘let’ is also
    reasonable practice.

** Starting and Stopping Emacs

*** Starting Emacs

**** Emacs Starting Operations

When  Emacs  is   started  up,  it  performs  the   following  operations  (see
‘normal-top-level’ in ‘startup.el’):

1. It  adds   subdirectories  to  ‘load-path’,  by  running   the  file  named
  ~subdirs.el~ in  each directory in the  list.  Normally, this file  adds the
  directory’s subdirectories to the list, and those are scanned in their turn.
  The files  ‘subdirs.el’ are normally  generated automatically when  Emacs is
  installed.

2. It  loads any ‘leim-list.el’ that  it finds in the  ‘load-path’ directories.
   This file is intended for registering input methods.

3. It sets the variable ‘before-init-time’  to the value of ‘current-time’.  It
   also sets  ‘after-init-time’ to ‘nil’,  which signals to Lisp  programs that
   Emacs is being initialized.

4. It  sets the  language  environment  and  the  terminal coding  system,  if
  requested by environment variables such as ‘LANG’.

5. It does some basic parsing of the command-line arguments.

6. It loads your early init file.  This  is not done if the options ‘-q’, ‘-Q’,
   or ‘--batch’ were specified.  If the  ‘-u’ option was specified, Emacs looks
   for the init file in that user’s home directory instead.

7. It calls the function  ~package-activate-all~ to activate any optional Emacs
   Lisp package that  has been installed.  However, Emacs  doesn’t activate the
   packages when ~package-enable-at-startup~ is ‘nil’ or when it’s started with
   one of  the options ‘-q’, ‘-Q’,  or ‘--batch’.  To activate  the packages in
   the latter  case, ~package-activate-all~ should be  called explicitly (e.g.,
   via the =--funcall= option).

8. If  not running  in batch mode,  it initializes the  window system  that the
   variable ~initial-window-system~ specifies.
   #+cindex:hook, before-init-hook
9. It runs the normal hook ‘before-init-hook’.

10. If  appropriate, it  creates a  graphical frame.  As  part of  creating the
    graphical   frame,  it   initializes   the  window   system  specified   by
    ‘initial-frame-alist’ and ‘default-frame-alist’ for the graphical frame, by
    calling the ‘window-system-initialization’ function for that window system.
    This is not done in batch (noninteractive) or daemon mode.

11. It initializes the initial frame’s faces, and sets up the menu bar and tool
    bar if needed.

12. It use ‘custom-reevaluate-setting’ to re-initialize the members of the list
    ‘custom-delayed-init-variables’.   These are  any  pre-loaded user  options
    whose  default  value depends  on  the  run-time, rather  than  build-time,
    context.

13. It loads the  library ‘site-start’, if it exists.  This is  not done if the
    options ‘-Q’ or ‘--no-site-file’ were specified.

14. It loads  your init file.  This is  not done if the options  ‘-q’, ‘-Q’, or
    ‘--batch’ were  specified.  If the  ‘-u’ option was specified,  Emacs looks
    for the init file in that user’s home directory instead.

15. It loads  the  library ‘default’,  if  it  exists.  This  is  not done  if
   ‘inhibit-default-init’  is non-‘nil’,  nor if  the options  ‘-q’, ‘-Q’,  or
   ‘--batch’ were specified.

16. It  loads your abbrevs  from the  file specified by  ‘abbrev-file-name’, if
    that file exists and can be read.  This is not done if the option ‘--batch’
    was specified.

17. It sets  the variable  ‘after-init-time’ to  the value  of ‘current-time’.
   This variable  was set  to ‘nil’  earlier; setting it  to the  current time
   signals  that  the  initialization  phase   is  over,  and,  together  with
   ‘before-init-time’, provides the measurement of how long it took.
   #+cindex:hook, after-init-hook
18. It runs the normal hook ‘after-init-hook’.

19. If the  buffer ‘*scratch*’ exists and  is still in Fundamental  mode (as it
    should   be  by   default),   it   sets  its   major   mode  according   to
    ‘initial-major-mode’.
    #+cindex:hook, tty-setup-hook
20. If started on a text terminal, it loads the terminal-specific Lisp library,
    and runs  the hook ‘tty-setup-hook’.  This  is not done in  ‘--batch’ mode,
    nor if ‘term-file-prefix’ is ‘nil’.

21. It displays the initial echo  area message, unless you have suppressed that
    with ‘inhibit-startup-echo-area-message’.

22. It processes any command-line options that were not handled earlier.

23. It now exits if the option ‘--batch’ was specified.

24. If   the  ‘*scratch*’   buffer   exists   and   is  empty,   it   inserts
  ‘(substitute-command-keys initial-scratch-message)’ into that buffer.

25. If ‘initial-buffer-choice’  is a string, it visits the  file (or directory)
    with  that name.   If it  is  a function,  it  calls the  function with  no
    arguments and selects the buffer that it  returns.  If one file is given as
    a command  line argument,  that file  is visited  and its  buffer displayed
    alongside ‘initial-buffer-choice’.  If more than  one file is given, all of
    the files are visited and the ‘*Buffer List*’ buffer is displayed alongside
    ‘initial-buffer-choice’.
    #+cindex:hook, emacs-startup-hook
26. It runs ‘emacs-startup-hook’.

27. It calls ‘frame-notice-user-settings’, which modifies the parameters of the
    selected frame according to whatever the init files specify.
    #+cindex:hook, windows-setup-hook
28. It  runs ‘window-setup-hook’.   The only difference  between this  hook and
    ‘emacs-startup-hook’ is that  this one runs after  the previously mentioned
    modifications to the frame parameters.

29. It displays  the “startup screen”, which is a  special buffer that contains
    information about  copyleft and  basic Emacs  usage.  This  is not  done if
    ‘inhibit-startup-screen’  or ‘initial-buffer-choice’  are non-‘nil’,  or if
    the ‘--no-splash’ or ‘-Q’ command-line options were specified.

30. If a daemon was requested,  it calls ‘server-start’.  (On POSIX systems, if
    a background  daemon was requested,  it then detaches from  the controlling
    terminal.)

31.  If started  by the  X  session manager,  it calls  ‘emacs-session-restore’
    passing it as argument the ID of the previous session.

***** Terminal-Specific Initialization

Each terminal type can  have its own Lisp library that Emacs  loads when run on
that type of terminal.

The usual role of a terminal-specific library is to enable special keys to send
sequences  that Emacs  can  recognize.  It  may  also  need to  set  or add  to
‘input-decode-map’ if  the Termcap or Terminfo  entry does not specify  all the
terminal’s function keys.

**** Emacs Starting Options

The following options affect some aspects of the startup sequence.

- inhibit-startup-screen ::  This variable, if non-‘nil’,  inhibits the startup
  screen.  In that  case, Emacs typically displays the  ‘*scratch*’ buffer; but
  see ‘initial-buffer-choice’, below.

  ‘inhibit-startup-message’  and ‘inhibit-splash-screen’  are aliases  for this
  variable.

- initial-buffer-choice  ::  If  non-‘nil’,  this variable  is  a  string  that
  specifies a file or directory for Emacs to display after starting up, instead
  of the startup screen.  If its value is a function, Emacs calls that function
  which must  return a buffer  which is then displayed.   If its value  is ‘t’,
  Emacs displays the ‘*scratch*’ buffer.

- inhibit-startup-echo-area-message ::  This variable  controls the  display of
  the  startup echo  area  message.  You  can suppress  the  startup echo  area
  message by adding text with this form to your init file:

  #+begin_src elisp
    (setq inhibit-startup-echo-area-message
          "YOUR-LOGIN-NAME")
  #+end_src

  Emacs explicitly checks  for an expression as shown above  in your init file;
  your login name must appear in the expression as a Lisp string constant.  You
  can   also  use   the  Customize   interface.   Other   methods  of   setting
  ‘inhibit-startup-echo-area-message’  to the  same  value do  not inhibit  the
  startup message.  This  way, you can easily inhibit the  message for yourself
  if you wish, but  thoughtless copying of your init file  will not inhibit the
  message for someone else.

- initial-scratch-message :: This  variable, if non-‘nil’, should  be a string,
  which is treated as documentation to  be inserted into the ‘*scratch*’ buffer
  when Emacs starts up.  If it is ‘nil’, the ‘*scratch*’ buffer is empty.

**** Emacs Command-Line Options Affecting Startup Sequence

The following command-line options affect some aspects of the startup sequence.

- =--no-splace= :: Do not display a splash screen.

- =--batch= :: Run without an interactive terminal.

- =--daemon=, =--bg-daemon=,  =--fg-daemon= ::  Do not initialize  any display;
  just  start a  server.   (A  “background” daemon  automatically  runs in  the
  background.)

- =--no-init-file=, =-q= :: Do not load  either the init file, or the ‘default’
  library.

- =--no-site-file= :: Do not load the ‘site-start’ library.

- =--quick=, =-Q= :: Equivalent to ‘-q --no-site-file --no-splash’.

**** Emacs Command-Line Initial Options

The initial options specify parameters for the Emacs session.

Some initial options affect the  loading of the initialization file.  Normally,
Emacs first  loads ‘site-start.el’ if  it exists, then your  own initialization
file if it exists, and finally  the default initialization file ‘default.el’ if
it exists  (*note Init  File::).  Certain  options prevent  loading of  some of
these files or substitute other files for them.

- =--chdir=DIRECTORY=  :: Change  to  =DIRECTORY= before  doing anything  else.
  This is mainly  used by session management  in X so that Emacs  starts in the
  same  directory as  it  stopped.   This makes  desktop  saving and  restoring
  easier.

- =--terminal=DEVICE=, =-t= :: Use DEVICE as  the device for terminal input and
  output.  This option implies ‘--no-window-system’.

- =--no-window-system-=, =-nw=   :: Don’t communicate directly  with the window
  system, disregarding  the =DISPLAY= environment  variable even if it  is set.
  This means that  Emacs uses the terminal  from which it was  launched for all
  its display and input.

- =--batch=  ::   Run Emacs in  “batch mode”.  Batch  mode is used  for running
  programs written in Emacs Lisp from  shell scripts, makefiles, and so on.  To
  invoke a  Lisp program, use the  ‘--batch’ option in conjunction  with one or
  more of ‘-l’, ‘-f’ or ‘--eval’.

  In batch mode, Emacs does not display the text being edited, and the standard
  terminal  interrupt characters  such  as  ‘C-z’ and  ‘C-c’  have their  usual
  effect.  Emacs functions that normally print  a message in the echo area will
  print to either  the standard output stream (‘stdout’) or  the standard error
  stream (‘stderr’) instead.

  - ‘prin1’, ‘princ’ and  ‘print’  print  to  ‘stdout’,

  - while ‘message’  and ‘error’ print  to ‘stderr’.

  - Functions that normally read keyboard  input from the minibuffer take their
    input from the terminal’s standard input stream (‘stdin’) instead.

  This  option  implies  ‘-q’  (do   not  load  an  initialization  file),  but
  ‘site-start.el’ is  loaded nonetheless.  It  also causes Emacs to  exit after
  processing all  the command  options.  In  addition, it  disables auto-saving
  except in  buffers for  which auto-saving is  explicitly requested,  and when
  saving files it omits the ‘fsync’ system call unless otherwise requested.

- =--script FILE= :: Run Emacs in batch mode, like ‘--batch’, and then read and
  execute the Lisp code in FILE.

  The normal use of  this option is in executable script  files that run Emacs.
  They can start with this text on the first line:

  : #!/usr/bin/emacs --script

  which will  invoke Emacs with  ‘--script’ and supply  the name of  the script
  file  as FILE.   Emacs Lisp  then treats  the ‘#!’  on this  first line  as a
  comment delimiter.

- =--no-init-file=, =-q=  ::  Do not  load any initialization file.  When Emacs
  is invoked with this option, the Customize facility does not allow options to
  be saved.  This option does not disable loading ‘site-start.el’.

- =--no-site-file=, =-nsl=  :: Do  not load  ‘site-start.el’.  The  ‘-Q’ option
  does this too, but other options like ‘-q’ do not.

- =--no-site-lisp=   ::  Do   not  include   the  ‘site-lisp’   directories  in
  ‘load-path’.  The ‘-Q’ option does this too.

- =--no-splash= :: Do not display a  startup screen.  You can also achieve this
  effect by setting the variable  ‘inhibit-startup-screen’ to non-‘nil’ in your
  initialization file.

- =--quick=, =-Q= :: Start Emacs  with minimum customizations.  This is similar
  to  using ‘-q’,  ‘--no-site-file’, ‘--no-site-lisp’,  ‘--no-x-resources’, and
  ‘--no-splash’ together.

- =--daemon[=NAME]=  ::  Start Emacs  as a  daemon: after  Emacs starts  up, it
  starts the  Emacs server without  opening any frames.   You can then  use the
  ‘emacsclient’ command to connect to  Emacs for editing.  (Optionally, you can
  specify an explicit NAME for the server;  if you do, you will need to specify
  the same NAME when you  invoke ‘emacsclient’, via its ‘--socket-name’ option.
  A  “background”  daemon  disconnects  from  the  terminal  and  runs  in  the
  background (‘--daemon’ is an alias for ‘--bg-daemon’).

- =--no-desktop= :: Do not reload any saved desktop.

- =--debug-init= :: Enable the Emacs Lisp debugger for errors in the init file.

*** Stopping Emacs

There are two ways to get out of Emacs:
- you can kill the Emacs job, which exits permanently, or
- you can suspend it, which permits you to reenter the Emacs process later.

**** Killing Emacs

Killing Emacs means ending the execution  of the Emacs process.  If you started
Emacs from a terminal, the parent process normally resumes control.

The low-level primitive for killing Emacs is ‘kill-emacs’.

- ~kill-emacs &optional exit-data~ ::
  #+cindex:kill-emacs
  #+cindex:hook, kill-emacs-hook
  This command calls  the hook ‘kill-emacs-hook’, then exits  the Emacs process
  and kills it.

  If =EXIT-DATA= is  an integer, that is  used as the exit status  of the Emacs
  process.  This is useful primarily in batch operations.

  If =EXIT-DATA= is a string, its  contents are stuffed into the terminal input
  buffer so  that the  shell (or  whatever program next  reads input)  can read
  them.

  If =EXIT-DATA= is neither an integer nor  a string, or is omitted, that means
  to use the  (system-specific) exit status which  indicates successful program
  termination.

- ~save-buffers-kill-terminal~ :: =C-x C-x=
  #+cindex:save-buffers-kill-terminal
  The ‘kill-emacs’  function is  normally called  via the  higher-level command
  ‘C-x C-c’ (‘save-buffers-kill-terminal’).

  It is  also called automatically  if Emacs  receives a ‘SIGTERM’  or ‘SIGHUP’
  operating   system   signal  (e.g.,   when   the   controlling  terminal   is
  disconnected), or  if it receives  a ‘SIGINT’  signal while running  in batch
  mode.

  #+cindex:hook, kill-emacs-query-functions
  It also runs the abnormal hook ‘kill-emacs-query-functions’

**** Suspending Emacs
On text  terminals, it  is possible  to “suspend  Emacs”, which  means stopping
Emacs  temporarily and  returning control  to  its superior  process, which  is
usually the shell.  This  allows you to resume editing later  in the same Emacs
process, with the same buffers, the same  kill ring, the same undo history, and
so on.  Suspending works only on a terminal device from which the Emacs session
was started.  We call that device the “controlling terminal” of the session.

- suspend-emacs  &optional string  ::  This function  stops  Emacs and  returns
  control to  the superior process.  If  and when the superior  process resumes
  Emacs, ‘suspend-emacs’ returns ‘nil’ to its caller in Lisp.

  If =STRING= is non-‘nil’, its characters  are sent to Emacs’s superior shell,
  to be read as  terminal input.  The characters in =STRING=  are not echoed by
  the superior shell; only the results appear.
  #+cindex:hook, suspend-hook, suspend-resume-hook
  Before  suspending,  ‘suspend-emacs’  runs the  normal  hook  ‘suspend-hook’.
  After  the  user   resumes  Emacs,  ‘suspend-emacs’  runs   the  normal  hook
  ‘suspend-resume-hook’.

#+texinfo:@heading Example of ~suspend-emacs~ Function

#+begin_src elisp
  (add-hook 'suspend-hook
            (lambda () (or (y-or-n-p "Really suspend? ")
                           (error "Suspend canceled"))))
  (add-hook 'suspend-resume-hook (lambda () (message "Resumed!")
                                   (sit-for 2)))
#+end_src

Here is what you would see upon evaluating ‘(suspend-emacs "pwd")’:

#+begin_example
          ---------- Buffer: Minibuffer ----------
          Really suspend? y
          ---------- Buffer: Minibuffer ----------

          ---------- Parent Shell ----------
          bash$ /home/username
          bash$ fg

          ---------- Echo Area ----------
          Resumed!
#+end_example

Note that  ‘pwd’ is not echoed  after Emacs is  suspended.  But it is  read and
executed by the shell.

** Configuring
"Configuring" are  things that "should" be  done or "should" be  checked, while
"Customizing"  are things  that "can"  be done  to create  a more  personalized
experience.

*** Emacs Initialization

#+texinfo:@heading The Emacs =Initialization= File

When  Emacs is  started, it  normally  tries to  load  a Lisp  program from  an
“initialization  file”, or  “init file”  for short.  This file,  if it  exists,
specifies how to initialize Emacs for you.

Emacs looks for your =init= file using the filenames (in this order):

- =~/.emacs=
- =~/.emacs.el=
- =~/.emacs.d/init.el=
- =~/.config/emacs/init.el=
- =$XDG_CONFIG_HOME/emacs/init.el=
- modern  POSIX  platforms  prefer  putting  your  initialization  files  under
  ‘~/.config’ so that troubleshooting a problem that might be due to a bad init
  file, or archiving a  collection of init files, can be  done by renaming that
  directory.
- Note that if neither the XDG location nor ‘~/.emacs.d’ exist, then Emacs will
  create ‘~/.emacs.d’ (and therefore use it during subsequent invocations).
- Emacs will set [[*Emacs Directory][‘user-emacs-directory’]] to the directory it decides to use

If your =init= file defines many  functions, consider moving them to a separate
(byte-compiled) file that you load in your =init= file.

To prevent  loading the  =init= file,  using the  command-line switch  =-q=. To
specify a unique file  to load as the =init= file,  use the command-line switch
=-u, --user=.

#+TEXINFO: @subheading Use @code{setq-default}

Some variables automatically become buffer-local when set with ‘setq’; what you
want in the init file is to set the default value, using ‘setq-default’.

#+ATTR_texinfo: :options setq-default [var value] ...
#+BEGIN_defun
  Set  the default  value of  variable VAR  to VALUE.  The default  value of  a
  variable  is seen  in buffers  that  do not  have  their own  values for  the
  variable.

  - VAR :: the variable name, is literal (not evaluated);

  - VALUE :: is an expression: it is evaluated and its value returned.

  More generally, you can use multiple variables and values, as in
  : (setq-default VAR VALUE VAR VALUE...)
#+END_defun

#+TEXINFO: @heading Site Startup File

#+cindex:site startup file
#+vindex:site-start.el
Your site may  also have a “site startup file”;  this is named ‘site-start.el’,
if it  exists. Emacs  finds this  file via  the standard  search path  for Lisp
libraries. Emacs loads this library before it loads your =init= file.

To inhibit loading of this library, use the option ‘--no-site-file’.

#+TEXINFO: @heading Default Init File

#+cindex:default init file
#+vindex:default.el
#+findex:inhibit-default-init
There  can  also  be  a  “default  init  file”,  which  is  the  library  named
‘default.el’,  found via  the standard  search  path for  libraries. The  Emacs
distribution  contains no  such library;  your site  may create  one for  local
customizations. If this  library exists, it is loaded whenever  you start Emacs
(except when you specify ‘-q’). But your init file, if any, is loaded first; if
it sets ‘inhibit-default-init’ non-‘nil’, then ‘default’ is not loaded.

#+TEXINFO: @heading Location of Init Files
#+vindex:load-path
You can place ‘default.el’ and ‘site-start.el’  in any of the directories which
Emacs  searches  for  Lisp  libraries. The  variable  ‘load-path’  (*note  Lisp
Libraries) specifies these directories.

#+TEXINFO: @heading The Early Init File
Most customizations for Emacs should be put in the normal init file. *Note Init
File.  However, it  is sometimes  desirable  to have  customizations that  take
effect during  Emacs startup earlier  than the  normal init file  is processed.
Such customizations can be put in the early init file,

- =~/.config/emacs/early-init.el=
- =~/.emacs.d/early-init.el=

This file is loaded before the package  system and GUI is initialized, so in it
you can customize variables that affect frame appearance as well as the package
initialization process, such as
- ‘package-enable-at-startup’,
- ‘package-load-list’, and
- ‘package-user-dir’.

*** Emacs Directory

#+ATTR_texinfo::options user-emacs-directory
#+BEGIN_defvar
  Directory beneath which additional  per-user Emacs-specific files are placed.
  Various programs in Emacs store information in this directory.
#+END_defvar

- Current Value: src_elisp{(symbol-value 'user-emacs-directory)}

#+ATTR_texinfo::options locate-user-emacs-file new-name &optional old-name
#+BEGIN_defun
  Return an absolute per-user Emacs-specific file name.

  - NEW-NAME :: If =NEW-NAME= exists in ~user-emacs-directory~, return it.

  - OLD-NAME  :: else if =OLD-NAME=  is non-nil and =~/OLD-NAME= exists, return
    =~/OLD-NAME=.

  else return =NEW-NAME= in ~user-emacs-directory~,  creating the directory if it
  does not exist.
#+END_defun

*** Must Do’s
**** Add to Init File

- install MELPA and ORG repositories ::
  1. http://melpa.org/#/getting-started
  2. ~(add-to-list ’package-archives (cons "melpa" "https://melpa.org/packages/") t)~
  3. https://orgmode.org/
  4. ~(add-to-list 'package-archives (cons "org"   "https://orgmode.org/elpa")    t)~

- Set Default Frame Size ::
  : (setq default-frame-alist '((top . 10) (left . 10) (width . 300) (height . 150)))

- Inhibit the Startup Screen ::
  1. M-x customize-group RET Initialization group
  2. Inhibit Startup Screen: “t”

- Set Mac Command key to Emacs Meta ::
  1. M-x customize-group RET ns
  2. Ns Command Modifier: “meta”
  3. Ns Alternate Modified: “No modifier”

- Set Global line number mode and column number mode ::
  1. M-x customize-group RET global-linum
  2. Global Linum Mode: “t”
  3. M-x customize-group RET mode-line
  4. Column Number Mode: “t”

- Set Show Paren mode ::
  1. M-x customize-group RET paren matching

- Set show-trailing-whitespace ::
  1. M-x customize-group RET Editing Basics
  2. Show Trailing Whitespace: “t”

- Set Electricity Group ::
  1. M-x customize-group RET electricity

- Set Icomplete mode ::
  1. M-x customize-group RET Icomplete
  2. Icomplete mode: “t”

- Set up Calendar date style to ISO (for Org-mode time stamps) ::
  1. M-x customize-group RET Calendar group
  2. Calendar Date Style: ISO

**** Must-Have Packages

- Org Mode ::
  - https://orgmode.org/

  - M-x ~package-refresh-contents~ ::
  - M-x ~package-list-packages~ ::
  - Find Org and install :: current version is now 9.3.6
  - Install global key bindings ::
    - ~org-store-link~ :: (global-set-key (kbd “C-c l”) 'org-store-link)
    - ~org-agenda~ :: (global-set-key (kbd “C-c a”) ’org-agenda)
    - ~org-capture~ :: (global-set-key (kbd “C-c c”) ’org-capture)
    - ~org-switchb~ :: (global-set-key (kbd “C-c b”) ’org-switchb)
  - Set up Org Babel :: Babel group
    - ~org-babel-load-languages~ ::
      - shell
      - perl
      - js
    - ~org-confirm-babel-evaluate~ ::
      - set to ’nil’
  - Set up Org Export Backends ::
    - M-x customize-group RET Org Group
    - Org Export Backends: texinfo, md
  - Set up Org Indent Mode for cleaner view ::
    - M-x customize-group RET Org Structure group
      - Org startup indented : “t”
  - Set up auto-fill-mode for Org mode file ::
    - ~(add-hook 'org-mode-hook 'auto-fill-mode)~
  - Set up time-stamp ::
    - ~(add-hook ’org-mode-hook 'time-stamp)~

- Magit Mode ::
  - https://magit.vc/

  - M-x ~package-refresh-contents~
  - M-x ~package-list-packages~
  - Find Magit and install---current version is now
    : Magit 20200217.135, Git 2.17.2 (Apple Git-113), Emacs 27.0.50, darwin
  - Install global key bindings to work with Magit from any buffer
    a. ~(global-set-key (kbd "C-x g") 'magit-status)~
    b. ~(global-set-key (kbd "C-x M-g") 'magit-dispatch)~

**** Start the Emacs server
- from ~/.bash_profile: ~/Applications/MacPorts/Emacs.app/Contents/MacOS/Emacs --daemon~
- from ~/.bash_profile: ~EDITOR=emacsclient~

*** Init File

- ~user-init-file~ :: File name,  including directory, of user’s initialization
  file.

- ~init-file-user~ :: Identity of user whose init file is or was read.

  The value is =nil= if ‘-q’  or ‘--no-init-file’ was specified, meaning do not
  load any init file.

  Otherwise, the value  may be an empty  string, meaning use the  init file for
  the user who originally logged in, or  it may be a string containing a user’s
  name meaning use that person’s init file.

  In either of the latter cases, ~(concat "~" init-file-user "/")~ evaluates to
  the name of the directory where the init file was looked for.

**** Init File Examples
- https://github.com/skeeto/.emacs.d

*** Configuring Backups
When configured, Emacs saves the old contents of a file you are working on in a
backup file  before saving the  contents of  the newly-changed buffer  into the
file, but  only for the first  save of the buffer.  If you kill the  buffer and
then visit  the file again,  a new backup  fill will be  made upon a  new save.
However, this behavior  can be overridden manually by  adding different numbers
of =C-u= ‘s when saving.

- ~make-backup-files~ :: Variable that determines whether to make backup files.
  It’s default value is =t=.

- ~backup-directory-alist~ :: Variable that  determines where backups should be
  saved based  upon regexps. Emacs  creates the directories when  necessary. No
  files are overwritten because of name clashes.

  - ~("." . DIR)~ :: make all backups in the directory DIR.
  - ~("." .  ".~")~ :: make backups  in the invisible subdirectory  =.~= of the
    original file’s directory.

- ~save-buffer~ :: Save current buffer in visited file if modified.

  These are the possible variations that affect when backups are created::

  - =C-x C-s= :: save the buffer in its associated file.
  - =C-u C-x C-s= :: mark the file to be backed up on the next save.
  - =C-u C-u C-x C-s= :: save the buffer and make a backup file immediately.
  - =C-u C-u C-u C-x C-s= :: Do both of the above.
  - =M-0 C-x C-s= :: Never make the previous version into a backup file.

- ~version-control~ ::  Variable that  determines whether numbered backup files
  are  produced. It  can be  set  globally as  well as  locally for  individual
  buffers. This variable  can also be set according to  an environment variable
  called =VERSION_CONTROL=.

  - when =nil=  :: origin value;  make numeric  backup versions for  files that
    already have some; otherwise not.

  - when =never= :: never make numeric backup versions.

  - when =t== :: make numeric backup versions unconditionally.

- Deleting excessive backups ::
  Emacs can save a  certain number of old file backups and  a certain number of
  new  file backups,  deleting the  ones in  between, using  the following  two
  variables:

  - ~kept-old-versions~ :: Variable that determines how many oldest versions to
    keep (default = 2).

  - ~kept-new-versions~ :: Variable that determines how many newest versions to
    keep (default = 2).

  - ~delete-old-versions~ :: Variable that determines whether backups will be
    deleted silently or only upon confirmation.

    - =nil=  ::  Emacs  queries  whether   to  delete  excess  backup  versions
      (default);

    - =t= :: Emacs deletes excess backup files silently.

  - Dired’s =.= :: (period) command can be used to delete old versions.

- ~make-backup-file-name-function~ :: Holds an  elisp procedure to override the
  usual way Emacs constructs backup file names.

*** Configuring File Name Completion
If you have changed your system's case-sensitivity setting[fn:1], have a look
at file name completion, [[ignore-case-variables][ignore case sensitivity]]:
*** Enabling Your Trash

#+vindex:delete-by-moving-to-trash
- [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]]


#+begin_src emacs-lisp :exports results
  (with-output-to-string
    (princ "Your value of 'delete-by-moving-to-trash' is currently: ")
    (princ delete-by-moving-to-trash))
#+end_src

#+cindex:Trash
#+cindex:delete using Trash
By default, Emacs =deletion= commands do not use the =Trash= facility.  To use
the =Trash= facility (when it is available) for common deletion commands,
change the variable [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] to =t=.  This affects the
commands =M-x delete-file= [[*delete-file][delete-file]] and =M-x delete-directory=
[[*delete-directory][delete-directory]] (see Directories), as well as the deletion commands in =Dired=
(see Dired Deletion).
*** Package Manager
*** Evaluating Lisp
*** Emacs Files
- ~user-emacs-directory~ :: Variable; default value is =~/.emacs.d/=.

  Directory beneath which additional  per-user Emacs-specific files are placed.
  Various programs in Emacs store information in this directory.

- ~locate-user-emacs-file~ :: Function

  #+attr_texinfo: :options locate-user-emacs-file new-name [old-name]
  #+begin_defun
  Return an absolute per-user Emacs-specific file name.

  If NEW-NAME exists in ‘user-emacs-directory’, return it.

  Else if OLD-NAME is non-nil and ~/OLD-NAME exists, return ~/OLD-NAME.

  Else return NEW-NAME in ‘user-emacs-directory’, creating the directory if it
  does not exist.
  #+end_defun
** Customizing
*** Customization File
The following variable is user-customizable:

<<custom-file-defvar>>
#+attr_texinfo: :options custom-file
#+begin_defvar
File used  for storing customization  information. The default is  =nil=, which
means to use your  init file as specified by ~user-init-file~.  If the value is
not =nil=, it should be an absolute file name.

While you can use  Customize to set this option, it is easier  and safer to use
the following procedure.  Instead of using Customize, write  something like the
following in your init file:

: (setq custom-file "~/.emacs.d/custom/.emacs-custom.el")
: (load custom-file)

When you change this variable outside  Custom, look in the previous custom file
(usually  your  init  file)  for the  forms  ‘(custom-set-variables  ...)’  and
‘(custom-set-faces ...)’,  and move them (whichever  ones you find) to  the new
custom file. This will preserve your existing customizations.
#+end_defvar

*** Configuring the Emacs Frame Height
- See [[http://irreal.org/blog/?p=1331][More on Setting the Emacs Frame Height]]
*** Custom Indexing Command
#+header_args: :eval no
**** insert-cindex
#+begin_src emacs-lisp
(defun insert-cindex ()
  "Insert #+cindex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+cindex:"))
(global-set-key (kbd "C-c I") 'insert-cindex)
#+end_src

**** insert-pindex
#+begin_src emacs-lisp
(defun insert-pindex ()
  "Insert #+pindex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+pindex:"))
(global-set-key (kbd "C-c P") 'insert-pindex)
#+end_src

**** insert-vindex
#+begin_src emacs-lisp
(defun insert-vindex ()
  "Insert #+vindex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+vindex:"))
(global-set-key (kbd "C-c V") 'insert-vindex)
#+end_src

**** insert-findex
#+begin_src emacs-lisp
(defun insert-findex ()
  "Insert #+findex: in an Orgmode document."
  (interactive)
  (insert-char #x0a)
  (indent-according-to-mode)
  (insert "#+findex:"))
(global-set-key (kbd "C-c F") 'insert-findex)
#+end_src
*** Custom Themes
#+findex:customize-themes
#+cindex:color themes
This section summarizes some information from

- [[info:emacs#Custom Themes][Custom Themes]]


The following variable is user-customizable:

- [[custom-theme-directory-defvar][custom-theme-directory]]


#+texinfo: Installed Color Themes

To see a list of installed color themes, and to try them out, use:

- =M-x customize-themes=


#+texinfo: @heading Install Color Themes using Package Manager

To install a theme with the package manager, look for themes in the list.  Most
have the suffix =-theme=, and they act and install like normal packages.

- =M-x package-list-packages=


#+texinfo: @heading Install New Color Themes by Hand

There are  more available for free  from Emacs’s package manager  or sites like
Github.  To  install  new  themes  by   hand,  add  =THEME=.el  files  to  your
[[custom-theme-directory-defvar][custom-theme-directory]] and  then issue the forgoing  ~customize-themes~ command
or alternatively, add the following theme command to your init file:

: (load-theme 'theme t)

You  can  override  specific  colors  you  don’t  like  by  using  the  regular
=Customize= interface described in /The  Customize Interface/.  Changes made in
the =Customize= interface take precedence over the themes.

**** Custom Theme Variables

<<custom-theme-directory-defvar>>
#+attr_texinfo: :options custom-theme-directory
#+begin_defvar
Variable defined in ~custom.el~.

Default user  directory for storing custom  theme files. It’s current  value is
~$HOME/.emacs.d/themes~.

The command [[customize-create-theme-defun][customize-create-theme]]  writes theme files into  this directory. By
default,  Emacs  searches  for  custom  themes in  this  directory  first.  See
~custom-theme-load-path~, next.
#+end_defvar

#+attr_texinfo: :options custom-theme-load-path
#+begin_defvar
Variable defined in ~custom.el~. This variable is designed for use in lisp code
(including   external   packages).   For  manual   user   customizations,   use
~custom-theme-directory~ instead.

List of directories to search for  custom theme files. Emacs searches for theme
files in the specified order.  Each element in the list should be one of:

- ’custom-theme-directory (meaning use its value)
- ’t (meaning value of the built-in theme directory, $data-directory/themes/)
- a string naming a directory
#+end_defvar

#+attr_texinfo: :options custom-safe-themes
#+begin_defvar
Variable defined in ~custom.el~

Variable holding list of themes (actually their SHA-256 has) that are considerd
safe to load, or the value =t=, meaning consider all themes as safe. The symbol
'default means to consider all themes in ~$data-directory/themes~ as safe.
#+end_defvar

#+attr_texinfo: :options custom-enabled-themes
#+begin_defvar
Variable defined in ~custom.el~.

List of  enabled Custom Themes,  highest precedence  first. This list  does not
include the ‘user’ theme, which is set by Customize and always takes precedence
over other Custom Themes.

Setting this variable through  =Customize= calls ~enable-theme~ or ~load-theme~
for each theme in the list.
#+end_defvar
**** Custom Theme Procedures

#+attr_texinfo: :options custom-file &optional no-error
#+begin_defun
Compiled lisp function in ~cus-edit.el~.

Return the file name for saving customizations.
#+end_defun

#+attr_texinfo: :options customize-themes &optional buffer
#+begin_defun
Autoloaded interactive compile lisp function in ~cus-theme.el~.

Display a selectable list of custom themes.

- BUFFER :: buffer to use when called from lisp, or if omitted,
  then use a buffer named ~*Custom Themes*~.
#+end_defun

#+attr_texinfo: :options load-theme theme &optional no-confirm no-enable
#+begin_defun
Interactive compiled lisp function in ~custom.el~.

Load the custom theme named =THEME= from its file (=THEME=~-theme.el~) found in
one of the directories specified by ~custom-theme-load-path~.

- NO-CONFIRM ::

  When loading,  Emacs will take into  consideration the value of  the variable
  ~custom-safe-themes~ unless  @@texinfo:@var{@@NO-CONFIRM@@texinfo:}@@ is =t=,
  in which case Emacs will load the theme without prompting.

- NO-ENABLE ::

  Emacs will enable the @@texinfo:@var{@@theme@@texinfo:}@@ unless the variable
  @@texinfo:@var{@@no-enable@@texinfo:}@@  is =t=.  Enabling a  theme DOES  NOT
  disable   any   already-enabled  theme.   To   disable   other  themes,   use
  ~disable-theme~.


This function is normally called  through Customize when setting custom-enabled
themes. See ~custom-enabled-themes~ for a list of enabled themes.
#+end_defun

#+attr_texinfo: :options load-theme theme
#+begin_defun
Interactive compiled lisp function in ~custom.el~.

Reenable     all     variable     and      face     settings     defined     by
@@texinfo:@var{@@theme@@texinfo:}@@.

- THEME ::   @@texinfo:@var{@@theme@@texinfo:}@@ should  be either =user=, or a
  theme   loaded    via   ~load-theme~.   After   this    function   completes,
  @@texinfo:@var{@@theme@@texinfo:}@@  will have  the  highest precedence  (after
  =user=)  among enabled  themes.  See ~custom-enabled-themes~  for  a list  of
  enabled themes.
#+end_defun

#+attr_texinfo: :options disable-theme theme
#+begin_defun
Interactive compiled lisp function in ~custom.el~.

Disable     all      variable     and     face     settings      defined     by
@@texinfo:@var{@@theme@@texinfo:}@@.
#+end_defun

<<customize-create-theme-defun>>
#+attr_texinfo: :options customize-create-theme &optional theme buffer
#+begin_defun
Autoloaded interactive compilded lisp function in ~cus-theme.el~.

Create or edit a custom theme.

- THEME  ::    @@texinfo:@var{@@theme@@texinfo:}@@, if  non-=nil=, should be an
  existing theme to edit. If @@texinfo:@var{@@theme@@texinfo:}@@ is =user=, the
  resulting ~*Custom Theme*~  buffer also contains a checkbox  for removing the
  theme settings specified in the buffer from the Custom save file.

- BUFFER  ::   @@texinfo:@var{@@buffer@@texinfo:}@@, if non-=nil=, should  be a
  buffer to use; the default is named ~*Custom Theme*~.
#+end_defun
*** Various Starter Packs
**** Emacs Live
An opinionated  set of defaults  for getting started  with a specific  focus on
live coding with Overtone and Quil.

- [[http://overtone.github.io/emacs-live/][emacs-live Home]]
- [[https://github.com/overtone/emacs-live][emacs-live on GitHub]]
*** Advanced Customization Examples
**** Bastien Guerry
- https://github.com/bzg/dotemacs/blob/master/emacs.org
*** Environment Variables
#+cindex:environment variables
**** Initial Environment
#+ATTR_texinfo::options initial-environment
#+BEGIN_defvar
  =initial-environment= is a  list of environment variables  inherited from the
  parent process. Each element should be a string of the form 'ENVVARNAME=VALUE'.
#+END_defvar

**** Executable Programs Environment
#+cindex:executable programs
#+vindex:exec-path
#+vindex:PATH env var
Emacs searches for  an executable program name in directories  specified by the
variable  =exec-path=.  This  variable holds  a list  of directories,  with the
default value being initialized from the environment variable =PATH= when Emacs
is started.

#+TEXINFO: @heading Value of @code{exec-path}

#+CAPTION: Value of ~exec-path~
#+NAME: value-of-exec-path
#+HEADER: :results value list :exports results
#+begin_src elisp
(exec-path) 
#+end_src

#+TEXINFO: @heading Value of @code{$PATH}

#+CAPTION: Value of $PATH Env Var
#+NAME: value-of-path-env-var
#+HEADER: :results value :exports results
#+begin_src elisp
(getenv "PATH")
#+end_src

** Starting
*** Starting the Emacs Server
#+cindex:@var{EDITOR}
By convention, your choice of editor is specified by the environment variable
=EDITOR=.  If you set =EDITOR= to ‘emacs’, Emacs would be invoked, but in an
inconvenient way---by starting a new Emacs process.  This is inconvenient
because the new Emacs process doesn't share buffers, a command history, or
other kinds of information with any existing Emacs process.

You can solve this problem by setting up Emacs as an edit server, so that it
“listens” for external edit requests and acts accordingly.  There are various
ways to start an Emacs server:

- Run the command ~server-start~ from within a process, either interactively as
  =M-x server-start=, or from within your =INIT= file as ~(server-start)~.  The
  existing Emacs process is the server.

- Run Emacs as a daemon by invoking Emacs from the command line with a
  @@texinfo:@option{@@--daemon@@texinfo:}@@ option.  When Emacs is started this
  way, it calls ~server-start~ after initialization and does not open an
  initial frame.  It then waits for edit requests from clients (using
  ~emacsclient~).

  - ~-daemon~

  - ~--daemon[=name]~

  - ~--bg-daemon[=name]~ ::

    A “background” daemon disconnects from the terminal and runs in the
    background (~--daemon~ is an alias for ~bg-daemon~).

    To kill a daemon session, type =M-x kill-emacs=.

  - ~--fg-daemon[=name]~

  - ~emacsclient~ ::

    Once an Emacs server is started, you can use a shell command called
    ~emacsclient~ to connect to the Emacs process and tell it to visit a file.
    You can then set the =EDITOR= environment variable to ‘emacsclient’, so
    that external programs will use the existing Emacs process for editing.

    - ‘-s server-name’ or ‘--socket-name=server-name’ Connect to the Emacs
      server named =server-name=.  The server name is given by the variable
      server-name on the Emacs server. If this option is omitted, ~emacsclient~
      connects to the first server it finds.

** Interface
* Keys
** Control
** Extended
** Universal
** Remembering Keys
** Mastering Key Bindings in Emacs
- https://www.masteringemacs.org/article/mastering-key-bindings-emacs


There’s a reason why the Emacs manual has dedicated 30-odd pages to describing,
in great detail, all the subtleties and nuances of how to bind keys.  I’ve
written a guide that covers what you need to know to bind keys to even complex
commands, and a set of templates you can use in your own code.

*** Key Sequences
A {{{dfn(key sequence)}}} (=key= for short), is a sequence of one or more input
events  that  is  meaningful  as   a  unit.   {{{dfn(Input  events)}}}  include
characters, function keys, and mouse buttons---al  the inputs that you can send
to the computer.  A key sequence gets its meaning from its "binding", which say
what command  it runs.  If  a key  sequence invokes a  command, it is  called a
{{{dfn(complete  key)}}}.  If  a key  sequence isn’t  long enough  to invoke  a
command, it is called a {{{dfn(prefix  key)}}}.  Every key sequence is either a
complete key or a prefix key.

A prefix key  combines with the following  input event to to make  a longer key
sequence.  After a  prefix key is entered, Emacs waits  for further input.  The
combination might be another prefix key, or  a complete key.  There is no limit
to the  length of key  sequences, but in practice  they are seldom  longer than
three or four input events.  An input  event cannot be combined with a complete
key.

**** Default Prefix Keys
The default prefix keys in Emacs are:
- =C-c=
- =C-h= & =<F1>=
- =C-x=
- =C-x <RET>=
- =C-x @=
- =C-x a=
- =C-x n=
- =C-x r=
- =C-x t=
- =C-x v=
- =C-x 4=
- =C-x 5=
- =C-x 6= & =<F2>=
- =<ESC>=
- =M-g=
- =M-o=


You can make new prefix keys by customizing Emacs.

*** Keymaps
#+cindex:keymap
Emacs  does not  assign  meanings  to keys  directly.   Instead, Emacs  assigns
meanings to named  “commands”, and then gives keys their  meanings by “binding”
them  to commands.   The bindings  between keys  and commands  are recorded  in
tables  called "keymaps."   Emacs  has  many different  keymaps,  each used  on
particular occasions.

A {{{dfn(keymap)}}} is  an internal data structure used by  Emacs to store keys
and  their  associated actions.   Keymaps  are  rarely modified  directly,  but
through a set of commands that manipulate the data structure for you.

Every buffer  and most  major and minor  modes have a  keymap, and  that keymap
defines what the keys do when key  sequences are sent to that buffer.  Keys can
be divided into three categories:

#+cindex:prefix key
#+cindex:key, prefix
#+cindex:complete key
#+cindex:key, complete
- undefined :: self-explanatory
- prefix key :: are parts of a complete key, and each constituent part of a
                prefix key is made up of its own keymap
- complete key :: a command that, when input, executes its associated command


#+cindex:keys, show all
To enumerate all the active minor and major mode key bindings in a buffer,
type:

- =C-h m=


If you know part of a key sequence, type out that part, then type the following
to get a list of all keys that belong to that sequence.

- =C-h=


**** Global Keymap
The  “global” keymap  is the  most  important keymap  because it  is always  in
effect.  The  global keymap defines  keys for  Fundamental mode; most  of these
definitions are common  to most or all  major modes.  Each major  or minor mode
can have its own keymap which overrides the global definitions of some keys.

Commands to rebind keys, such as  ‘M-x global-set-key’, work by storing the new
binding  in the  proper place  in  the global  map.   To view  the current  key
bindings, use the ‘C-h b’ command.
*** Key Bindings
{{{dfn(Key  binding)}}}  means  to  map keys  to  commands.   "Keymaps"  record
keybindings.  Modes define  their own key bindings, so activating  a mode might
override custom key bindings.

A small number of keys are reserved for user-defined bindings and should not be
used  by modes.   The  reserved key  sequences are  those  consisting of  =C-c=
followed  by  a  letter,  and  function  keys  =<F5>=  through  =<F9>=  without
modifiers.

There are several ways you can define (or undefine) keys.

- ~(define-key KEYMAP KEY DEF)~ ::

     #+cindex:@code{define-key}
     #+cindex:keyboard map
     #+cindex:keymap, keyboard
     Defines a key against a keyboard map.  Use this if you want to change a
     keymap that isn’t the current buffer map.

- ~(local-set-key KEY COMMAND)~ ::

     #+cindex:@code{local-set-key}
     #+cindex:local keymap
     #+cindex:keymap, local
     Binds a key to the local keymap used by the active buffer, unlike
     ~define-key~ which takes an explicit keymap to bind a key against.

- ~(global-set-key KEY COMMAND)~ ::

     #+cindex:@code{global-set-key}
     #+cindex:global keymap
     #+cindex:keymap, global
     Binds a key to the global keymap, making it available in all buffers (with
     a caveat---see below.)

- ~(global-unset-key KEY)~ ::

     #+cindex:@code{global-unset-key}
     #+cindex:global keymap
     #+cindex:keymap, global
     Removes KEY from the global keymap

- ~(local-unset-key KEY)~ ::

     #+cindex:@code{local-unset-key}
     #+cindex:local keymap
     #+cindex:keymap, local
     Removes KEY from the active, local keymap.

*** Representing Keys in Code
{{{heading(@@texinfo:@code{@@kbd@@texinfo:}@@)}}}

#+cindex:key as string, vector
#+cindex:vector key
#+cindex:@code{kbd} macro
In order to actually bind a key you must first tell Emacs what key you intend
to use.  Unfortunately there’s more than one way of representing keys in Emacs:
as a /string/, or as a /vector/.  There is a macro built in to Emacs called
{{{dfn(kbd)}}}, which translates a human-readable key into a format Emacs can
understand.

{{{heading(Function and Navigation Keys)}}}

One important point to note is that you must surround /function/ and
/navigation/ keys with =<= and =>=.  Those keys include F-keys, arrow keys and
home row keys, like so: =<home>=, =<f8>= and =<down>=.  But if you want to
represent the key =C-c p= then write ~(kbd "C-c p")~.

*** Remapping Commands
{{{heading(@@texinfo:@code{@@remap@@texinfo:}@@---Replace)}}}

#+cindex:@code{remap} event
#+cindex:@code{define-key} command
You can tell Emacs that you want to /replace/ all keys pointing to a certain
command with one of your own choosing by using the ~remap~ event; this should
be done instead of passing a key to the key bind function you are using.  This
is arguably the best way of replacing existing commands with your own as Emacs
will automagically handle the key reassignment in the background.

: (define-key (current-global-map) [remap kill-line] 'my-homemade-kill-line)

Here I globally remap all key binds that point to ~kill-line~ to
~my-homemade-kill-line~.

#+cindex:transient mark mode
For some more hands-on examples read my article [[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode][Fixing the Mark Commands in Transient Mark Mode]].

*** Reserved Keys
You can pick any keyboard combination you desire---even if that key bind is
already taken, so be careful.  But Emacs has set aside certain keys for use by
users.  Generally, all keys prefixed with =C-c ?= (where =?= is a single
character) are reserved for you, and you alone.  In practice most third-party
packages don’t give a hoot and will gladly stuff their own key binds in there.

The other set of reserved keys are the F-keys from =F5= and onwards.

{{{heading(Hyper and Super Prefix Keys)}}}

#+cindex:hyper key
#+cindex:super key
The other two prefix keys reserved to you are =hyper= and =super=.  They are
remnants from ancient keyboards used in the 80s, but live on today in Emacs.
Most PC-compatible keyboards won’t have a =super= or =hyper= key so some people
rebind the Windows key and the Application Context key to be =hyper= and
=super= instead.

#+caption:Symbolics's lisp machine keyboard PN 365407 Rev C. (Photo by Joey Devilla.)
#+name:fig-lisp-machine-super-hyper-keys
[[file:resources/images/lisp-machine-keyboard-2-left.jpg]]

[fn::From http://ergoemacs.org/emacs/emacs_hyper_super_keys.html]

- See [[http://ergoemacs.org/emacs/emacs_hyper_super_keys.html][Emacs: How to Bind Super Hyper Keys]].

- See [[http://irreal.org/blog/?p=1450][A Hyper Key for the Mac]]


If you want to use =hyper= then use the prefix key =H-= (e.g., =H-q=) and if
you want =super= use the prefix key =s-= (lower case).


{{{heading(On Mac OS X)}}}

#+caption:set keys for Apple keyboard, for emacs in OS X
#+name:set-keys-mac-os-x
#+begin_src emacs-lisp
;; set keys for Apple keyboard, for emacs in OS X
(setq mac-command-modifier 'meta) ; make cmd key do Meta
(setq mac-option-modifier 'super) ; make opt key do Super
(setq mac-control-modifier 'control) ; make Control key do Control
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper
#+end_src

* Movement

Movement in Emacs is more than characters in a buffer; there’s a host of
supplementary skills that make up navigation, like:

#+cindex:windowing system
- understanding Emacs’s rather complicated windowing system

- movement in Emacs is /local/, /regional/ or /global/.
  #+cindex:local movement
- /local movement/ is what you do when you edit and move around text near to
  the point.
  #+cindex:syntactic unit
- A /syntactic unit/ --- a semi-formal term for commands that operate on a
  group of characters --- is a character, word, line, sentence, paragraph,
  balanced expression, and so forth.
  #+cindex:regional movement
- /regional movement/ involves whole functions or class definitions, if you are
  writing code; or chapters and such constructs, if you are writing prose.
  #+cindex:global movement
- /global movement/ is anything that takes you from one buffer to another, or
  from one window to the next.

#+texinfo:@heading Windows

#+cindex:windows
#+cindex:tiling window manager
Emacs has a penchant for creating windows: when you view a help file, when you
compile a file, or when you open a shell.  Emacs is a /tiling window manager/.

In Emacs, windows are transient; they come and go as you need them.  You can
save your window configuration (and there are several ways of doing this) but
they were never meant to be immutable, like so many editors --- set once and
then never changed again.

#+texinfo:@heading Buffers

#+cindex:buffers
Buffers are rarely killed (that is, closed) when they are no longer needed;
most Emacs hackers will simply switch away to something else, only to return to
it when needed.  That may seem wasteful, but each buffer (aside from assorted
metadata and the buffer’s particular coding system) is only slightly bigger
than the byte size of the characters in it.  A typical Emacs session lasts
weeks between restarts and most Emacs hackers have many hundreds of buffers
running without issue.

** List of Syntactical Elements
- =char= ::

  - ~left-char~ (=C-f=), ~right-char~ (=C-b=)

- =word= ::

  - ~forward-word~ (=M-f=) (=C-<right>=), ~backward-word~ (=M-b=) (=C-<left>=)

- =line= ::

  #+findex:line-move-visual
  #+cindex:logical line
  #+cindex:Visual Line Mode
  #+cindex:visual line
  #+findex:toggle-truncate-lines
  #+findex:toggle-word-wrap
  - *visual*, *screen* --- what you see; the default way to move
    - =Visual Line Mode= wraps by /word boundaries/
    - =M-x customize-option RET global-visual-line-mode=
  - *logical* --- what Emacs sees
    - =M-x customize-option RET line-move-visual nil= --- move by logical lines
    - ~toggle-truncate-lines~
    - ~toggle-word-wrap~

  - ~next-line~ (=C-n=), ~previous-line~ (=C-p=)
  - ~beginning-of-line~ (=C-a=) (=<home>=), ~end-of-line~ (=C-e=) (=<end>=)
  - ~forward-line~
  - ~back-to-indentation~ (=M-m=)

** The Basics
Learning the basic key bindings to:

- find and save files,
- change buffers, and
- the bare essentials of day-to-day use


{{{noindent}}}is the first step on the path to mastering Emacs.

#+caption:Basic Commands
#+name:basic-commands
| Key Binding | Command                      | Purpose                                     |
|-------------+------------------------------+---------------------------------------------|
| C-x C-f     | ~find-file~                  | Find and open a file                        |
| C-x C-s     | ~save-buffer~                | Save the buffer                             |
| C-x b       | ~switch-to-buffer~           | Switch buffer                               |
| C-x k       | ~kill-buffer~                | Kill (close) a buffer                       |
| C-x C-b     | ~list-buffers~               | Display all open buffers                    |
| C-x C-c     | ~save-buffers-kill-terminal~ | Exit Emacs                                  |
| esc-esc-esc | ~keyboard-escape-quit~       | Exit the current mode; return to one window |
| C-/         | ~undo~                       | Undo changes                                |
| F-10        | ~menu-bar-open~              | Activate the menu bar                       |
|-------------+------------------------------+---------------------------------------------|

*** find-file =C-x C-f=
#+findex:find-file
To *open* a file is to /find/ or /visit/ it.  The two are synonymous.  If the
file does not exist, Emacs will open an empty buffer associated with that
filename.  If the file exists, Emacs will place the contents into a buffer
associated with that filename.

#+texinfo:@heading Major Mode Load Order

When you visit a file, Emacs will pick a major mode.  Emacs supports an array
of detection mechanisms that can all be changed to suit your needs.  They are
listed here in the order they are applied.

**** File-local variables

**** Program loader directives

**** Magic mode detection

**** Automatic mode detection

*** Coding Systems and Line Endings
Emacs applies two other important heuristics you should know about:
- coding systems and
- line endings.

**** Coding Systems
#+cindex:coding system
Emacs has excellent Unicode support, including:
- transparently reading and writing between different coding systems,
- bidirectional right-to-left script support,
- keyboard input method switching, and more.


#+findex:describe-coding-system
- ~describe-coding-system~ (=C-h C=) ::

  To see the coding system in use for the current buffer.  Emacs will display a
  lot of information, including all the coding systems associated with the
  buffer.  For files, they are almost always set to the same coding system.


The modeline will also provide some information:

: U:**-  helloworld.c       92% of 5k   ...

#+cindex:multi-byte
The first character, =U=, means the buffer ~helloworld.c~ has a *multi-byte*
coding system.

#+cindex:ISO character encoding
If it said =1=, it would typically be part 1 of any number of ISO character
encodings.  The exact mnemonic will depend on which of the hundreds of
supported coding systems you are using.

**** Line Endings
#+cindex:line endings
When you open a file, Emacs will determine the line endings used.

#+cindex:DOS line endings
#+cindex:UNIX line endings
If the file uses DOS or UNIX line endings, they will be preserved when you open
and save a file.

The modeline will tell you what line ending you are using:

: U:**-  helloworld.c       92% of 5k   ...

The : means it’s UNIX-style line endings.  For DOS it would say =(DOS)=.

** Window Management

** Frame Management

** Elemental Movement
*** Navigation Keys---Arrow Keys Etc
Arrow keys move  by character; can combine the arrow  keys with the =<control>=
key to move by word.

- =<left>=, =C-<left>=
- =<right>=, =C-<right>=
- =<up>=, =C-<up>=
- =<down>=, =C-<down>=
- =<insert>=: activate =overwrite-mode=
- =<delete>=: delete character after point
- =<prior>=, =<next>=: Page-up, Page-down move by full page
- =<home>=, =<end>=: Move to beginning, end of  line

#+attr_texinfo: :options next-screen-context-lines
#+begin_defvar
Variable  controlling  number   of  lines  of  continuity   when  scrolling  by
screenfuls; default is 2.
#+end_defvar

 *** Moving by Character
|-----------------------+-------------+-------------------------------------------|
| Command               | Key Binding | Purpose                                   |
|-----------------------+-------------+-------------------------------------------|
| ~forward-char~        | =C-f=       | Forward character                         |
| ~backward-char~       | =C-b=       | Backward character                        |
| ~next-line~           | =C-n=       | Next (visual) line                        |
| ~previous-line~       | =C-p=       | Previous (visual) line                    |
|-----------------------+-------------+-------------------------------------------|
| ~point~               |             | return the value of point                 |
| ~point-min~           |             | minimum possible value of point           |
| ~point-max~           |             | maximum possible value of point           |
| ~buffer-end~          |             | return the far-end position of buffer     |
| ~buffer-size~         |             | return the number of characters in buffer |
|-----------------------+-------------+-------------------------------------------|
| ~goto-char~           |             | Set point to =POS=                        |
| ~forward-char~        |             | Move point =COUNT= chars foward           |
| ~backward-char~       |             | Move point =COUNT= chars backward         |
|-----------------------+-------------+-------------------------------------------|
| ~skip-chars-forward~  |             |                                           |
| ~skip-chars-backward~ |             |                                           |
|-----------------------+-------------+-------------------------------------------|

*** Moving by Line
|---------------------------+------------------+-------------------------------------------------|
| Command                   | Key Binding      | Purpose                                         |
|---------------------------+------------------+-------------------------------------------------|
| ~beginning-of-line~       | =C-a= / =<home>= | Beginning of line                               |
| ~end-of-line~             | =C-e= / =<end>=  | End of line                                     |
| ~back-to-indentation~     | =M-m=            | First character on line                         |
| ~forward-line~            |                  | Move N lines forward (no error)                 |
|                           |                  | Return COUNT of lines left to move              |
| ~vertical-motion~         |                  | Moves point to start of the screen line         |
|---------------------------+------------------+-------------------------------------------------|
| ~line-beginning-position~ |                  | Return char pos of first character              |
| ~line-end-position~       |                  | Return char pos of last character               |
| ~count-lines~             |                  | Return no. lines between START and END          |
| ~line-number-at-pos~      |                  | Return line number of posotion POS              |
|---------------------------+------------------+-------------------------------------------------|
| ~bolp~                    |                  | Return t if point is at the beginning of a line |
| ~eolp~                    |                  | Return t if point point is at the end of a line |
|---------------------------+------------------+-------------------------------------------------|

Text  lines are  portions  of  the buffer  delimited  by =newline=  characters.
=newline= characters are regarded as part of the previous line.

The first text  line begins at the  beginning of the buffer, and  the last text
line ends  at the end  of the buffer,  whether or not  the last character  is a
newline.

**** Lines
- Visual :: physical lines; "what you see"
- Screen :: identical to visual line
- Logical :: buffer lines; opposite of visual or screen lines

#+attr_texinfo: :options line-move-visual arg &optional noerror
#+begin_defun
  Move =ARG= lines forward.
#+end_defun

#+attr_texinfo: :options line-move-visual
#+begin_defvar
  When non-=nil=, ‘line-move’ moves point by /visual lines/.

  If =nil=, ‘line-move’ moves point by /logical lines/.
#+end_defvar

**** Visual Line Mode
A  minor mode  that  builds on  the  concept of  visual  lines with  additional
functionality. *Visual Line Mode* wraps by word boundary resulting in “cleaner”
word wrapping  like what you’d see  in a traditional word  processor. The minor
mode will also disable the fringe indicators.

Additionally,  *Visual Line  Mode* replaces  a number  of movement  and editing
commands with  visual equivalents. =C-p=  and =C-n= will  behave as they  do in
default Emacs installations with the ~line-move-visual~ option enabled.

Furthermore, commands  like moving  to the  beginning and end  of a  line (with
=C-a= and =C-e=) now work on visual lines instead of logical lines.

The ~kill~ command (bound to =C-k=) will also work on visual lines.

#+attr_texinfo: :options visual-line-mode &optional arg
#+begin_defun
  Toggle visual line-based editing (*Visual Line mode*) in the current buffer.

  When *Visual Line mode* is enabled,  ‘word-wrap’ is turned on in this buffer,
  and simple editing commands are redefined to act on visual lines, not logical
  lines.
#+end_defun

#+attr_texinfo: :options global-visual-line-mode
#+begin_defun
  *Visual-Line mode* is enabled in all buffers where ‘turn-on-visual-line-mode’
  would do it.
#+end_defun

#+attr_texinfo: :options toggle-truncate-lines &optional ARG
#+begin_defun
  When truncating is off, long lines are folded.
#+end_defun

*** Moving by Word and Paragraph
|----------------------+---------------------+----------------------------------------|
| Command              | Key Binding         | Purpose                                |
|----------------------+---------------------+----------------------------------------|
| ~forward-word~       | =M-f= / =C-<left>=  | Forward word                           |
| ~backward-word~      | =M-b= / =C-<right>= | Backward word                          |
| ~forward-paragraph~  | =M-}=               | Next paragraph                         |
| ~backward-paragraph~ | =M-{=               | Previous paragraph                     |
| ~count-words~        |                     | Returns no. wods between START and END |
|----------------------+---------------------+----------------------------------------|

**** What Constitutes a Word

#+cindex:syntax table
Mode  writers make  assumptions  about the  nature  of the  text  in a  buffer.
Different modes  require different assumptions  about text. Every  character is
given a meaning by the mode author,  directly or indirectly, in a registry that
maps the characters to a particular  syntactic meaning. This registry is called
a /syntax table/.

- Syntax Table ::

  Every character ---  printable characters, including Unicode  code points ---
  are given a meaning by the mode author, directly or indirectly, in a registry
  that maps the characters to a  particular syntactic meaning. The syntax table
  keeps track of things like, "What characters are used for comments?" or "What
  characters make up  a word?" and, although obscured from  view, affects every
  part of Emacs.

  The syntax table alone decides the  makeup of a word (or symbol, punctuation,
  comment, etc.) as a syntactic unit. So  when you move the point around on the
  screen,  it  moves according  to  the  syntax  table  and the  general  rules
  governing ~forward-word~ and ~backward-word~.

  What sets Emacs apart  from other editors is that you  can inspect and change
  the syntax table, which  in turn will affect how your  point moves across the
  screen when you invoke certain commands.

  You can view your current buffer’s syntax  table by typing =C-h s=. In it you
  will see a human readable version of the characters and their assigned syntax
  class.

#+ATTR_texinfo: :options describe-syntax &optional buffer (C-h s)
#+BEGIN_defun
  Describe  the syntax  specifications in  the  syntax table  of =BUFFER=.  The
  descriptions are inserted in a help buffer, which is then displayed.

  - BUFFER :: defaults to the current buffer.
#+END_defun

Emacs will generally ignore non-word characters immediately following the point
in the direction you are travelling.

**** Sub- and Superword Movement---Glasses Mode
#+cindex:camel case
=Subword= mode ("camel case") is a buffer-local minor mode. Enabling it changes
the definition of  a word so that word-based commands  stop inside symbols with
mixed  uppercase and  lowercase letters,  e.g. "GtkWidget",  "EmacsFrameClass",
"NSGraphicsContext".

Here we  call these  mixed case symbols  ‘nomenclatures’. Each  capitalized (or
completely uppercase) part of a nomenclature is called a ‘subword’.

This  mode  changes the  definition  of  a word  so  that  word commands  treat
nomenclature boundaries as word boundaries.

#+ATTR_texinfo: :options subword-mode &optional arg
#+BEGIN_defun
  Toggle subword movement and editing (Subword mode).

  - ARG :: If  called from Lisp, toggle  the mode if =ARG=  is ‘toggle’. Enable
    the mode  if =ARG= is  nil, omitted, or is  a positive number.  Disable the
    mode if =ARG= is a negative number.
#+END_defun

#+cindex:snake case
=Superword=  mode ("snake  case") is  a  buffer-local minor  mode. Enabling  it
changes the  definition of words  such that  symbols characters are  treated as
parts of  words: e.g.,  in ‘superword-mode’,  "this_is_a_symbol" counts  as one
word.

#+ATTR_texinfo: :options superword-mode &optional arg
#+BEGIN_defun
  Toggle superword movement and editing (Superword mode).

  - ARG :: If  called from Lisp, toggle  the mode if =ARG=  is ‘toggle’. Enable
    the mode  if =ARG= is  nil, omitted, or is  a positive number.  Disable the
    mode if =ARG= is a negative number.
#+END_defun

#+TEXINFO: @subheading Glasses Minor Mode

#+ATTR_texinfo: :options glasses-mode &optional arg
#+BEGIN_defun
  Minor mode for making identifiers =likeThis= readable.

  When  this  mode  is  active,  it  tries  to  add  virtual  separators  (like
  underscores) at places they belong to.

  - ARG :: If  called from Lisp, toggle  the mode if =ARG=  is ‘toggle’. Enable
    the mode  if =ARG= is  nil, omitted, or is  a positive number.  Disable the
    mode if =ARG= is a negative number.
#+END_defun

#+TEXINFO: @heading Global Minor Modes

#+ATTR_texinfo: :options global-subword-mode &optional arg
#+BEGIN_defun
#+TEXINFO: @defunx global-superword-mode &optional arg
  Toggle Subword/Superword mode in all buffers.
  - ARG :: If called from Lisp, enable the mode if ARG is omitted or nil.
#+END_defun

**** What Constitutes a Paragraph
The paragraph commands rely on a set of variables that define the beginning and
end of a paragraph:

#+ATTR_texinfo: :options paragraph-start
#+BEGIN_defvar
  Regexp for  beginning of  a line  that starts  OR separates  paragraphs. This
  regexp  should match  lines that  separate paragraphs  and should  also match
  lines that start a paragraph (and are part of that paragraph).
#+END_defvar

#+ATTR_texinfo: :options paragraph-separate
#+BEGIN_defvar
  Regexp for beginning of a line that separates paragraphs.

  This specifies how to distinguish lines that start paragraphs from lines that
  separate them.
#+END_defvar

#+ATTR_texinfo: :options use-hard-newlines
#+BEGIN_defvar
  Non-nil   if   =Use-Hard-Newlines=  mode   is   enabled.   Use  the   command
  ‘use-hard-newlines’ to change this variable.
#+END_defvar

#+ATTR_texinfo: :options use-hard-newlines &optional arg insert
#+BEGIN_defun
  Toggle between hard and soft newlines in the current buffer.

  - hard newlines :: text-property ‘hard’ on newlines

  - soft newlines  :: Newlines  not marked  "hard" are  called "soft",  and are
    always internal  to paragraphs. The  fill functions insert and  delete only
    soft newlines.

  - ARG :: If  called from Lisp, toggle  the mode if =ARG=  is ‘toggle’. Enable
    the mode  if =ARG= is  nil, omitted, or is  a positive number.  Disable the
    mode if =ARG= is a negative number.

  - INSERT :: When  enabling, if there are  newlines in the buffer  but no hard
    newlines, ask  the user whether  to mark as  hard any newlines  preceding a
    ‘paragraph-start’  line.  From a  program,  second  arg =INSERT=  specifies
    whether to do this;
    - never :: to change nothing,
    - t /  always  :: to force  marking, ‘guess’ to  try to do the  right thing
      with no questions,
    - nil :: or anything else to ask the user.

  When enabled, the  functions ‘newline’ and ‘open-line’  add the text-property
  ‘hard’ to  newlines that  they insert,  and a  line is  only considered  as a
  candidate to match ‘paragraph-start’ or  ‘paragraph-separate’ if it follows a
  hard newline.
#+END_defun

#+ATTR_texinfo: :options paragraph-indent-minor-mode &optional arg
#+BEGIN_defun
  *Minor mode* for editing text, with leading spaces starting a paragraph.

  In this mode, you  do not need blank lines between  paragraphs when the first
  line   of  the   following  paragraph   starts  with   whitespace,  as   with
  ‘paragraph-indent-text-mode’.
#+END_defun

#+ATTR_texinfo: :options paragraph-indent-text-mode
#+BEGIN_defun
  *Major mode* for editing text, with leading spaces starting a paragraph.

  In this mode, you  do not need blank lines between  paragraphs when the first
  line of the following paragraph starts with whitespace.

  - ~ispell-complete-word~ (=C-M-i=) ::

    Try to complete the word before or at point.

    - =INTERIOR-FRAG= ::  when non-nil,  the word may  be a  character sequence
      inside of a word.
#+END_defun

*** Moving by Sentences
|---------------------+-------------+------------------------------------|
| Command             | Key Binding | Purpose                            |
|---------------------+-------------+------------------------------------|
| ~backward-sentence~ | =M-a=       | Move backward to start of sentence |
| ~forward-sentence~  | =M-e=       | Move forward to end of sentence    |
|                     |             |                                    |
|---------------------+-------------+------------------------------------|

#+ATTR_texinfo: :options sentence-end
#+BEGIN_defvar
  A regular expression that matches ends of sentences. Every paragraph boundary
  terminates sentences as well. The value includes the whitespace following the
  sentence.
#+END_defvar

#+ATTR_texinfo: :options sentence-end
#+BEGIN_defun
  Return the regexp describing the end of a sentence.

  This function returns  either the value of the variable
  - ‘sentence-end’ if it is   non-nil,  or
  - the  default   value  constructed   from  the   variables
    - ‘sentence-end-base’,
    - ‘sentence-end-double-space’,
    - ‘sentence-end-without-period’ and
    - ‘sentence-end-without-space’.

  The default value  specifies that in order  to be recognized as the  end of a
  sentence,  the ending  period, question  mark, or  exclamation point  must be
  followed by two spaces, with perhaps some closing delimiters in between.
#+END_defun

You can alter this behavior by customizing the following variables:

- sentence-end-double-space ::  non-nil means a  single space does *not*  end a
  sentence
- sentence-end-without-period ::  non-nil means a  sentence will end  without a
  period
- sentence-end-without-space ::  a string  of characgters  that end  a sentence
  /without/ requiring spaces after

*** Moving by S-Expression
|--------------------+-------------+--------------------------------------------------|
| Command            | Key Binding | Purpose                                          |
|--------------------+-------------+--------------------------------------------------|
| ~forward-sexp~     | =C-M-f=     | Move forward by sexp                             |
| ~backward-sexp~    | =C-M-b=     | Move backward by sexp                            |
|                    | =<ESC> C-d= |                                                  |
| ~up-list~          |             | Move forward out of one level of parentheses     |
| ~backward-up-list~ | =C-M-u=     | Move up out of a list                            |
| ~down-list~        | =C-M-d=     | Move down into list                              |
|                    |             | just like ‘up-list’, but with a negated argument |
| ~forward-list~     | =C-M=n=     | Move forward to next list =(..)=                 |
| ~backward-list~    | =C-M=p=     | Move backward to previous list                   |
|--------------------+-------------+--------------------------------------------------|

- =sexp= :: is a Lisp term that covers a wide range of commands that operate on
  /balanced expressions/.

- balanced expressions :: can span multiple lines; can consist of:

  - strings :: are balanced expressions that begin and end with ="= or ='=.

  - brackets  :: are  balanced expressions  that  have defined  open and  close
    characters:
    - =[ ]=
    - =( )=
    - ={ }=
    - =< >=

*** Moving by Defun
|------------------------------------------+-------------+----------------------------------------+-------------------------------------------------------|
| Command                                  | Key Binding | Purpose                                | Curent Value                                          |
|------------------------------------------+-------------+----------------------------------------+-------------------------------------------------------|
| ~beginning of defun~                     | =C-M-a=     | Move to beginning of defun             |                                                       |
| ~end-of-defun~                           | =C-M-e=     | Move to end of defun                   |                                                       |
| ~defun-prompt-regexp~                    |             | User option; what text can             |                                                       |
|                                          |             | can appear before the open-paren       |                                                       |
|                                          |             | that starts a defun                    |                                                       |
| ~open-paren-in-columnn-0-is-defun-start~ |             | Variable; open paren in col 0 is defun | src_emacs_lisp{open-paren-in-column-0-is-defun-start} |
| ~beginning-of-defun-function~            |             | Function to find beginning of a defun  |                                                       |
| ~end-of-defun-function~                  |             | Function to find end of defun          |                                                       |
|------------------------------------------+-------------+----------------------------------------+-------------------------------------------------------|

The ~defun~ commands move to the logical beginning or end of the function point
is in.  =function= is really a rather loose term.

*** Moving by Pages
| Command          | Key Binding | Purpose                                     |
|------------------+-------------+---------------------------------------------|
| ~forward-page~   | =C-x ]=     | Move forward to page boundary               |
| ~backward-page~  | =C-x [=     | Move backward to page boundary              |
| ~mark-page~      | =C-x C-p=   | Put mark at end of page, point at beginning |
| ~narrow-to-page~ | =C-x n p=   | Mark text outside page invisible.           |
|------------------+-------------+---------------------------------------------|

A  =page= is  anything  delimited  by the  character  defined  in the  variable
=page-delimiter=, which  defaults to the control  code =^L=, also known  as the
ASCII control code =form feed=.

In some LISP circles, it is common to group things by *pages* and as Emacs has
close ties to the LISP community it comes with a battery of commands to
interact with pages.

*** Moving to End of Buffer
| Command               | Key Binding | Purpose                     |
|-----------------------+-------------+-----------------------------|
| ~beginning-of-buffer~ | =M-<=       | Move to beginning of buffer |
| ~goto-char POINT-MIN~ |             | Move to beginning of buffer |
| ~end-of-buffer~       | =M->=       | Move to end of buffer       |
| ~goto-char POINT-MAX~ |             | Move to end of buffer       |
|-----------------------+-------------+-----------------------------|
 
*** Scrolling
| Command                   | Key Binding       | Purpose                      |
|---------------------------+-------------------+------------------------------|
| ~scroll-up-command~       | =C-v= / =<prior>= | Scroll text upward           |
| ~scroll-down-command~     | =M-v= / =<next>=  | Scroll text downward         |
| ~scroll-other-window~     | =C-M-v=           | Scroll other window upward   |
| ~scrol-other-window-down~ | =C-M-S-v=         | Scroll other window downward |
|                           | =C-M- - C-M-v=    |                              |
| ~scroll-left~             | =C-x <=           | Scroll window display left   |
| ~scroll-right~            | =C-x >=           | Scroll window display right  |
|---------------------------+-------------------+------------------------------|

#+ATTR_texinfo: :options next-screen-context-lines
#+BEGIN_defvar
  Number of lines of continuity when scrolling by screenfuls.
#+END_defvar

** Bookmarks and Registers

[[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#index-bookmarks-559][Bookmarks in Manual §13.8]]

/Bookmarks/ record positions you can jump to.  They have long names, and they
persist automatically from one Emacs session to the next.  The prototypical use
of bookmarks is to record where you were reading in various files.

#+cindex:bookmark
Bookmarks in Emacs work identically to the ones in your web browser but with
the notable exception of supporting a wider variety of sources.  That makes
Emacs’s bookmarking system flexible enough for you to bookmark:

- info pages
- files
- dired directories
- remote files using Emacs' Tramp system


Bookmarks are a very efficient way of jumping to frequently-used files or
directories; it is also useful if there are sections of Emacs’s manual that you
want to return to frequently.  And because of the unified nature of Emacs ---
buffers --- the three are seamlessly stored and recalled from the same list of
bookmarks.

#+cindex:bookmark file
Bookmarks are saved to a bookmark file in ~$HOME/.emacs.d/~ called ~bookmarks~.

#+texinfo:@heading Bookmark File

#+vindex:bookmark-default-file
The variable ~bookmark-default-file~ determines where Emacs stores your
bookmarks.

#+cindex:s-expression
The file is plain text (elisp =s-expressions=, actually) meaning it is possible
edit it manually (if you absolutely must) or merge the files if you regularly
add or remove bookmarks from multiple machines.

Here is a sample entry:

#+begin_src elisp :eval never
("mastering-emacs.org"
 (filename . "~/Dev/Emacs/MasteringEmacs/MasteringEmacs.org")
 (front-context-string . "# -*- mode: org;")
 (rear-context-string)
 (position . 1))
#+end_src

#+texinfo:@heading Bookmark Commands

#+caption: Bookmark Commands
#+name:bookmark-commands
|-------------+---------------------|
| Key Binding | Purpose             |
|-------------+---------------------|
| C-x r m     | Set a bookmark      |
| C-x r l     | List bookmarks      |
| C-x r b     | Jump to a bookmark  |
|-------------+---------------------|

#+texinfo:@heading Register Commands

#+cindex:register
Registers, however, are different; they are the flip side of the coin --- where
bookmarks are permanent, registers are transient.  A /register/ is a
single-character store-and-recall mechanism for several types of data,
including:

- Window configurations and framesets
- Points
- Numbers and Text


A register is a single character only.  When you want to store or recall
something, you are asked for a single character to query.

#+caption:Register Commands
#+name:register-commands
|-------------+----------------------------------------|
| Key Binding | Purpose                                |
|-------------+----------------------------------------|
| C-x r n     | Store number in register               |
| C-x r s     | Store region in register               |
| C-x r SPC   | Store point in register                |
| C-x r +     | Increment number in register           |
| C-x r j     | Jumpt to register                      |
| C-x r i     | Insert content in register             |
| C-x r w     | Store window configuration in register |
| C-x r f     | Store frameset in register             |
|-------------+----------------------------------------|

** Selections and Regions

** Searching and Indexing

** Other Movement Commands
* Directories---Files---Buffers
** File Directories
A /directory listing/ is a list of all the files in a directory.

Emacs provides commands to create and delete directories, and to make directory
listings in /brief format/ (file names only) and /verbose format/ (sizes,
dates, and other attributes included).

#+cindex:Dired
Emacs also includes a directory browser feature called Dired, which you can
invoke with =C-x d=;

- [[*list-directory][~list-directory~]] (=C-x C-d=)

- [[*make-directory][~make-directory~]]

- [[*delete-directory][~delete-directory~]]

- [[*move-file-to-trash][~move-file-to-trash~]] (a Lisp function)

- [[*system-move-file-to-trash][~system-move-file-to-trash~]] (a non-interactive built-in C function)

- ~list-directory-brief-switches~ (a variable)

- ~list-directory-verbose-switches~ (a variable)

- ~directory-free-space-program~ (a variable)

- ~directory-free-space-args~ (a variable)

- [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] (a variable)

- ~trash-directory~ (a variable)

*** list-directory

#+attr_texinfo: :options list-directory dirname &optional verbose
#+begin_defun
Display a list of files in or matching DIRNAME, a la ‘ls’.  When called
interactively, a prefix argument switches on verbose mode.

- DIRNAME :: a directory file name; wildcard characters can be included; it
  will be globbed by the shell if necessary;

- VERBOSE :: if non-nil, supply the {{{option (-l)}}} switch.


The variables:

- ~list-directory-brief-switches~
- ~list-directory-verbose-switches~


control which switches are passed to the ~ls~ command in brief and verbose
listings.

The variables:

- ~directory-free-space-program~ (~df~)
- ~directory-free-space-args~ (args to pass to ~df~)


customize the display of free space on the disk containing the directory in
verbose mode.

#+end_defun

*** make-directory

Create the directory DIR and optionally any nonexistent parent dirs.  When
called interactively, non-existent parent dirs will automatically be created.

#+attr_texinfo: :options make-directory dir &optional parents
#+begin_defun
- DIR :: The DIR to create; if DIR exists, signal an error unless PARENTS is
  non-nil.

- PARENTS :: If non-nil, create any non-existent parent directories.
#+end_defun

*** delete-directory

Delete the directory named DIRECTORY.  Symlinks are /not/ followed.

#+attr_texinfo: :options delete-directory directory &optional recursive trash
#+begin_defun
- DIRECTORY :: The directory to delete;

- RECURSIVE :: If non-nil, delete all files contained inside DIRECTORY;

- TRASH :: If non-nil, and if variable [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] is also
  non-nil, move the DIRECTORY into the trash or recycle bin using
  [[*move-file-to-trash][~move-file-to-trash~]].
#+end_defun

*** move-file-to-trash

First, if the function [[*system-move-file-to-trash][~system-move-file-to-trash~]] is defined, call it with
FILENAME as an argument.

Otherwise, move the file (or directory) named FILENAME to the trash, or if the
variable ~trash-directory~ is defined[fn::by default it is nil], to it.

When [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] is non-nil, this function is called by
[[*delete-file][~delete-file~]] and [[*delete-directory][~delete-directory~]] instead of deleting files outright.

#+attr_texinfo: :options move-file-to-trash filename
#+begin_defun
- FILENAME :: file or directory to move to trash.
#+end_defun

*** system-move-file-to-trash

Move file or directory named FILENAME to the recycle bin.

#+attr_texinfo: :options system-move-file-to-trash filename
#+begin_defun
- FILENAME :: file or directory to move to the trash
#+end_defun

*** delete-by-moving-to-trash---a variable

#+attr_texinfo: :options delete-by-moving-to-trash
#+begin_defvar
If non-nil (nil is the default), some file deletion commands using the function
~move-file-to-trash~ instead of deleting them outright.  These commnds include:
- [[*delete-file][~delete-file~]]
- [[*delete-directory][~delete-directory~]]
- =Dired= deletion commands


The variable can be customized.
#+end_defvar

** Directories and File Names

#+texinfo:@heading Directory Variables

- [[*default-directory---a variable][~default-directory~]] --- a variable representing the current buffer's default
  directory


#+texinfo:@heading File Name Components

- [[*file-name-directory][~file-name-directory~]] --- the directory name of a file name (path) (ends with
  a trailing slash =/=)

- [[*file-name-as-directory][~file-name-as-directory~]] --- the directory name of a file name, or path (with
  a slash)

- [[*file-name-nondirectory][~file-name-nondirectory~]] --- the filename of a path (everything after last
  slash)

- [[*file-name-extension][~file-name-extension~]] --- the filename's extension

- [[*file-name-sans-extension][~file-name-sans-extension~]] --- the filename without its extension

- [[*directory-name-p][~directory-name-p~]] --- true for a directory name

- [[*directory-file-name][~directory-file-name~]] --- a directory file name (dirname) (file name without
  a trailing slash)


#+texinfo:@heading Absolute and Relative File Names

- [[*file-name-absolute-p][~file-name-absolute-p~]] --- true if the file name is absolute

- [[*file-relative-name][~file-relative-name~]] --- a relative file name in relation to a directory


#+texinfo:@heading Expanding and Abbreviating File Names

- [[*expand-file-name][~expand-file-name~]] --- expands to absolute an abbreviated file name

- [[*substitute-in-file-name][~substitute-in-file-name~]] --- expands environment variables in a file name
  (path)

- [[*abbreviate-file-name][~abbreviate-file-name~]] --- abbreviates an absolute file or directory name


#+texinfo:@heading Quoting File Names

- [[*file-name-quote][~file-name-quote~]] --- adds quote prefix to a file name

- [[*file-name-unquote][~file-name-unquote~]] --- removes quote prefix from a file name

- [[*file-name-quoted-p][~file-name-quoted-p~]] --- tests whether a file name is quoted


#+texinfo: @heading Magic File Names

- magic file names :: TODO

*** File Name Components

The operating system groups files into directories.  To specify exactly and
precisely (absolutely) a file[fn::some would call this a /path/], you must
specify the *directory* and the file's *file name* within that directory.

Therefore, Emacs considers a file name[fn:path:path] as having two main parts:

#+cindex:directory name
- the /directory name/ part; see [[*file-name-directory][~file-name-directory~]] and [[*file-name-as-directory][~file-name-as-directory~]]

- the nondirectory part (or /file name/ within the directory).  This is also
  sometimes referred to as a /relative file name/, since it is *relative* to
  the directory part.  The file name often has a /base name/ and an optional
  /extension/.

  - see [[*file-name-nondirectory][~file-name-nondirectory~]]

  - see [[*file-name-extension][~file-name-extension~]] and [[*file-name-sans-extension][~file-name-sans-extension~]]

  - see [[*file-name-base][~file-name~base~]]


Either part may be empty.  Concatenating these two parts reproduces the
original file name[fn:path].  On most systems, the directory part is everything
up to and including the last slash; the nondirectory part is the rest.

#+texinfo:@heading Absolute File Names

An /absolute file name/ specifies all the directory names starting from the
root of the tree.  An absolute file name starts with a ‘/’.

- see [[*file-name-absolute-p][~file-name-absolute-p~]]

#+texinfo:@heading Relative File Names

A /relative file name/ specifies the position of the file in the tree relative
to a default directory.  A relative file name does NOT start with a ‘/’.  It
can use abbreviations such as =.=, =..=, and =~=.

- see [[*file-relative-name][~file-relative-name~]]

#+texinfo:@heading Expanding File Names

Expanding a file name means converting a relative file name to an absolute one.
Since this is done relative to a default directory, you must specify the
default directory as well as the file name to be expanded.  It also involves
expanding abbreviations (e.g., =~=).

- see [[*expand-file-name][~expand-file-name~]]

- see [[*substitute-in-file-name][~substitute-in-file-name~]]

- see [[*abbreviate-file-name][~abbreviate-file-name~]]


#+texinfo:@heading Quoting File Name

Sometimes, it is not desired to expand file names.  In such cases, the file
name can be quoted to suppress the expansion, and to handle the file name
literally.  Quoting happens by prefixing the file name with ‘/:’.

- see [[*file-name-quote][~file-name-quote~]]

- see [[*file-name-unquote][~file-name-unquote~]]

- see [[*file-name-quoted-p][~file-name-quoted-p~]]

*** Directory Names and Directory File Names

#+texinfo:@heading Directory Name

#+cindex:directory name
A /directory name/ <<directory-name>> is a string that must name a directory if
it names any file at all.

- see [[*file-name-directory][~file-name-directory~]]

- see [[*file-name-as-directory][~file-name-as-directory~]]


#+texinfo:@heading Directory File Name

#+cindex:directory
#+cindex:directory file name
A /directory/ is actually a kind of file, and it has a file name (called the
/directory file name/ <<directory-file-name>>, which is related to the
/directory name/ but is typically not identical, e.g., it will not have a
trailing slash.

- See [[*directory-file-name][~directory-file-name~]]

#+texinfo:@heading The Difference

These two names for the same entity are related by a syntactic transformation:

- On GNU and other POSIX-like systems, to obtain a directory name, append a ‘/’
  to a directory file name that does not already end in ‘/’.

  : directory name = directory file name + /


The difference between a [[directory-name][directory name]] and a [[directory-file-name][directory file name]] is subtle but
crucial:

- When an Emacs variable or function argument is described as being a
  /directory name/, a /directory file name/ is not acceptable.

- When [[*file-name-directory][~file-name-directory~]] returns a string, that is always a /directory
  name/.

*** Directory and File Variables and Functions
**** default-directory---a variable

#+attr_texinfo: :options default-directory
#+begin_defvar
Name of default directory of current buffer.  It should be a [[directory-name][directory name]] (as
opposed to a [[directory-file-name][directory file name]]).  On GNU and Unix systems, [[directory-name][directory names]]
end in a slash ‘/’.
#+end_defvar

**** file-name-directory

#+attr_texinfo: :options file-name-directory filename
#+begin_defun
This function returns the /directory component/ of a file name.  Given a Unix
syntax file name, it returns a string ending in slash (=/=).

- FILENAME :: a file name (path)

- RETURN VALUE :: the directory component ([[directory-name][directory name]]) from FILENAME
  (path);

  nil if FILENAME does not include a directory.
#+end_defun

**** file-name-nondirectory

This function takes a full file name (path) and returns everything after the
last slash, or the full name if it contains no slash.  If the file name ends in
a slash, then this function will return the empty string.

#+attr_texinfo: :options file-name-nondirectory filename
#+begin_defun
- FILENAME :: a full file name (path)

- RETURN VALUE :: file name without its directory.
#+end_defun
**** file-name-extension

#+attr_texinfo: :options file-name-extension filename &optional period
#+begin_defun
- FILENAME :: a file name

- PERIOD :: if non-nil, include the period in the returned value; if file name
  has no extension, return the empty string rather than nil.

- RETURN VALUE :: the FILENAME's extension, i.e., the part that begins with the
  last ‘.’, or nil for extensionless file name, or the empty string if the file
  name ends with a period.
#+end_defun
**** file-name-sans-extension

#+attr_texinfo: :options file-name-sans-extension filename
#+begin_defun
- FILENAME :: a file name to work upon

- RETURN VALUE :: a file name without an extension; this includes the directory
  portion of the FILENAME, if any.
#+end_defun
**** file-name-base

#+attr_texinfo: :options file-name-base &optional filename
#+begin_defun
- FILENAME :: a file name to work upon; the default is [[*buffer-file-name][~buffer-file-name~]]

- RETURN VALUE :: the base name of the file name, i.e., no directory and no
  extension
#+end_defun
**** directory-file-name

This function returns a string representing /dirname/ in a form that the
operating system will interpret as the name of a file (a directory file name).
In general, it will return a name without a trailing slash.

This operation exists because a directory is also a file, but its name as a
directory is different from its name as a file.

#+attr_texinfo: :options directory-file-name directory
#+begin_defun
- DIRECTORY :: a directory to process; obtain its file name; in Unix-syntax,
  this function just removes the final slash.

- RETURN VALUE :: the file name of the directory named DIRECTORY (its directory
  file name).
#+end_defun
**** file-name-as-directory

This operation exists because a directory is also a file, but its name as a
directory is different from its name as a file.  The result can be used as the
value of ~default-directory~ or passed as second argument to
~expand-file-name~.

#+attr_texinfo: :options file-name-as-directory file
#+begin_defun
- FILE :: a file

- RETURN VALUE :: Return a string representing the file name FILE interpreted
  as a directory.  For a Unix-syntax file name, just appends a slash unless a
  trailing slash is already present.
#+end_defun
**** directory-name-p

#+attr_texinfo: :options directory-name-p name
#+begin_defun
- NAME :: potential file name to test

- RETURN VALUE :: non-nil if NAME ends with a directory separator character.
#+end_defun
**** file-name-absolute-p

This function tests whether a file name is absolute.  Given a possibly relative
file name, you can expand any leading ‘~’ and convert the result to an absolute
name using [[*expand-file-name][~expand-file-name~]].

#+attr_texinfo: :options file-name-absolute-p filename
#+begin_defun
- FILENAME :: the file name to test

- RETURN VALUE :: returns t if FILENAME is an absolute file name or begins with
  =~=; returns nil if not.
#+end_defun
**** file-relative-name

Convert an absolute file name to a relative file name in relation to a
directory.

#+attr_texinfo: :options file-relative-name filename &optional directory
#+begin_defun
- FILENAME :: a file name upon which to operate to convert it to be relative to
  DIRECTORY, which defaults to [[*default-directory---a variable][~default-directory~]].

- DIRECTORY :: a directory to act as a reference for this function;

- RETURN VALUE :: a relative file name which is equivalent to FILENAME in
  combination with DIRECTORY.
#+end_defun

**** file-name-quote

This macro adds the quotation prefix ‘/:’ to the file name.

#+attr_texinfo: :options file-name-quote name
#+begin_defun
- NAME :: a file name upon which to operate;

- RETURN VALUE :: the file name to which has been added the quotation prefix:
  ‘/:’;

  - local file name :: prefixes name with ‘/:’.

  - remote file name :: the local part of name (see Magic File Names) is
    quoted;

  - quote name :: If name is already a quoted file name, name is returned
    unchanged.
#+end_defun
**** file-name-unquote

This macro removes the quotation prefix ‘/:’ from the file name, if any.

#+attr_texinfo: :options file-name-unquote name
#+begin_defun
- NAME :: a file name upon which to operate

- RETURN VALUE :: the NAME without a quote prefix.  If name is a remote file
  name, the local part of name is unquoted.
#+end_defun
**** file-name-quoted-p

This macro returns non-nil, when name is quoted with the prefix ‘/:’.

#+attr_texinfo: :options file-name-quoted-p name
#+begin_defun
- NAME :: a file name to test

= RETURN VALUE :: returns non-nil, when name is quoted with the prefix ‘/:’; if
  name is a remote file name, the local part of name is checked.
#+end_defun

**** expand-file-name

Convert a relative file name to an absolute one and canonacilize it.  However,
use =(directory-file-name (file-name-directory dirname))= to traverse a
filesystem tree, not =(expand-file-name ".." dirname)=.

#+attr_texinfo: :options expand-file-name name &optional default-directory
#+begin_defun
- NAME :: a file name (a string that is a valid file name) upon which to
  operate: convert the file name to absolute and canonicalize it.  =~/= expands
  to the home directory.  =~USER= expands to USER's home directory.

- DEFAULT-DIRECTORY :: a directory used to start with if NAME is relative (does
  not start with slash or tilde);  this can be either a directory name or a
  directory file name; if nil or missing, the current buffer's value of
  ~default-directory~ is used.

- RETURN VALUE :: an absolute, canonacalized file name.
#+end_defun
**** substitute-in-file-name

This function replaces environment variable references in filename with the
environment variable values.

Sometimes, it is not desired to expand file names. In such cases, the file name
can be quoted to suppress the expansion, and to handle the file name
literally. Quoting happens by prefixing the file name with ‘/:’.

#+attr_texinfo: :options substitute-in-file-name filename
#+begin_defun
- FILENAME :: a file name upon which to operate; in FILENAME, substitute
  environment variables

- RETURN VALUE :: an absolute file name
#+end_defun
**** abbreviate-file-name

Converts a directory name to its abbreviation.  You can use this function for
directory names and for file names, because it recognizes abbreviations even as
part of the name.

#+attr_texinfo: :options abbreviate-file-name filename
#+begin_defun
- FILENAME :: an absolute file name upon which to operate;

- RETURN VALUE :: a shortened version of FILENAME, using
  ~directory-abbrev-alist~.  Also substitute =~= for the user's home directory
  and remove automounter prefixes.

  When this function is first called, it caches the user’s home directory as a
  regexp in ~abbreviated-home-dir~, and reuses it afterwards.
#+end_defun

** Files

#+texinfo:@heading Visiting Files

- [[*find-file][~find-file~]] ::

- [[find-file-literally][~find-file-literally~]] ::

- [[*find-file-noselect][~find-file-noselect~]] ::

- [[*find-file-other-window][~find-file-other-window~]] ::

- [[*find-file-read-only][~find-file-read-only~]] ::

- [[*find-file-wildcards --- User Option][~find-file-wildcards~]] --- user option ::

- [[*find-file-hook --- User Option][~find-file-hook~]] --- user option ::

- [[*find-file-not-found-functions --- Variable][~find-file-not-found-functions~]] --- variable ::

- [[*find-file-literally --- Variable][~find-file-literally~]] --- variable ::


#+texinfo:@heading Saving Files

- [[*save-buffer][~save-buffer~]] ::

- [[*save-some-buffers][~save-some-buffers~]] ::

- [[*write-file][~write-file~]] ::

- [[*set-visited-file-name][~set-visited-file-name~]] ::

- [[*not-modified][~not-modified~]] ::


#+texinfo:@heading Deleting Files

- [[*delete-file][~delete-file~]] ::

#+texinfo:@heading Hooks Related to Saving

- [[*write-file-functions---a hook][~write-file-functions~]] ::

- [[*write-contents-functions---a hook][~write-contents-functions~]] ::

- [[*before-save-hook][~before-save-hook~]] ::

- [[*after-save-hook][~after-save-hook~]] ::


#+texinfo:@heading Writing Buffers to Files

- [[*append-to-file][~append-to-file~]] ::

- [[*write-region][~write-region~]] ::

- [[*with-temp-file][~with-temp-file~]] ::


#+texinfo:@heading Errors

- handle errors ::

  - ~system-messages-locale~ (a variable) ::

  - ~locale-coding-system~ (a variable) ::


#+texinfo:@heading Creating Temporary Files

- [[*make-temp-file][~make-temp-file~]] :: create a unique temporary file

- [[*temporary-file-directory---a user option][~temporary-file-directory~]]---a user option :: default directory for storing
  temporary files

- [[*small-temporary-file-directory---a user option][~small-temporary-file-directory~]]---a user option :: a default directory for
  storing small temporary files

*** Visiting or Finding Files

#+cindex:visit a file
/Visiting/ a file means reading a *file* (information recorded in a computer)
into a *buffer* (information inside of Emacs that can be viewed and edited).
Once this is done, we say that the buffer is “visiting” that file, and call the
file “the visited file” of the buffer.  The buffer contains information copied
from the file.  If that information is changed, it must be *saved* (copied back
into the file) to make the changes permanent; otherwise the new information
will be lost.

Function names that visit files for historical reasons start with ~find-~
rather than ~visit-~.

In a Lisp program, if you want to look at the contents of a file but not alter
it, the fastest way is to use [[*Insert File Contents][~insert-file-contents~]] in a temporary buffer.
Visiting the file is not necessary and takes longer.

**** find-file

#+attr_texinfo: :options find-file filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, using an existing
buffer if there is one, and otherwise creating a new buffer and reading the
file into it.  It also returns that buffer.  This function is equivalent to:

 : (switch-to-buffer (find-file-noselect filename nil nil wildcards))

See [[switch-to-buffer][~switch-to-buffer~]].

- WILDCARDS :: if non-nil, expand wildcard characters in FILENAME and visit all
  of the matching files.  It is *always* true interactively.
#+end_defun

**** find-file-literally

#+attr_texinfo: :options find-file-literally filename
#+begin_defun
This command visits FILENAME, like ‘find-file’ does, but it does not perform
any format conversions (*note Format Conversion::), character code conversions
(*note Coding Systems::), or end-of-line conversions (*note End of line
conversion: Coding System Basics.).  The buffer visiting the file is made
unibyte, and its major mode is Fundamental mode, regardless of the file name.
File local variable specifications in the file (*note File Local Variables::)
are ignored, and automatic decompression and adding a newline at the end of the
file due to ‘require-final-newline’ (*note require-final-newline: Saving
Buffers.) are also disabled.

If you want to be sure of accessing a file’s contents literally, you should
create a temporary buffer and then read the file contents into it using
~insert-file-contents-literally~ (*note Reading from Files::).
#+end_defun

**** find-file-noselect

#+attr_texinfo: :options find-file-noselect filename &optional nowarn rawfile wildcards
#+begin_defun
This function returns a buffer visiting the file FILENAME.  It does *not* make
the buffer /current/ or /display/ it in a window.

The function returns an existing buffer if there is one; otherwise it creates a
new buffer and reads the file into it.

When this function uses an existing buffer, it first verifies that the file has
not changed since it was last visited or saved in that buffer.  If the file has
changed, this function asks the user whether to reread the changed file.  If
the user says ‘yes’, any edits previously made in the buffer are lost.

This function normally calls ~after-find-file~ after reading the file.  This
function sets the buffer major mode, parses local variables, warns the user if
there exists an auto-save file more recent than the file just visited, and
finishes by running the functions in ‘find-file-hook’.

- WILDCARDS :: if non-nil, expand wildcard characters in FILENAME and visit all
  of the matching files.

- NOWARN :: if non-nil, do not issue warnings.

- RAWFILE :: if non-nil, do not call ~after-find-file~, and
  ~find-file-not-found-functions~ are not run in case of failure, and
  suppresses coding system conversion and format conversion.

- RETURN VALUE :: usually returns the buffer that is visiting the file
  FILENAME.  If WILDCARDS are used, it returns a list of buffers that are
  visiting various files.
#+end_defun

**** find-file-other-window

#+attr_texinfo: :options find-file-other-window filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, but does so in a
window other than the selected window.  It may use another existing window or
split a window;
#+end_defun

**** find-file-read-only

#+attr_texinfo: :options find-file-read-only filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, like ‘find-file’, but
it marks the buffer as read-only.
#+end_defun

**** find-file-wildcards --- User Option

#+attr_texinfo: :options find-file-wildcards
#+begin_defvar
If this option is set to =nil=, then the various ~find-file~ functions ignore
their WILDCARDS argument and never treat wildcard characters specially.  The
default value is =t=.
#+end_defvar

**** find-file-hook --- User Option

#+attr_texinfo: :options find-file-hook
#+begin_defvar
The value of this variable is a list of functions to be called after a file is
visited.  The buffer visiting the file is current when the hook functions are
run.

#+cindex:hook
This is a normal hook.
#+end_defvar

**** find-file-not-found-functions --- Variable

#+attr_texinfo: :options find-file-not-found-functions
#+begin_defvar
The value of this variable is a list of functions to be called when ‘find-file’
or ‘find-file-noselect’ is passed a nonexistent file name.
‘find-file-noselect’ calls these functions as soon as it detects a nonexistent
file.  It calls them in the order of the list, until one of them returns
non-‘nil’.

#+cindex:hook, not normal
This is not a normal hook because the values of the functions are used, and in
many cases only some of the functions are called.
#+end_defvar

**** find-file-literally --- Variable

#+attr_texinfo: :options find-file-literally
#+begin_defun
If non-nil, makes ~save-buffer~ behave as if the buffer were visiting its file
literally, without conversions of any kind.

The command ~find-file-literally~ sets this variable’s local value, but other
equivalent functions and commands can do that as well.

This variable is permanent local, so it is unaffected by changes of major
modes.

#+end_defun

*** File Names
**** Minibuffer for File Names

#+texinfo:@heading Minibuffer

#+cindex:minibuffer
#+cindex:completion
#+cindex:history
While in the minibuffer, you can use the usual /completion/ and /history/
commands.  Minibuffer history commands offer some special features for reading
file names.

#+findex:find-file
#+cindex:visit file
#+cindex:minibuffer
- ~find-file~ (=C-x C-f=) :: use the /minibuffer/ to read a file name argument.
  Emacs obeys this command by /visiting/ the file: it creates a buffer, copies
  the contents of the file into the buffer, and then displays the buffer for
  editing.  If the file does not exist, this command creates an empty buffer;
  Emacs creates the file the first time you save this buffer.

- ~save-buffer~ (=C-x C-s=) :: you can save the new text in the file by typing
  =C-x C-s= (~save-buffer~).  This copies the altered buffer contents back into
  the file

#+texinfo:@subheading Completion

<<ignore-case-variables>>
#+vindex:read-file-name-completion-ignore-case
- ~read-file-name-completion-ignore-case~ :: when non-nil, ignore case when
  completing file names.
#+vindex:read-buffer-completion-ignore-case
- ~read-buffer-completion-ignore-case~ :: when non-nil, ignore case when
  completing buffer names.
  #+vindex:completion-ignored-extensions
- ~completion-ignored-extensions~ :: When completing file names, Emacs usually
  omits certain alternatives that are considered unlikely to be chosen, as
  determined by this list variable.

  It's value is:

  src_elisp[:eval yes :results output :exports results]{(princ completion-ignored-extensions)}
  #+vindex:completion-cycle-threshold
- ~completion-cycle-threshold~ :: If non-nil, completion commands can cycle
  through completion alternatives. If t, cycling is always used.

#+texinfo:@subheading Permissive Completion with Confirmation

#+texinfo: @subheading Minibuffer History

#+cindex:minibuffer history
Every argument that you enter with the minibuffer is saved in a minibuffer
history list so you can easily use it again later.  Emacs keeps separate
history lists for several different kinds of arguments.  For example, there is
a list for file names, used by all the commands that read file names.  Other
history lists include buffer names, command names (used by M-x), and command
arguments (used by commands like ~query-replace~).  Use the following arguments
to quickly fetch an earlier argument into the minibuffer:

- ~previous-history-element~ (=M-p=)

- ~next-history-element~ (=M-n=)

- ~previous-line-or-history-element~ (=<UP>=)

- ~next-line-or-history-element~ (=<DOWN>=)

- ~previous-matching-history-element~ (=M-r regexp=)

- ~next-matching-history-element~ (=M-s regexp=)

- ~repeat-complex-command~ (=C-x <ESC> <ESC>=) : Re-execute a recent minibuffer
  command from the command history.  With no argument, it repeats the last such
  command. A numeric argument specifies which command to repeat; 1 means the
  last one, 2 the previous, and so on.  You can use the usual minibuffer
  history commands to move through the history list.

- ~list-command-history~ (=M-x list-command-history=) : open a new window with
  the list of commands
  #+vindex:command-history
- ~command-history~ : The list of previous minibuffer-using commands is stored
  as a Lisp list in this variable.  Lisp programs can re-execute a command by
  calling eval with the command-history element.

**** Default Directory

#+cindex:default directory
#+vindex:default-directory
- ~default-directory~ :: Each buffer has a default directory, stored in the
  buffer-local variable ~default-directory~.  Emacs always assumes that any
  relative file name is relative to the default directory,

  When you visit a file, Emacs sets ~default-directory~ in the visiting buffer
  to the directory of its file.

  #+findex:pwd
- ~pwd~ :: Show the current default directory.

  #+findex:cd
- ~cd DIR~ :: Make DIR become the current buffer’s default directory.

**** Quoting File Names
You can quote an absolute file name to prevent special characters and syntax in
it from having their special effects.  The way to do this is to add =/:= at the
beginning.
: /:/foo:/bar

**** Completion
After you type part of the argument, Emacs can fill in the rest, or some of it,
based on what was typed so far.  Certain keys (usually =<TAB>=, =<RET>=, and
=<SPC>=) are rebound in the minibuffer to special completion commands.  You can
usually type =?= to see a list of completion alternatives.

*** Saving Files

#+cindex:hooks
#+cindex:format conversion
Saving a buffer runs several hooks.  It also performs format conversion.  These
hooks are only run by ~save-buffer~; they are not run by other primitives and
functions that write buffer text to files.  Auto-saving does not run these
hooks.

**** save-buffer

#+attr_texinfo: :options save-buffer &optional arg
#+begin_defun
Save current buffer in visited file if modified.

- arg :: how to deal with backup files
#+end_defun

**** save-some-buffers

#+attr_texinfo: :options save-some-buffers &optional ARG PRED
#+begin_defun
Save some modified file-visiting buffers.  Asks user about each one.  You can
answer ‘y’ to save, ‘n’ not to save, ‘C-r’ to look at the buffer in question
with ~view-buffer~ before deciding or ‘d’ to view the differences using
~diff-buffer-with-file~.

This command first saves any buffers where ~buffer-save-without-query~ is
non-nil, without asking.

- ARG :: Optional argument ARG (interactively, prefix argument) non-nil means
  save all with no questions.

- PRED :: Optional second argument PRED determines which buffers are
  considered:

  - If PRED is nil, all the file-visiting buffers are considered.

  - If PRED is t, then certain non-file buffers will also be considered.

  - If PRED is a zero-argument function, it indicates for each buffer whether
    to consider it or not when called with that buffer current.

  - PRED defaults to the value of ‘save-some-buffers-default-predicate’.


See ~save-some-buffers-action-alist~ if you want to change the additional
actions you can take on files.
#+end_defun

**** write-file

#+attr_texinfo: :options write-file FILENAME &optional CONFIRM
#+begin_defun
Write current buffer into file FILENAME.  This makes the buffer visit that
file, and marks it as not modified.

If optional second arg CONFIRM is non-nil, this function asks for confirmation
before overwriting an existing file.
#+end_defun

**** set-visited-file-name

#+attr_texinfo: :options set-visited-file-name FILENAME &optional NO-QUERY ALONG-WITH-FILE
#+begin_defun
Change name of file visited in current buffer to FILENAME.  This also renames
the buffer to correspond to the new file.  The next time the buffer is saved it
will go in the newly specified file.

FILENAME nil or an empty string means mark buffer as not visiting any file.

The optional second argument NO-QUERY, if non-nil, inhibits asking for
confirmation in the case where another buffer is already visiting FILENAME.

The optional third argument ALONG-WITH-FILE, if non-nil, means that the old
visited file has been renamed to the new name FILENAME.
#+end_defun
**** not-modified

If you have changed a buffer but do not wish to save the changes, you should
take some action to prevent it.  Otherwise, each time you use =C-x s= or =C-x
C-c=, you are liable to save this buffer by mistake.  One thing you can do is
type =M-~= (not-modified), which clears out the indication that the buffer is
modified.  If you do this, none of the save commands will believe that the
buffer needs to be saved. (‘~’ is often used as a mathematical symbol for
“not”; thus =M-~= is “not”, metafied.)

#+attr_texinfo: :options not-modified &optional ARG
#+begin_defun
This function is for interactive use only; in Lisp code use
~set-buffer-modified-p~ instead.

Mark current buffer as unmodified, not needing to be saved.

With prefix ARG, mark buffer as modified, so C-x C-s will save.
#+end_defun
**** write-file-functions---a hook

#+attr_texinfo: :options write-file-functions
#+begin_defvar
This variable a list of functions to be called before writing out a buffer to
its visited file.  If one of them returns non-‘nil’, the file is considered
already written and the rest of the functions are not called, nor is the usual
code for writing the file executed.  In addition, if a function in
~write-file-functions~ returns non-‘nil’, it is responsible for making a backup
file, using the following code:

: (or buffer-backed-up (backup-buffer))

Even though this is not a normal hook, you can use ‘add-hook’ and ‘remove-hook’
to manipulate the list.
#+end_defvar

**** write-contents-functions---a hook

#+attr_texinfo: :options write-contents-functions
#+begin_defvar
This works just like ‘write-file-functions’, but it is intended for hooks that
pertain to the buffer’s contents, not to the particular visited file or its
location, and can be used to create arbitrary save processes for buffers that
aren’t visiting files at all.  Such hooks are usually set up by major modes, as
buffer-local bindings for this variable.

If any of the functions in this hook returns non-‘nil’, the file is considered
already written and the rest are not called and neither are the functions in
~write-file-functions~.
#+end_defvar

**** before-save-hook

#+attr_texinfo: :options before-save-hook
#+begin_defvar
This normal hook runs before a buffer is saved in its visited file, regardless
of whether that is done normally or by one of the hooks described above.
#+end_defvar
**** after-save-hook

#+attr_texinfo: :options after-save-hook
#+begin_defvar
This normal hook runs after a buffer has been saved in its visited file.
#+end_defvar

*** Backing Up Files

**** ~make-backup-files~---a variable

Emacs can be configured to make backup files on save in several different
ways, using the variable ~make-backup-files~, which by default is t.

- ~make-backup-files~ ::

  - non-nil means make a backup of a file the first time it is saved.  This can
    be done:

    - by renaming the file; the existing file is renamed so that it is a backup
      file; the buffer is then written into a new file with the original file
      name.

    - by copying the file; the existing file is copied into a backup file; then
      the buffer is written into the file, overwriting it with new content.

    - the choice of renaming or copying is controlled by the variables:

      - ~backup-by-copying~ :: non-nil means using copying

      - ~backup-by-copying-when-linked~ :: non-nil means using copying for
        files with multiple names.  The alternate names will refer to the
        latest version as edited.  ~backup-by-copying~ must be nil.

      - ~backup-by-copying-when-mismatch~ :: Non-nil means create backups by
        copying if this preserves owner or group.

      - ~backup-by-copying-when-priviledged-mismatch~ :: Non-nil means create
        backups by copying to preserve a privileged owner.

      - ~backup-inhibited~ :: If non-nil, backups will be inhibited.

**** Making Interactive Backups

By default, Emacs will only make a backup of a file the first time it is
saved.  You can explicitly control further backups as follows:

- =C-u C-x C-s= :: the version thus saved will be made into a backup file if
  you save the buffer again.

- =C-u C-u C-x C-s= :: saves the buffer, but first makes the previous file
  contents into a new backup file.

- =C-u C-u C-u C-x C-s= :: does both things: it makes a backup from the
  previous contents, and arranges to make another from the newly saved contents
  if you save again.

**** Making Backups into Specific Directories

- ~backup-directory-alist~---a variable ::

  Use this variable to specify that files matching certain patterns should be
  backed up in specific directories.  A typical use is to add an element =("."
  . dir)= to make all backups in the directory with absolute name ~dir~.
  Alternatively, adding, =("." . ".~")= would make backups in the invisible
  subdirectory =.~= of the original file’s directory.

**** Single or Numbered Backups

When Emacs makes a backup file, its name is normally constructed by appending
‘~’ to the file name being edited.

Emacs can also make numbered backup files. Numbered backup file names contain
‘.~’, the number, and another ‘~’ after the original file name.

- ~version-control~ --- a variable :: determines whether to make single backup
  files or mul- tiple numbered backup files.  The usual way to set this
  variable is globally, through your init file or the customization buffer.
  But you can set version-control locally in an individual buffer to control
  the making of backups for that buffer’s file.

  - nil :: make single backups, unless files already have numbered backups.

  - t :: make numbered backups.

  - never :: never make numbered backups; always make single backups.

- ~make-backup-file-name-function~ :: tell Emacs what function to use to make
  backup names.

**** Automatic Backup Deletion

To prevent excessive consumption of disk space, Emacs can delete numbered
backup versions automatically.  Generally Emacs keeps the first few backups and
the latest few backups, deleting any in between.  This happens every time a new
backup is made.

- ~kept-old-versions~---a variable ::

  the number of oldest (lowest-numbered) backups to keep (default 2)

- ~kept-new-version~---a variable ::

  the number of newest (highest-numbered) ones to keep (default 2)

- ~delete-old-versions~ :: if t, Emacs deletes the excess backup files
  silently.  If nil, the default, Emacs asks you whether it should delete the
  excess backup versions.  If any other value, Emacs never automatically
  deletes backups.

- Dired =.= command :: can be used to delete old versions.
*** Writing to Files
You can write the contents of a buffer, or part of a buffer, directly to a file
on disk using the functions:

- ~append-to-file~

- ~write-region~


But don’t use these functions to write to files that are being visited.

**** append-to-file

#+attr_texinfo: :options append-to-file start end filename
#+begin_defun
This function appends the contents of the region delimited by START and END in
the current buffer to the end of file FILENAME.  If that file does not exist,
it is created.

When called from Lisp, this function is completely equivalent to:

: (write-region start end filename t)

- RETURN VALUE :: nil
#+end_defun

**** write-region

#+attr_texinfo: :options write-region start end filename &optional append visit lockname mustbenew
#+begin_defun
This function writes the region delimited by START and END in the current
buffer into the file specified by FILENAME.

If START is ‘nil’, then the command writes the entire buffer contents (_not_
just the accessible portion) to the file and ignores END.

If START is a string, then ‘write-region’ writes or appends that string, rather
than text from the buffer.  END is ignored in this case.

If APPEND is non-‘nil’, then the specified text is appended to the existing
file contents (if any).  If APPEND is a number, ‘write-region’ seeks to that
byte offset from the start of the file and writes the data from there.
#+end_defun

**** with-temp-file

#+attr_texinfo: :options with-temp-file file body
#+begin_defun
The ‘with-temp-file’ macro evaluates the BODY forms with a temporary buffer as
the current buffer; then, at the end, it writes the buffer contents into file
FILE.  It kills the temporary buffer when finished, restoring the buffer that
was current before the ‘with-temp-file’ form.  Then it returns the value of the
last form in BODY.

See also [[*with-temp-buffer][~with-temp-buffer~]].
#+end_defun

**** make-temp-file

Some programs need to write temporary files.  Here is the usual way to
construct a name for such a file.  The job of ~make-temp-file~ is to prevent
two different users or two different jobs from trying to use the exact same
file name.

#+attr_texinfo: :options make-temp-file prefix &optional dir-flag suffix text
#+begin_defun
This function creates a temporary file and returns its name by adding to PREFIX
some random characters that are different in each Emacs job.

- PREFIX :: a user-provided string that should be unique to this program; this
  helps Emacs generate a unique file name despite numerous programs in
  different jobs running simultaneously and using this macro.

- DIR-FLAG :: if non-nil, create a new, empty directory instead of a file.

- SUFFIX :: if non-nil, it is added to the end of the file name.

- TEXT :: if a string, insert it into the new file before returning; DIR-FLAG
  should be nil;

  if nil, leave the file empty.

- RETURN VALUE :: the newly-created file name pointing to a new-created file
  that is empty unless TEXT contains a string, in which case the file contains
  TEXT.
#+end_defun

If you want to write a temporary file which is likely to be small, you should
compute the directory like this:

#+caption:Creating a Small Temporary File
#+name:create-small-temp-file
#+begin_src elisp :eval never
  (make-temp-file
   (expand-file-name prefix
                     (or small-temporary-file-directory
                         temporary-file-directory)))
#+end_src

**** temporary-file-directory---a user option

The default directory for temporary files is controlled by the variable
~temporary-file-directory~.  This variable gives the user a uniform way to
specify the directory for all temporary files.  It will have a default value
consistent with the operating system so it does not need to be explicitly
created.

#+attr_texinfo: :options temporary-file-directory
#+begin_defvar
This variable specifies the directory name for creating temporary files.  Its
value should be a [[directory-name][directory name]], but a program should be able to handle a
[[directory-file-name][directory file name]] instead.

The default value is determined in a reasonable way for your operating system;
it is based on the =TMPDIR=, =TMP= and =TEMP= environment variables, with a
fall-back to a system-dependent name if none of these variables is defined.  At
the time of writing this, this variable’s default value is:
: /var/folders/x_/v2pfz45s7h3245q6wlvvvnyh0000gn/T/

The variable’s value can be customized from within Emacs.

The directory ~/var/folders/~ is owned by =root=, but the folders ~x/~ and
above are owned by the User.  ~x/~ was apparently created at the time the User
account was created, and the folders inside it were created in the recent past.

This variable works well as the optional default directory for
[[*expand-file-name][~expand-file-name~]].
#+end_defvar

**** small-temporary-file-directory---a user option

#+attr_texinfo: :options small-temporary-file-directory
#+begin_defvar
The directory for writing small temporary files.  If non-nil, use this
directory instead of [[*temporary-file-directory---a user option][~temporary-file-directory~]] when creating small temporary
files.  This is for systems that have fast storage with limited space, such as
a RAM disk.

It’s default value is nil.  It’s value can be customized.
#+end_defvar
*** Deleting Files
**** delete-file
Delete file named FILENAME.  If it is a symlink, remove the symlink.

#+attr_texinfo: :options delete-file filename &optional trash
#+begin_defun
- FILENAME :: file name to delete.

- TRASH :: if non-nil, and if the variable [[*delete-by-moving-to-trash---a variable][~delete-by-moving-to-trash~]] is also
  non-nil, then use the Trash facility to delete the file.
#+end_defun

** Buffers

#+texinfo:@heading Working with Buffers

- [[bufferp][~bufferp~]]

- [[list-buffers][~list-buffers~]] invoke Buffer Menu

- [[ibuffer][=ibuffer=]] invoke Ibuffer-mode

- [[Icomplete][=Icomplete=]] global minor mode


#+texinfo:@heading Buffer Names

- [[*buffer-name][~buffer-name~]] return the name of the buffer

- [[*rename-buffer][~rename-buffer~]] rename a buffer


#+texinfo:@heading Interactive Buffer Commands using Windows

- [[switch-to-buffer][~switch-to-buffer~]] display a buffer in a window

- [[switch-to-buffer-other-window][~switch-to-buffer-other-window~]]

- [[switch-to-buffer-other-frame][~switch-to-buffer-other-frame~]]

- [[previous-buffer][~previous-buffer~]]

- [[next-buffer][~next-buffer~]]

- [[beginning-of-buffer][~beginning-of-buffer~]]

- [[end-of-buffer][~end-of-buffer~]]


#+texinfo:@heading Positions within a Buffer

- [[point][~point~]]

- [[point-min][~point-min~]]

- [[point-max][~point-max~]]

- [[buffer-end][~buffer-end~]]

- [[buffer-size][~buffer-size~]]


#+texinfo:@heading Moving Around Within a Buffer

- [[goto-char][~goto-char~]]

- [[forward-char][~forward-char~]]

- [[backward-char][~backward-char~]]

- [[forward-word][~forward-word~]]

- [[backward-word][~backward-word~]]

- [[goto-line][~goto-line~]]

- [[forward-line][~forward-line~]]

- [[beginning-of-line][~beginning-of-line~]]

- [[line-beginning-position][~line-beginning-position~]]

- [[end-of-line][~end-of-line~]]

- [[line-end-position][~line-end-position~]]

- [[forward-line][~forward-line~]]

- [[count-lines][~count-lines~]]

- [[count-words][~count-words~]]

- [[line-number-at-pos][~line-number-at-pos~]]

- [[bobp][~bobp~]]

- [[eobp][~eobp~]]

#+texinfo:@heading The Current Buffer for Editing

- [[*current-buffer][~current-buffer~]] return the current buffer

- [[*set-buffer][~set-buffer~]] make buffer current for editing

- [[*save-current-buffer][~save-current-buffer~]] save the current buffer before editing

- [[*with-current-buffer][~with-current-buffer~]] make buffer current temporarily for editing

- [[*with-temp-buffer][~with-temp-buffer~]] create a temporary buffer for editing


#+texinfo:@heading Working with Buffer Names

- [[*get-buffer][~get-buffer~]] return a buffer given a name

- [[other-buffer][~other-buffer~]] return the previous buffer

- [[*generate-new-buffer-name][~generate-new-buffer-name~]] just return a unique buffer name

- [[*buffer-file-name][~buffer-file-name~]] return the visited file's name

- [[*get-file-buffer][~get-file-buffer~]] return the buffer visiting the file name (exact) or nil

- [[*find-buffer-visiting][~find-buffer-visiting~]] return a buffer visiting the file name (not exact)

- [[set-visited-file-name][~set-visited-file-name~]] change the name of the visited file


#+texinfo:@heading Working with Buffer Contents

- [[*buffer-string][~buffer-string~]] return a buffer as a string


#+texinfo:@heading Creating and Killing Buffers

- [[*get-buffer-create][~get-buffer-create~]] creates or returns an existing buffer

- [[*generate-new-buffer][~generate-new-buffer~]] generate a new buffer with a unique name

- [[*create-file-buffer][~create-file-buffer~]] create a buffer and visit a file

- [[*kill-buffer][~kill-buffer~]] kill a buffer


*** About Buffers

#+texinfo:@heading A Buffer is a Lisp Object---a special data type

#+cindex:buffer
A /buffer/ is a Lisp object containing text to be edited.  Buffers in Emacs
editing are objects that have distinct names and hold text that can be edited.
Each time you visit a file, a buffer is used to hold the file’s text.  Each
buffer has a unique name, which can be of any length.  Most buffers are made by
visiting files, and their names are derived from the files’ names; however, you
can also create an empty buffer with any name you want.

Buffers appear to Lisp programs as a special data type.  You can think of the
contents of a buffer as a string that you can extend; insertions and deletions
may occur in any part of the buffer.

#+texinfo:@heading Files and Windows

Buffers are used to hold the contents of files that are being visited; there
may also be buffers that are not visiting files.  For examppl each time you
invoke Dired, a buffer is used to hold the directory listing.  If you send a
message with =C-x m=, a buffer is used to hold the text of the message.  When
you ask for a command’s documentation, that appears in a buffer named =*Help*=.
Each buffer, including the current buffer, may or may not be displayed in any
windows.  When a buffer is displayed in a window, its name is shown in the mode
line.

#+texinfo:@heading Current Buffer

#+cindex:current buffer
Only one buffer is selected and designated the [[*Current Buffer][current buffer]] at any time.
When a command operates on “the buffer”, this really means that it operates on
the /current buffer/.  When there is only one Emacs window, the buffer
displayed in that window is current.  When there are multiple windows, the
buffer displayed in the “selected window” is current.

#+texinfo:@heading Properties

#+cindex:text properties
A buffer’s “contents” consist of a series of characters, each of which
optionally carries a set of text properties that can specify more information
about that character.

#+texinfo:@heading Buffer-Local Variables

#+cindex:buffer-local variables
#+cindex:local variables
Buffer-specific information that is directly accessible is stored in
/buffer-local variable bindings/, which are variable values that are effective
only in a particular buffer.  This feature allows each buffer to override the
values of certain variables.  Most major modes override variables.

Aside from its textual contents, each buffer records several pieces of
information, such as what file it is visiting (if any), whether it is modified,
and what major mode and minor modes are in effect.  These are stored in
“buffer-local variables”---variables that can have a different value in each
buffer.

#+texinfo:@heading Buffer Positions

#+cindex:position
A /position/ is the index of a character in the text of a buffer.  A position
actually identifies the place between characters or before the first character,
or after the last character.  One speaks of the character either before or
after a given position.  When one says the character “at” a position, one
usually is referring to the character /after/ that position.

#+cindex:marker
Positions can be represented either by integers or by markers.  A /marker/ is a
special object that relocates automatically when text is inserted or deleted so
it stays with the surrounding characters.

<<bufferp>>
#+attr_texinfo: :options bufferp @var{object}
#+begin_defun
Return t if OBJECT is an editor buffer.
#+end_defun

*** Interactive Commands for Creating and Selecting Buffers

#+findex:list-buffers
- ~list-buffers &optional ARG~ (=C-x C-b=) ::
  <<list-buffers>>
  Invoke the Buffer Menu.  Display a list of existing buffers.  With prefix
  argument ARG, show only buffers that are visiting files.
  #+findex:buffer-menu
- ~buffer-menu &optional ARG~ ::
- ~buffer-menu-other-window~ ::
  Switch to the Buffer Menu.

  |            C            |       R       |           M           | Buffer | Size | Mode       | File         |
  |           <c>           |      <c>      |          <c>          |        |      |            |              |
  |-------------------------+---------------+-----------------------+--------+------+------------+--------------|
  | ~.~ the current buffer  | ~%~ read-only |     ~*~ modified      | name   | size | major mode | visited file |
  | ~>~ marked for display  |               | ~S~ marked for saving |        |      |            |              |
  | ~D~ marked for deletion |               |                       |        |      |            |              |


- ~buffer-menu-mode~ is the major mode for Buffer Menu buffers.

  - q --- leave Buffer Menu
  - RET --- select new current buffer this window
  - o --- select new current buffer other window
  - V --- select new current buffer in View mode
  - M-x Buffer-menu-view-other-window
  - C-o --- display buffer in another window
  - m --- make for display
  - v --- select this buffer and show marked buffers in other windows
  - 1 --- select this buffer in full-frame window
  - 2 --- select this buffer in half-window and other buffer in half window
  - M-s a C-s --- Incremental search in marked buffers
  - M-s a C-M-s --- Isearch for regext in marked buffers
  - t --- visit-tags-table this buffer
  - ~ --- clear modified flog on buffer
  - s --- mark for saving
  - C-k --- mark for deletion
  - C-d --- makr for deletion and move up
  - x --- delete or save marked buffers
  - u --- remove marks (ARG and move up)
  - M-DEL --- remove a mark from all lines
  - U --- remove all marks from all lines
  - DEL --- back up a line and remove marks
  - % --- toggle read-only status
  - g --- update
  - T --- toggle displaying only file buffers
  - b --- bury buffer

#+cindex:Icomplete global minor mode
- =Icomplete= <<Icomplete>>global minor mode (=M-x icomplete-mode=) :: provides
  a convenient way to quickly select an element among the possible completions
  in a minibuffer.  When enabled, typing in the minibuffer continuously
  displays a list of possible completions that match the string you have typed.
  At any time, you can type ‘C-j’ to select the first completion in the list.
  There are two ways to make an item first:

  1. You can type more of the completion name and thus narrow down the list;

  2. You can use ‘C-.’ and ‘C-,’ to rotate the list until the desired buffer is
     first.

  ‘M-<TAB>’ will select the first completion in the list, like ‘C-j’ but
  without exiting the minibuffer, so you can edit it further.  This is
  typically used when entering a file name, where ‘M-<TAB>’ can be used a few
  times to descend in the hierarchy of directories.

  - ~icomplete-mode~ variable :: nil to deselect; t to select.


#+cindex:Ibuffer-mode
- ~ibuffer~ :: <<ibuffer>>Begin using Ibuffer to edit a list of buffers.  Make
  a list of buffers and operate on them in Dired-like fashion.  Type ‘h’ after
  entering ibuffer for more information.
  #+findex:switch-to-buffer
- ~switch-to-buffer BUFFER-OR-NAME~ (=C-x b BUFFER=) ::
  <<switch-to-buffer>>

  If called interactively, read the buffer name using ‘read-buffer’.  The
  variable ~confirm-nonexistent-file-or-buffer~ determines whether to request
  confirmation before creating a new buffer.  If BUFFER-OR-NAME is a string
  that does not identify an existing buffer, create a buffer with that name.
  If BUFFER-OR-NAME is =nil=, switch to the buffer returned by ~other-buffer~
  (Return most recently selected buffer other than BUFFER).

  *WARNING*: This is NOT the way to work on another buffer temporarily within a
  Lisp program!  Use [[*set-buffer][~set-buffer~]] instead.  That avoids messing with the
  window-buffer correspondences.

- ~switch-to-buffer-other-window~ (=C-x 4 b BUFFER=) ::
  <<switch-to-buffer-other-window>>

- ~switch-to-buffer-other-frame~ (=C-x 5 b BUFFER=) ::
  <<switch-to-buffer-other-frame>>

- ~previous-buffer~ (=C-x <LEFT>=) ::
  <<previous-buffer>>

- ~next-buffer~ (=C-x <RIGHT>=) ::
  <<next-buffer>>

- ~beginning-of-buffer~ (=M-<=) ::
  <<beginning-of-buffer>>

  This function is for interactive use only; move point to the beginning of the
  buffer.  With numeric arg N, put point N/10 of the way from the beginning.

- ~end-of-buffer~ (=M->=) ::
  <<end-of-buffer>>

  This function is for interactive use only; move point to the end of the
  buffer.  With numeric arg N, put point N/10 of the way from the end.  If the
  buffer is narrowed, this command uses the end of the accessible part of the
  buffer.

- ~goto-char~ (=M-g c=) ::
  <<goto-char>>

  #+attr_texinfo: :options goto-char position
  #+begin_defun
  Set point to POSITION.  The beginning of the buffer is ~(point-min)~, and the
  end is ~(point-max)~.

  - POSITION :: a number or marker indicating buffer position.

  - RETURN VALUE :: POSITION


  If narrowing is in effect, position still counts from the beginning of the
  buffer, but point cannot go outside the accessible portion.  If position is
  out of range, ~goto-char~ moves point to the beginning or the end of the
  accessible portion.
  #+end_defun

  To move point to the beginning (end) of the buffer, write:
  : (goto-char (point-min))
  : (goto-char (point-max))

- ~forward-char~ ~backward-char~ ::
  <<forward-char>> <<backward-char>>

  #+attr_texinfo: :options forward-char &optional count
  #+begin_defun
  Move point COUNT characters forward (backward if COUNT is negative).  Signal
  error if the beginning or ending of the buffer is reached.

  - COUNT :: if nil, use a default value of 1.
  #+end_defun

- ~forward-word~ ~backward-word~ ::
  <<forward-word>> <<backward-word>>

  #+attr_texinfo: :options forward-word &optional count
  #+begin_defun
  Move point forward (backward) COUNT words.

  - COUNT :: if nil, default is 1.

  - RETURN VALUE :: t; but if an edge of the buffer or a field boundary is
    reached, point is left there and the function returns nil.
  #+end_defun

- ~forward-word-strictly~ ~backward-word-strictly~ ::

  See above

- ~goto-line LINE &optional BUFFER~ (=M-g g=) ::
  <<goto-line>>

  This function is for interactive use only (because it sets mark); in Lisp
  code use [[forward-line][~forward-line~]] instead.

  Go to LINE, counting from line 1 at beginning of buffer.  If called
  interactively, a numeric prefix argument specifies LINE; without a numeric
  prefix argument, read LINE from the minibuffer.

  If optional argument BUFFER is non-nil, switch to that buffer and move to
  line LINE there.  If called interactively with C-u as argument, BUFFER is the
  most recently selected other buffer.

  This function is usually the wrong thing to use in a Lisp program. What you
  probably want instead is something like:

  #+begin_src elisp :eval no
  (goto-char (point-min))
  (forward-line (1- N))
  #+end_src

  If at all possible, an even better solution is to use char counts rather than
  line counts.

- ~goto-line~ (=C-u M-g M-g=) ::

  reads a number N using the minibuffer, selects the most recently selected
  buffer other than the current buffer in another window, and then moves point
  to the beginning of line number N in that buffer.

  This is mainly useful in a buffer that refers to line numbers in another
  buffer: if point is on or just after a number, ‘goto-line’ uses that number
  as the default for N.

  Note that prefix arguments other than just ‘C-u’ behave differently.  ‘C-u 4
  M-g M-g’ goes to line 4 in the _current_ buffer, without reading a number
  from the minibuffer.

- ~forward-line &optional N~ ::
  <<forward-line>>

  #+attr_texinfo: :options forward-line &optional n
  #+begin_defun
  Move N lines forward (backward if N is negative).  Precisely, if point is on
  line I, move to the start of line I + N.  If there isn’t room, go as far as
  possible (no error).

  - N :: number of lines to move;

  - RETURN VALUE :: Returns the count of lines left to move.  If moving
    forward, that is N minus number of lines moved; if backward, N plus number
    moved.
  #+end_defun

- ~beginning-of-line~ ::
  <<beginning-of-line>>

  Move point to the beginning of current line.  With argument N > 1, move
  forward =N - 1= lines first.  Stop when reaching the beginning or ending of
  the buffer without error.

- ~line-beginning-position~ ::
  <<line-beginning-position>>

  Return the position that ~(beginning-of-line count)~ would move to.

  - RETURN VALUE :: Return the character position of the first character on the
    current line.  With optional argument N, scan forward N - 1 lines first.
    If the scan reaches the end of the buffer, return that position.

- ~end-of-line~ ::
  <<end-of-line>>

  Move point to end of current line (in the logical order). With argument N not
  nil or 1, move forward N - 1 lines first.  If point reaches the beginning or
  end of buffer, it stops there.

- ~line-end-position~ ::
  <<line-end-position>>

  Return the character position of the last character on the current line. With
  argument N not nil or 1, move forward N - 1 lines first.  If scan reaches end
  of buffer, return that position.

- ~forward-line~ ::
  <<forward-line>>

  Move N lines forward (backward if N is negative).  If point is on line I,
  move to the start of line I + N.  If there isn’t room, go as far as possible
  (no error).

  Returns the count of lines left to move.  That is, N minus moved lines.

- ~count-lines start end~ ::
  <<count-lines>>

  Return number of lines between START and END.  This is usually the number of
  newlines between them.

- ~count-words start end~ ::
  <<count-words>>

  Count words between START and END.

- ~line-number-at-pos~ ::
  <<line-number-at-pos>>

  Return buffer line number at position POS. If POS is nil, use current buffer
  location.

- bobp :: Return t if point is at the beginning of the buffer.
  <<bobp>>

- eobp :: Return t if point is at the end of the buffer.
  <<eobp>>

*** Current Buffer
#+cindex:current buffer
At any time, one buffer is designated the /current buffer/---the buffer in
which most editing takes place.  Most of the primitives for examining or
changing text operate implicitly on the current buffer.

Normally, the buffer displayed in the selected window is the current buffer,
but this is not always so: a Lisp program can temporarily designate any buffer
as current in order to operate on its contents, without changing what is
displayed on the screen.

**** current-buffer

#+attr_texinfo: :options current-buffer
#+begin_defun
Return the current buffer as a Lisp object.
#+end_defun

**** set-buffer

#+attr_texinfo: :options set-buffer @var{buffer-or-name}
#+begin_defun
Make buffer BUFFER-OR-NAME current for editing operations.

- BUFFER-OR-NAME :: may be a buffer or the name of an existing buffer.
#+end_defun

When an editing command returns to the editor command loop, Emacs automatically
calls ~set-buffer~ on the buffer shown in the selected window.  you should not
use set-buffer to switch visibly to a different buffer; for that, use the
functions described in Switching Buffers.  However, when writing a Lisp
function, do not rely on this behavior of the command loop to restore the
current buffer after an operation.

To operate temporarily on another buffer, put the ~set-buffer~ within a
[[*save-current-buffer][~save-current-buffer~]] form.

**** save-current-buffer

#+attr_texinfo: :options save-current-buffer &rest body
#+begin_defun
Record which buffer is current; execute BODY; can use ~set-buffer~ to make a
different buffer current without displaying it.  At the conclusion of BODY,
make the original buffer current.

BODY is executed just like ‘progn’.
#+end_defun

**** with-current-buffer

#+attr_texinfo: :options with-current-buffer buffer-or-name &rest body
#+begin_defun
Execute the forms in BODY with BUFFER-OR-NAME temporarily current.

- BUFFER-OR-NAME :: must be a buffer or the name of an existing buffer.

- RETURN VALUE :: The value returned is the value of the last form in BODY.
#+end_defun

**** with-temp-buffer

#+attr_texinfo: :options with-temp-buffer &rest body
#+begin_defun
Create a temporary buffer, and evaluate BODY there like ‘progn’.

- RETURN VALUE :: The return value is the value of the last form in body.  You
  can return the contents of the temporary buffer by using ~buffer-string~ as
  the last form.
#+end_defun

**** buffer-string

#+attr_texinfo: :options buffer-string
#+begin_defun
Return the contents of the current buffer as a string.  If narrowing is in
effect, this function returns only the visible part of the buffer.
#+end_defun

*** Positions
#+cindex:point
/Point/ is a special buffer position used by many editing commands, and like
other positions, designates a place between two characters (or before the first
character, or after the last character), rather than a particular character.
Usually terminals display the cursor over the character that immediately
follows point; point is actually before the character on which the cursor sits.

The value of point is a number no less than 1, and no greater than the buffer
size plus 1.

Each buffer has its own value of point.  Each window also has its own value of
point, independent of the value of point in other windows displaying the same
buffer.  This makes it useful to have multiple windows showing one buffer:
This is why point can have different values in various windows that display the
same buffer.

**** point

#+attr_texinfo: :options point
#+begin_defun
Return value of point as an integer.
#+end_defun

**** point-min

#+attr_texinfo: :options point-min
#+begin_defun
Return the minimum permissible value of point in the current buffer.  This is
1, unless narrowing (a buffer restriction) is in effect.
#+end_defun

**** point-max

#+attr_texinfo: :options point-max
#+begin_defun
Return the maximum permissible value of point in the current buffer.  This is
(1+ (buffer-size)), unless narrowing (a buffer restriction) is in effect, in
which case it is less.
#+end_defun

**** buffer-end

#+attr_texinfo: :options buffer-end arg
#+begin_defun
- ARG :: If position, return the end position (~point-max~) of the buffer.
  Otherwise, return the beginning (~point-min~) of the buffer.
#+end_defun

**** buffer-size

#+attr_texinfo: :options buffer-size &optional buffer
#+begin_defun
Return the number of characters in the current buffer, without taking into
account narrowing.

- BUFFER :: if non-nil, return the number of characters in this buffer.


To count the number of characters in the accessible portion of the current
buffer, use ~(- (point-max) (point-min))~, and to count the number of
characters in some other BUFFER, use ~(with-current-buffer BUFFER (-
(point-max) (point-min)))~.
#+end_defun

*** Buffer Names and File Names
#+cindex:buffer name
#+cindex:buffer-or-name
Each buffer has a unique name, which is a string.  Many of the functions that
work on buffers accept either a buffer or a buffer name as an argument.  Any
argument called BUFFER-OR-NAME is of this sort.  Any argument called BUFFER must
be an actual buffer object, not a name.

#+texinfo:@heading Buffer File Names

#+cindex:buffer file name
The /buffer file name/ is the name of the file that is visited in that buffer.
When a buffer is not visiting a file, its buffer file name is ‘nil’.  Most of
the time, the buffer name is the same as the nondirectory part of the buffer
file name, but the buffer file name and the buffer name are distinct and can be
set independently.

#+texinfo:@heading Buffer Name Functions

**** buffer-name

#+attr_texinfo: :options buffer-name &optional buffer
#+begin_defun
This function returns the name of BUFFER as a string.  BUFFER defaults to the
current buffer.
#+end_defun

**** rename-buffer

#+attr_texinfo: :options rename-buffer newname &optional unique
#+begin_defun
This function renames the current buffer to NEWNAME.

Ordinarily, ‘rename-buffer’ signals an error if NEWNAME is already in use.
However, if UNIQUE is non-‘nil’, it modifies NEWNAME to make a name that is not
in use.

This function returns the name actually given to the buffer.
#+end_defun

Also ~rename-uniquely~

**** get-buffer

#+attr_texinfo: :options buffer-or-name
#+begin_defun
This function returns the buffer specified by BUFFER-OR-NAME.

If BUFFER-OR-NAME is a string and there is no buffer with that name, the value
is ‘nil’.
#+end_defun

**** other-buffer

#+attr_texinfo: :options other-buffer &optional buffer visible-ok frame
#+begin_defun
Return most recently select buffer other than BUFFER.  This is done by scanning
the selected or specified frame’s buffer list first, followed by the list of
all buffers.

- BUFFER :: Return a buffer other than this one if possible; ignore this buffer
  completely unless it is a live buffer.

- VISIBLE-OK :: Buffers not visible in windows are preferred to visible
  buffers, unless optional second argument VISIBLE-OK is non-nil.

- FRAME :: if non-nil, and is a live frame, use that frame’s buffer list, not
  the selected frame’s buffer list.

- RETURN VALUE :: return a found buffer; if no other buffer exists, return the
  =*scratch*= buffer, and create it if necessary.
#+end_defun

**** generate-new-buffer-name

#+attr_texinfo: :options starting-name &optional ignore
#+begin_defun
This function returns a name that would be unique for a new buffer---but does
not create the buffer.  It starts with STARTING-NAME, and produces a name not
currently in use for any buffer by appending a number inside of ‘<...>’.

If the optional second argument IGNORE is non-‘nil’, it should be a string, a
potential buffer name.  It means to consider that potential buffer acceptable,
if it is tried, even it is the name of an existing buffer (which would normally
be rejected).
#+end_defun

**** buffer-file-name

#+texinfo:@heading Buffer File Name Functions and Variables

#+attr_texinfo: :options buffer-file-name &optional buffer
#+begin_defun
This function returns the absolute file name of the file that BUFFER is
visiting (defaulting to the current buffer).  It returns 'nil' if BUFFER is not
visiting a file.
#+end_defun

**** buffer-file-name---a permanent buffer-local variable

#+attr_texinfo: :options buffer-file-name
#+begin_defvar
This buffer-local variable contains the name of the file being visited in the
current buffer, or ‘nil’ if it is not visiting a file.

Use [[*set-visited-file-name][~set-visited-file-name~]] to change this variable's value.
#+end_defvar

**** buffer-file-truename---a permanent buffer-local variable

#+attr_texinfo: :options buffer-file-truename
#+begin_defvar
This buffer-local variable holds the abbreviated [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Truenames.html#Truenames][truename]] of the file visited
in the current buffer, or ‘nil’ if no file is visited.
#+end_defvar

**** get-file-buffer

#+attr_texinfo: :options get-file-buffer filename
#+begin_defun
This function returns the buffer visiting file FILENAME, or 'nil' if there is
none.  The argument FILENAME, which must be a string, is expanded then compared
against the visited file names of all live buffers.  Note that the buffer’s
‘buffer-file-name’ must match the expansion of FILENAME exactly.

In unusual circumstances, there can be more than one buffer visiting the same
file name.  In such cases, this function returns the first such buffer in the
buffer list.
#+end_defun

**** find-buffer-visiting

#+attr_texinfo: :options find-buffer-visiting filename &optional predicate
#+begin_defun
This is like ‘get-file-buffer’, except that it can return any buffer visiting
the file possibly under a different name.  That is, the buffer’s
‘buffer-file-name’ does not need to match the expansion of FILENAME exactly, it
only needs to refer to the same file.

If PREDICATE is non-‘nil’, it should be a function of one argument, a buffer
visiting FILENAME.  The buffer is only considered a suitable return value if
PREDICATE returns non-‘nil’.
#+end_defun

**** set-visited-file-name
<<set-visited-file-name>>

#+attr_texinfo: :options set-visited-file-name filename &optional no-query along-with-file
#+begin_defun
If FILENAME is a non-empty string, this function changes (or sets) the name of
the file visited in the current buffer to FILENAME.  The next time the buffer
is saved it will go in the newly-specified file.

This command marks the buffer as modified.  It also renames the buffer to
correspond to the new file name, unless the new name is already in use.

If FILENAME is ‘nil’ or the empty string, that stands for “no visited file”.
In this case, ‘set-visited-file-name’ marks the buffer as having no visited
file, without changing the buffer’s modified flag.

Normally, this function asks the user for confirmation if there already is a
buffer visiting FILENAME.  If NO-QUERY is non-‘nil’, that prevents asking this
question.

If ALONG-WITH-FILE is non-‘nil’, that means to assume that the former visited
file has been renamed to FILENAME.  In this case, the command does not change
the buffer’s modified flag, nor the buffer’s recorded last file modification
time as reported by ‘visited-file-modtime’.  If ALONG-WITH-FILE is ‘nil’, this
function clears the recorded last file modification time, after which
‘visited-file
#+end_defun

*** Modifying Buffers

#+texinfo:@heading Modified Flag

#+cindex:modified flag
Emacs keeps a flag called the “modified flag” for each buffer, to record
whether you have changed the text of the buffer.  This flag is set to ‘t’
whenever you alter the contents of the buffer, and cleared to ‘nil’ when you
save it.

Some Lisp programs set the flag explicitly.  For example, the function
‘set-visited-file-name’ sets the flag to ‘t’, because the text does not match
the newly-visited file, even if it is unchanged from the file formerly visited.

**** buffer-modified-p

This function returns ‘t’ if the buffer BUFFER has been modified since it was
last read in from a file or saved, or ‘nil’ otherwise.

**** set-buffer-modified-p

This function marks the current buffer as modified if FLAG is non-‘nil’, or as
unmodified if the flag is ‘nil’.

Another effect of calling this function is to cause unconditional redisplay of
the mode line for the current buffer.

#+texinfo:@subheading @code{force-mode-line-update}

: (set-buffer-modified-p (buffer-modified-p))

**** restore-buffer-modified-p

Like ‘set-buffer-modified-p’, but does not force redisplay of mode lines.

**** not-modified

This command marks the current buffer as unmodified, and not needing to be
saved.

If ARG is non-‘nil’, it marks the buffer as modified, so that it will be saved
at the next suitable occasion.

Don’t use this function in programs, since it prints a message in the echo
area; use ~set-buffer-modified-p~ (above) instead.

**** buffer-modified-tick

This function returns BUFFER’s modification-count.  This is a counter that
increments every time the buffer is modified.

**** buffer-chars-modified-tick

This function returns BUFFER’s character-change modification-count.  Changes to
text properties leave this counter unchanged;

**** with-silent-modifications

Sometimes there’s a need for modifying buffer in a way that doesn’t really
change its text, like if only its text properties are changed.  If your program
needs to modify a buffer without triggering any hooks and features that react
to buffer modifications, use the ~with-silent-modifications~ macro.

**** Buffer Modification Time

When a buffer and its visited file are changed independently of each, saving
the buffer contents into the file would potentially lose new information.
Emacs therefore checks the file’s modification time using the functions
described below before saving the file.

**** verify-visited-file-modtime

This function compares what BUFFER (by default, the current-buffer) has
recorded for the modification time of its visited file against the actual
modification time of the file as recorded by the operating system.  The two
should be the same unless some other process has written the file since Emacs
visited or saved it.

The function returns ‘t’ if the last actual modification time and Emacs’s
recorded modification time are the same, ‘nil’ otherwise.

**** clear-visited-file-modtime

This function clears out the record of the last modification time of the file
being visited by the current buffer.  As a result, the next attempt to save
this buffer will not complain of a discrepancy in file modification times.

**** visited-file-modtime

This function returns the current buffer’s recorded last file modification
time, as a list of the form ‘(HIGH LOW MICROSEC PICOSEC)’.  (This is the same
format that ‘file-attributes’ uses to return time values;

**** set-visited-file-modtime

This function updates the buffer’s record of the last modification time of the
visited file, to the value specified by TIME if TIME is not ‘nil’, and
otherwise to the last modification time of the visited file.

**** ask-user-about-supersession-threat

This function is used to ask a user how to proceed after an attempt to modify a
buffer visiting file FILENAME when the file is newer than the buffer text.

**** Read-Only Buffers

Read-only buffers are used in two kinds of situations:

- A buffer visiting a write-protected file is normally read-only.

- Modes such as Dired and Rmail make buffers read-only when altering the
  contents with the usual editing commands would probably be a mistake.

**** buffer-read-only---a variable

This buffer-local variable specifies whether the buffer is read-only.

**** inhibit-read-only---a variable

If this variable is non-‘nil’, then read-only buffers and, depending on the
actual value, some or all read-only characters may be modified.

**** read-only-mode

This is the mode command for Read Only minor mode, a buffer-local minor mode.
When the mode is enabled, ‘buffer-read-only’ is non-‘nil’ in the buffer; when
disabled, ‘buffer-read-only’ is ‘nil’ in the buffer.

**** barf-if-buffer-read-only

This function signals a ‘buffer-read-only’ error if the current buffer is
read-only.

*** The Buffer List
*** Creating and Killing Buffers

#+texinfo:@heading Creating Buffers

#+cindex:create
There are two primitives for creating buffers, plus several others:

- ~get-buffer-create~ ::

  creates a buffer if it finds no existing buffer with the specified name;

- ~generate-new-buffer~ ::

  always creates a new buffer and gives it a unique name.

- ~with-output-to-temp-buffer~ ::

- ~create-file-buffer~ ::

#+texinfo:@heading Killing Buffers

#+cindex:kill
/Killing a buffer/ makes its name unknown to Emacs and makes the memory space
it occupied available for other use.  The ‘buffer-name’ of a buffer is ‘nil’
if, and only if, the buffer is killed.  If you kill a buffer that is current or
displayed in a window, Emacs automatically selects or displays some other
buffer instead.  Killing a buffer can change the current buffer.  If you kill a
buffer that is the base buffer of one or more indirect buffers, the indirect
buffers are automatically killed as well.

#+cindex:live buffer
A buffer that has not been killed is called a /live/ buffer.  To test whether a
buffer is live or killed, use the function ~buffer-live-p~ (see below).

**** get-buffer-create

#+attr_texinfo: :options get-buffer-create buffer-or-name
#+begin_defun
- BUFFER-OR-NAME :: a buffer of this name is returned.  It does not become the
  current buffer, though.  If the buffer exists, it is returned.  If no such
  buffer exists, a new buffer is created.

  The major mode of a newly-created buffer is set to Fundamental.

  If the buffer name begins with a space, undo information recording is
  disabled.
#+end_defun

**** generate-new-buffer

#+attr_texinfo: :options generate-new-buffer name
#+begin_defun

- NAME :: This function returns a newly created, empty buffer, but does not
  make it current.  The name of the buffer is generated by passing NAME to the
  function [[*generate-new-buffer-name][~generate-new-buffer-name~]].

  The major mode for the new buffer is set to Fundamental mode.
#+end_defun

**** with-output-to-temp-buffer

#+attr_texinfo: :options with-output-to-temp-buffer bufname &rest body
#+begin_defun
Bind ‘standard-output’ to buffer BUFNAME, eval BODY, then show that buffer.
#+end_defun

**** create-file-buffer

#+attr_texinfo: :options create-file-buffer filename
#+begin_defun
Create a suitably named buffer for visiting FILENAME, and return it.
#+end_defun

**** kill-buffer

#+attr_texinfo: :options kill-buffer &optional buffer-or-name
#+begin_defun
- BUFFER-OR-NAME ::

  The buffer (or current buffer if the name is omitted) is killed, freeing all
  its memory.

  Any processes that have this buffer as the /process-buffer/ are sent the
  =SIGHUP= (hangup) signal, which normally causes them to terminate.

  If the buffer to be killed has unsaved changes, the user is asked to
  confirm.  To prevent the request, clear the =modified= flag before calling
  this function.  See [[*Modifying Buffers][Modifying Buffers]].

  This function calls ~replace-buffer-in-windows~ for cleaning up all windows
  currently displaying the buffer to be killed.

- RETURN VALUE ::

  t is returned if the buffer is actually killed.  'nil' is returned if the
  user refuses to confirm or if the buffer is already dead.
#+end_defun

**** kill-buffer-query-functions---a variable

#+attr_texinfo: :options kill-buffer-query-functions
#+begin_defvar
Before confirming unsaved changes, ‘kill-buffer’ calls the functions in the
list ‘kill-buffer-query-functions’, in order of appearance, with no arguments.
The buffer being killed is the current buffer when they are called.  The idea
of this feature is that these functions will ask for confirmation from the
user.  If any of them returns ‘nil’, ‘kill-buffer’ spares the buffer’s life.
#+end_defvar

**** kill-buffer-hook---a permanent local variable

#+attr_texinfo: :options kill-buffer-hook
#+begin_defvar
This is a normal hook run by ‘kill-buffer’ after asking all the questions it is
going to ask, just before actually killing the buffer.  The buffer to be killed
is current when the hook functions run.
#+end_defvar

**** buffer-offer-save---a buffer-local user-option

#+attr_texinfo: :options buffer-offer-save
#+begin_defvar
If non-'nil', tells ~save-buffers-kill-emacs~ to offer to save that buffer.

If ~save-some-buffers~ is called with its second optional argument set to t, it
will also offer to save the buffer.

If set to the symbol =always=, both ~save-buffers-kill-emacs~ and
~save-some-buffers~ will always offer to save.
#+end_defvar

**** buffer-save-without-query---a buffer-local variable

#+attr_texinfo: :options buffer-save-without-query
#+begin_defvar
If non-'nil', tells ~save-buffers-kill-emacs~ and ~save-some-buffers~ to save
this buffer if it is modified without asking.
#+end_defvar

**** buffer-live-p

#+attr_texinfo: :options buffer-live-p object
#+begin_defun
Returns t if OBJECT is a live buffer, or 'nil' otherwise.
#+end_defun

*** Indirect Buffers
#+cindex:indirect buffer
#+cindex:base buffer
An /indirect buffer/ shares the text of some other buffer, which is called the
/base buffer/ of the indirect buffer.

The text of the indirect buffer is always identical to the text of its base
buffer; changes made by editing either one are visible immediately in the
other.

But in all other respects, the indirect buffer and its base buffer are
completely separate.  They can have different names, different values of point,
different narrowing, different markers, different major modes, and different
local variables.

An indirect buffer cannot visit a file, but its base buffer can.  If you try to
save the indirect buffer, that actually works by saving the base buffer.
Killing the base buffer effectively kills the indirect buffer, but killing an
indirect buffer has no effect on its base buffer.

**** make-indirect-buffer

The general way to make an indirect buffer.

#+attr_texinfo: :options make-indirect-buffer base-buffer name &optional clone
#+begin_defun
Create and return an indirect buffer for buffer BASE-BUFFER, named NAME.

- BASE-BUFFER :: should be a live buffer or the name of an existing buffer.

- NAME :: should be a string which is not the name of an existing buffer.

- CLONE :: if non-nil, preserve BASE-BUFFER's state in the indirect buffer; if
  nil, the indirect buffer's state is reset to default values.
#+end_defun

**** clone-indirect-buffer
This function creates and returns a new indirect buffer that shares the current
buffer’s base buffer and copies the rest of the current buffer’s attributes.

If DISPLAY-FLAG is non-‘nil’, as it always is in interactive calls, that means
to display the new buffer by calling ~pop-to-buffer~.

#+attr_texinfo: :options clone-indirect-buffer newname display-flag &optional norecord
#+begin_defun
Create an indirect buffer that is a twin copy of the current buffer.

- NEWNAME :: name to give to the new indirect buffer.  If nil, defaults to the
  current buffer's name, modified by adding an <N> suffix to it, or
  incrementing the N in an existing suffix.

- DISPLAY-FLAG :: if non-nil, show the new buffer with ~pop-to-buffer~.

- NORECORD :: if non-nil, do not put this buffer at the front fo the list of
  recently selected ones.

- RETURN VALUE :: the newly-created indirect buffer.
#+end_defun

**** clone-indirect-buffer-other-window---C-x 4 c

#+attr_texinfo: :options clone-indirect-buffer-other-window NEWNAME DISPLAY-FLAG &optional NORECORD
#+begin_defun
Like ~clone-indirect-buffer~, but display in another window.
#+end_defun

**** buffer-base-buffer

#+attr_texinfo: :options buffer-base-buffer &optional buffer
#+begin_defun
This function returns the base buffer of BUFFER, which defaults to the current
buffer.  If BUFFER is not indirect, the value is ‘nil’.  Otherwise, the value
is another buffer, which is never an indirect buffer.
#+end_defun

*** Swapping Text

**** buffer-swap-text

#+attr_texinfo: :options buffer-swap-text buffer
#+begin_defun
Swap the text between current buffer and BUFFER.

This function is very fast because it doesn’t move any text, it only changes
the internal data structures of the buffer object to point to a different chunk
of text.  Using it, you can pretend that a group of two or more buffers are
actually a single virtual buffer that holds the contents of all the individual
buffers together.

If you use ~buffer-swap-text~ on a file-visiting buffer, you should set up a
hook to save the buffer’s original text rather than what it was swapped with.
~write-region-annotate-functions~ works for this purpose.  You should probably
set ~buffer-saved-size~ to −2 in the buffer, so that changes in the text it is
swapped with will not interfere with auto-saving.
#+end_defun

** Insert File Contents

#+cindex:file, insert
#+cindex:insert file
#+attr_texinfo: :indic code
In a Lisp program, if you want to look at the contents of a file but not alter
it, the fastest way is to use ‘insert-file-contents’ in a temporary buffer.
Visiting the file is not necessary and takes longer.

- insert-file =C-x i= ::

     This function is for interactive use only; in Lisp code use
     ~insert-file-contents~ instead

- insert-file-contents ::

     #+attr_texinfo: :options insert-file-contents @var{filename} &optional @var{visit} @var{end} @var{replace}
     #+begin_defun
     Insert contents of file FILENAME after point.  Returns list of absolute
     file name and number of characters inserted.

     - VISIT if non-nil, the buffer’s visited filename and last save file
       modtime are set, and it is marked unmodified.

     - BEG and END specify what portion of the file to insert.
       These arguments count bytes in the file, not characters in the buffer.
       If VISIT is non-nil, BEG and END must be nil.

     - REPLACE if non-nil, replace the current buffer contents (in the
       accessible portion) with the file contents.  This is better than simply
       deleting and inserting the whole thing because (1) it preserves some
       marker positions and (2) it puts less data in the undo list.  When
       REPLACE is non-nil, the second return value is the number of characters
       that replace previous buffer contents.
     #+end_defun
* Editing
** Killing and Yanking

** Transposing Text

** Filling and Commenting

** Searching and Replacing

#+cindex:regular expression
When you search for text, you can do so either with regular expressions or
without.  Replacing text in Emacs is no different, but with the added benefit
of letting you leverage the power of elisp in the /replace/ portion of search
and replace.

In that sense, Emacs is different from other editors: you can use elisp and
regexp capturing groups together --- powerful, if you know elisp.

#+cindex:PCRE
#+cindex:regular expression, GNU standard
Emacs’s regular expression implementation is also different from PCRE.  It
follows the GNU standard for regular expressions with many additions (and quite
a few omissions) to make it suitable for both package developers and Emacs
users.

*** Regular Expressions

#+cindex:regexp
Emacs’s regexp engine is nowhere near as user-friendly as it could be.  It’s
old, weathered and too entrenched --- and heavily modified to suit Emacs’s
peculiar needs --- to be easily replaced.  In practical terms, that causes
confusion in regexp building for people unaccustomed to Emacs’s quirky regexp
engine.  It’s even worse if you write elisp as you have to escape the escape
character as Emacs’s C-style string reader would otherwise trigger on
backslashes.

I will not cover regular expressions in great detail since that is a whole book
onto itself.  Instead, I will tell you how Emacs’s regexp engine differs from
modern ones.

**** Backslashed Constructs

The following constructs require backslashes or Emacs will treat them like
literal characters:

| Construct | Description     |
|-----------+-----------------|
| =\pipe=   | Alternative     |
| =\(...\)= | Capturing group |
| =\{...\}= | Repetition      |
|-----------+-----------------|


See also [[*Backslash Constructs][Backslash Constructs]]

**** Missing Features

**** Emacs-Only Features

#+cindex:match construct
#+cindex:Unicode
One area where Emacs’s regexp engine does shine is its support for /match
constructs/ and /Unicode support/:

#+caption:Match Constructs and Unicode Support
#+name:match-constructs-and-unicode-support
| Constructs   | Description                                               |
|--------------+-----------------------------------------------------------|
| =\<=, =\>=   | Matches beginning and end of word                         |
| =\_<=, =\_>= | Matches beginning and end of symbol                       |
| =\scode=     | Matches any character whose syntax table code is code     |
| =\Scode=     | Matches any character whose syntax table code is not code |
|--------------+-----------------------------------------------------------|

**** Syntax of Regular Expressions

#+cindex:syntax, regexp
#+cindex:regexp syntax
Regular expressions have a syntax in which a few characters are “special
constructs” and the rest are “ordinary”.

#+texinfo:@heading Special Characters

#+cindex:special characters, regexp
#+cindex:regexp special characters
The “special characters” are:

#+attr_texinfo: :indic code
- .
- *
- +
- ?
- [ and sometimes ]
- [: ... :]
- ^
- $
- \
- -


Any other character appearing in a regular expression is ordinary, unless a ‘\’
precedes it.

Things to note:

#+texinfo: :indic code
- ^ :: For historical compatibility reasons, ‘^’ can be used only at the
  beginning of the regular expression, or after ‘\(’, ‘\(?:’ or ‘\|’.

- $ :: For historical compatibility reasons, ‘$’ can be used only at the end of
  the regular expression, or before ‘\)’ or ‘\|’.

- \ :: also has special meaning in the read syntax of Lisp strings and must be
  quoted with ‘\’.

#+begin_example
\\   => \
\\\\ => \\
#+end_example

#+texinfo:@heading Character Alternatives

=[ ... ]= is a /character alternative/.

#+attr_texinfo: :indic code
- [ad] ::
- [a-z] ::
- [a-z$%.] ::
- []a-z]  :: To include a ‘]’ in a character alternative, you must make it the
  first character.
- []a-z-] :: To include a ‘-’, write ‘-’ as the first or last character of the
  character alternative, or as the upper bound of a range.
- ^ :: To include ‘^’ in a character alternative, put it anywhere but at the
  beginning.
  #+cindex:newline, regexp
- [^...] :: ‘[^’ begins a “complemented character alternative”.  This matches
  any character except the ones specified.  ‘^’ is not special in a character
  alternative unless it is the first character.  A complemented character
  alternative can match a newline, unless newline is mentioned as one of the
  characters not to match.  This is in contrast to the handling of regexps in
  programs such as ‘grep’.


#+texinfo:@heading Rules Regarding ]

The exact rules are that:
- at the beginning of a regexp, ‘[’ is special and ‘]’ not.
- This lasts until the first unquoted ‘[’,
  - after which we are in a character alternative;
  - ‘[’ is no longer special
    - (except when it starts a character class)
  - but ‘]’ is special,
    - unless it immediately follows the special ‘[’ or
    - that ‘[’ followed by a ‘^’.
  - This lasts until the next special ‘]’ that does not end a character class.
- This ends the character alternative and restores the ordinary syntax of regular expressions;
- an unquoted ‘[’ is special again and a ‘]’ not.

#+texinfo:@heading POSIX Features

#+cindex:POSIX regexp
The following aspects of ranges are specific to Emacs, in that POSIX allows but
does not require this behavior and programs other than Emacs may behave
differently:

#+vindex:case-fold-search
#+cindex:collation sequence
#+cindex:unibyte character
1. If ~case-fold-search~ is non-‘nil’, =[a-z]= also matches upper-case letters.

2. A range is not affected by the locale’s collation sequence: it always
   represents the set of characters with codepoints ranging between those of
   its bounds, so that =[a-z]= matches only ASCII letters, even outside the C
   or POSIX locale.

3. As a special case, if either bound of a range is a raw 8-bit byte, the other
   bound should be a unibyte character, and the range matches only unibyte
   characters.

4. If the lower bound of a range is greater than its upper bound, the range is
   empty and represents no characters.  Thus, ‘[b-a]’ always fails to match,
   and ‘[^b-a]’ matches any character, including newline.  However, the lower
   bound should be at most one greater than the upper bound; for example,
   ‘[c-a]’ should be avoided.

5. A character alternative can also specify [[*Char Classes][named character classes]].  This is
   a POSIX feature.  Using a character class is equivalent to mentioning each
   of the characters in that class; but the latter is not feasible in practice,
   since some classes include thousands of different characters.  A character
   class should not appear as the lower or upper bound of a range.

**** Syntax Classes

#+cindex:syntax classes
#+cindex:classes, regexp syntax
#+cindex:regexp, syntax classes
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html#Syntax-Class-Table][Table of Syntax Classes]]

**** Char Classes

#+cindex:char classes, regexp
#+cindex:classes, regexp char
#+cindex:regexp, char classes
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Char-Classes.html#Char-Classes][Character Classes]]

**** Backslash Constructs

#+cindex:backslash, regexp
#+cindex:regexp backslash
For the most part, =\= followed by any character matches only that character.
However, there are several exceptions: certain sequences starting with =\= that
have special meanings.  Here is a table of the special =\= constructs.

- =\|= :: an alternative
- =\{M\}= :: repeat the previous pattern exactly M times
- =\{M,N\}= :: specifies repetition
- =\(...\)= :: a grouping construct
- =\(?:...\)= :: the “shy group” (“non-capturing” or “unnumbered”) construct
- =\(?NUM:...\)= :: the “explicitly numbered group” construct
- =\DIGIT= :: matches the same text that matched DIGITth occurrence of a group
- =\w= :: matches any word-constituent character
- =\W= :: matches any character that is not a work constituent
- =\sCODE= :: matches any character whose syntax is CODE
- =\SCODE= :: matches any character whose syntax is not CODE
- =\cC= :: matches any character whose category is C. =M-x describe-categories=
- =\CC= :: matches any character whose category is not C


The following regular expression constructs match the empty string---that is,
they don’t use up any characters---but whether they match depends on the
context.

#+attr_texinfo: :indic code
- \` :: matches the empty string, but only at the beginning of the buffer or
  string being matched against.
- \' :: matches the empty string, but only at the end of the buffer or string
  being matched against.
- \= :: matches the empty string, but only at point.
- =\b= :: matches the empty string, but only at the beginning or end of a word.
- =\B= :: matches the empty string, but _not_ at the beginning or end of a
  word, nor at the beginning or end of the buffer (or string)
- \< :: matches the empty string, but only at the beginning of a word.
- \> :: matches the empty string, but only at the end of a word.
- \_< :: matches the empty string, but only at the beginning of a symbol.
- \_> :: matches the empty string, but only at the end of a symbol.

*** Regular Expression Functions
These functions operate on regular expressions.

**** regexp-quote

#+attr_texinfo: :options regexp-quote string
#+begin_defun
This function returns a regular expression whose only exact match is STRING.
This allows you to request an exact string match or search when calling a
function that wants a regular expression.
#+end_defun

**** regexp-opt

#+attr_texinfo: :options regexp-opt strings &optional paren
#+begin_defun
This function returns an efficient regular expression that will match any of
the strings in the list STRINGS.  This is useful when you need to make matching
or searching as fast as possible—for example, for Font Lock mode.

- STRINGS :: list of strings

- PAREN :: The optional argument PAREN can be any of the following:

  - a string :: The resulting regexp is preceded by PAREN and followed by ‘\)’;
    =\\(?1:=

  - words :: The resulting regexp is surrounded by ‘\<\(’ and ‘\)\>’.

  - symbols :: The resulting regexp is surrounded by ‘\_<\(’ and ‘\)\_>’

  - non-nil :: The resulting regexp is surrounded by ‘\(’ and ‘\)’.

  - nil :: The resulting regexp is surrounded by ‘\(?:’ and ‘\)’
#+end_defun

**** regexp-opt-charset

#+attr_texinfo: :options regexp-opt-depth regexp
#+begin_defun
This function returns the total number of grouping constructs (parenthesized
expressions) in REGEXP.  This does not include shy groups.
#+end_defun

**** regexp-opt-charset chars

#+attr_texinfo: :options regexp-opt-charset chars
#+begin_defun
This function returns a regular expression matching a character in the list of
characters CHARS.
#+end_defun

*** Regular Expression Searching in Programs

**** re-search-forward

#+attr_texinfo: :options re-search-forward regexp &optional limit noerror count
#+begin_defun
This function searches forward in the current buffer for a string of text that
is matched by the regular expression REGEXP.  The function skips over any
amount of text that is not matched by REGEXP, and leaves point at the end of
the first match found.  It returns the new value of point.

- REGEXP :: The regexp to match against

- LIMIT :: The upper bound to the search, unless nil

- NOERROR :: What ‘re-search-forward’ does when the search fails depends on the
  value of NOERROR:

  - nil :: Signal a ‘search-failed’ error.

  - t :: Do nothing and return ‘nil’.

  - other :: Move point to LIMIT (or the end of the accessible portion of the
    buffer) and return ‘nil’.

- COUNT :: If COUNT is positive number, N, search N times.  If all searches
  succeed, function call succeeds, moves point and return point’s new value.
  Otherwise, function call fails.

  If COUNT is a negative number -N, the search is done N times in the backward
  direction.

- RETURN VALUE :: Upon success, the value of point; nil on failure.
#+end_defun

**** string-match

#+attr_texinfo: :options string-match regexp string &optional start
#+begin_defun
This function returns the index of the start of the first match for the regular
expression REGEXP in STRING, or ‘nil’ if there is no match

- REGEXP :: regexp to match against

- STRING :: string to use for match

- START :: if non-nil, start search at that index in STRING

- RETURN VALUE :: index of the start of the first match in STRING, or nil if
  there is no match.
  #+findex:match-end
- ~(match-end 0)~ :: If this function finds a match, the index of the first
  character beyond the match is available as ‘(match-end 0)’.


You can use the function <<match-string>> [[*match-string][~match-string~]] to extract the
substrings matched by the parenthesis constructions in REGEXP.
#+end_defun

**** string-match-p

#+attr_texinfo: :options string-match-p regexp string &optional start
#+begin_defun
This predicate function does what ~string-match~ does, but it avoids modifying
the match data.
#+end_defun

**** looking-at

#+attr_texinfo: :options looking-at regexp
#+begin_defun
This function determines whether the text in the current buffer directly
following point matches the regular expression REGEXP.  The result is ‘t’ if
so, ‘nil’ otherwise.  This function does not move point, but it does update the
match data.
#+end_defun

**** looking-at-p

#+attr_texinfo: :options looking-at-p regexp
#+begin_defun
This predicate function works like ‘looking-at’, but without updating the match
     data.
#+end_defun

**** looking-back

#+attr_texinfo: :options looking-back regexp limit &optional greedy
#+begin_defun
This function returns ‘t’ if REGEXP matches the text immediately before point
(i.e., ending at point), and ‘nil’ otherwise.

- REGEXP :: the regexp to match against

- LIMIT :: You can bound the time required by specifying a non-‘nil’ value for
  LIMIT, which says not to search before LIMIT.

- GREEDY :: If GREEDY is non-‘nil’, this function extends the match backwards
  as far as possible, stopping when a single additional previous character
  cannot be part of a match for REGEXP.  When the match is extended, its
  starting position is allowed to occur before LIMIT.
#+end_defun

**** search-spaces-regexp---a variable

#+attr_texinfo: :options search-spaces-regexp
#+begin_defun
If this variable is non-‘nil’, it should be a regular expression that says how
to search for whitespace.  In that case, any group of spaces in a regular
expression being searched for stands for use of this regular expression.

Since this variable affects all regular expression search and match constructs,
you should bind it temporarily for as small as possible a part of the code.
#+end_defun

*** Replacing Text Using Match Data

#+cindex:match data
Emacs keeps track of the start and end positions of the segments of text found
during a search; this is called the “match data”.

All functions are allowed to overwrite the match data unless they’re explicitly
documented not to do so.  A consequence is that functions that are run
implicitly in the background should likely save and restore the match data
explicitly.

**** replace-match

This function replaces all or part of the text matched by the last search.  It
works by means of the match data.

#+attr_texinfo: :options replace-match replacement &optional fixedcase literal string subexp
#+begin_defun
This function performs a replacement operation on a buffer or string.

- REPLACEMENT :: The String to replace the matched text

- FIXEDCASE :: If FIXEDCASE is non-‘nil’, then ~replace-match~ uses the
  replacement text without case conversion; otherwise, it converts the
  replacement text depending upon the capitalization of the text to be
  replaced.

- LITERAL :: If LITERAL is non-‘nil’, then REPLACEMENT is inserted exactly as
  it is, the only alterations being case changes as needed.  If it is ‘nil’
  (the default), then the character ‘\’ is treated specially.

  If a ‘\’ appears in REPLACEMENT, then it must be part of one of the following
  sequences:

  - =\&= :: This stands for the entire text being replaced.

  - =\N= :: where N is a digit; this stands for the text that matched the Nth
    subexpression in the original regexp.

  - =\\= :: This stands for a single ‘\’ in the replacement text.

  - =\?= :: This stands for itself (for compatibility with ‘replace-regexp’ and
    related commands;

  - any other :: error

- STRING :: If you performed the last search on a string, pass the same string
  as STRING.  Then this function returns a new string, in which the matched
  text is replaced by REPLACEMENT.

- SUBEXP :: If SUBEXP is non-‘nil’, that says to replace just subexpression
  number SUBEXP of the regexp that was matched, not the entire match.
#+end_defun

#+texinfo:@heading Replace All Matches in Part of a Buffer

If you want to find all matches for a regexp in part of the buffer, and replace
them, the best way is to write an explicit loop using [[*re-search-forward][~re-search-forward~]] and
~replace-match~, like this:

#+begin_src elisp :eval no
  (while (re-search-forward "foo[ \t]+bar" nil t)
    (replace-match "foobar"))
#+end_src

Replacing matches in a string is more complex, especially if you want to do it
efficiently.  So Emacs provides a function to do this: [[*replace-regexp-in-string][~replace-regexp-in-string~]].

**** match-substitue-replacement

#+attr_texinfo: :options match-substitute-replacement replacement &optional fixedcase literal string subexp
#+begin_defun
This function returns the text that would be inserted into the buffer by
‘replace-match’, but without modifying the buffer.

It is useful if you want to present the user with actual replacement result,
with constructs like ‘\N’ or ‘\&’ substituted with matched groups.

Arguments REPLACEMENT and optional FIXEDCASE, LITERAL, STRING and SUBEXP have
the same meaning as for ‘replace-match’.

#+end_defun
**** replace-regexp-in-string

#+attr_texinfo: :options replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
#+begin_defun

This function uses [[*replace-match][~replace-match~]] to do the replacement.

- REGEXP :: the regexp to use

- REP :: replacement string or function.

  If a function, ~replace-regexp-in-string~ calls REP for each match, passing
  the text of the match as its sole argument.  It collects the value REP
  returns and passes that to ~replace-match~ as the replacement string.

- STRING :: string to search; this function copies STRING and searches it for
  matches for REGEXP, and replaces them with REP.

- FIXEDCASE :: passed to ~replace-match~

- LITERAL :: passed to ~replace-match~

- SUBEXP :: passed to ~replace-match~

- START :: If START is non-‘nil’, the search for matches starts at that index
  in STRING, so matches starting before that index are not changed.

- RETURN VALUE :: It returns the modified copy.
#+end_defun

**** perform-replace

If you want to write a command along the lines of ~query-replace~, you can use
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Search-and-Replace.html#Search-and-Replace][~perform-replace~]] to do the work.

#+attr_texinfo: :options perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end backward region-noncontiguous-p
#+begin_defun
This function is the guts of ‘query-replace’ and related commands.

It searches for occurrences of FROM-STRING in the text between positions START
and END and replaces some or all of them.  If START is ‘nil’ (or omitted),
point is used instead, and the end of the buffer’s accessible portion is used
for END.  (If the optional argument BACKWARD is non-‘nil’, the search starts at
END and goes backward.)
#+end_defun

*** Accessing Matched Text Using Match Data
This section explains how to use the match data to find out what was matched by
the last search or match operation, if it succeeded.

Every successful search sets the match data.  You should query the match data
immediately after searching, before calling any other function that might
perform another search, or save and restore the match data around the call to
functions that could perform another search, or use the functions that
explicitly do not modify the match data.

You can ask about the entire matching text, or about a particular parenthetical
subexpression of a regular expression, using the COUNT argument.

- If count is zero, you are asking about the entire match.
- If count is positive, it specifies which subexpression you want.

**** match-string

#+attr_texinfo: :options match-string count &optional in-string
#+begin_defun

- COUNT :: if zero, return the entire matched text; if positive integer,
  return the COUNTth matched parenthetical subexpression.

- IN-STRING :: If the last such operation was done against a string with
  [[match-string][~string-match~]], then you should pass the same string as the argument
  IN-STRING.

  After a buffer search or match, you should omit IN-STRING or pass ‘nil’ for
  it; but you should make sure that the current buffer when you call
  ~match-string~ is the one in which you did the searching or matching.

- RETURN VALUE :: The matched text or a portion of the matched text as a string
  depending on the value of COUNT.

  The value is ‘nil’ if COUNT is out of range, or for a subexpression inside a
  ‘\|’ alternative that wasn’t used or a repetition that repeated zero times.

#+end_defun

**** match-string-no-properties

#+attr_texinfo: :options match-string-no-properties count &optional in-string
#+begin_defun
This function is like ~match-string~ except that the result has no text
properties.
#+end_defun

**** match-beginning

#+attr_texinfo: :options match-beginning count
#+begin_defun
If the last regular expression search found a match, this function returns the
position of the start of the matching text or of a subexpression of it.

- COUNT :: If COUNT is zero, then the value is the position of the start of the
  entire match.  Otherwise, COUNT specifies a subexpression in the regular
  expression, and the value of the function is the starting position of the
  match for that subexpression.

  The value is ‘nil’ for a subexpression inside a ‘\|’ alternative that wasn’t
  used or a repetition that repeated zero times.
#+end_defun

**** match-end

#+attr_texinfo: :options match-end count
#+begin_defun
This function is like ~match-beginning~ except that it returns the position of
the end of the match, rather than the position of the beginning.
#+end_defun

**** match-data

#+attr_texinfo: :options match-data &optional integers reuse reseat
#+begin_defun
This function returns a list of positions (markers or integers) that record all
the information on the text that the last search matched.

- RETURN VALUE ::

  - Element zero is the position of the beginning of the match for the whole
    expression;

  - element one is the position of the end of the match for the expression.

  - The next two elements are the positions of the beginning and end of the match
    for the first subexpression, and so on.

  - In general, element number 2N corresponds to ‘(match-beginning N)’; and
  element number 2N + 1 corresponds to ‘(match-end N)’.

- INTEGERS :: Applies only to buffer searches; normally all the elements are
  markers or ‘nil’, but if INTEGERS is non-‘nil’, that means to use integers
  instead of markers.  (In that case, the buffer itself is appended as an
  additional element at the end of the list, to facilitate complete restoration
  of the match data.)

- REUSE :: If REUSE is non-‘nil’, it should be a list.  In that case,
  ‘match-data’ stores the match data in REUSE.  REUSE is destructively
  modified.  The purpose of this feature is to reduce the need for garbage
  collection.

- RESEAT :: If RESEAT is non-‘nil’, all markers on the REUSE list are reseated
  to point to nowhere.
#+end_defun

**** set-match-data

#+attr_texinfo: :options set-match-data match-list &optional reseat
#+begin_defun
This function sets the match data from the elements of MATCH-LIST, which should
be a list that was the value of a previous call to ‘match-data’.

If RESEAT is non-‘nil’, all markers on the MATCH-LIST list are reseated to
point to nowhere.
#+end_defun

**** save-match-data

#+attr_texinfo: :options save-match-data body
#+begin_defun
This macro executes BODY, saving and restoring the match data around it.  The
return value is the value of the last form in BODY.
#+end_defun

*** Using RE Builder Command

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Regular-Expressions.html#Regular-Expressions


For interactive development of regular expressions, you can use the =M-x
re-builder= command.  It provides a convenient interface for creating regular
expressions, by giving immediate visual feedback in a separate buffer.  As you
edit the regexp, all its matches in the target buffer are highlighted.  Each
parenthesized sub-expression of the regexp is shown in a distinct face, which
makes it easier to verify even very complex regexps.

#+attr_texinfo: :options re-builder
#+begin_defun
Construct a regexp interactively.

This command makes the current buffer the "target" buffer of
the regexp builder.  It displays a buffer named "*RE-Builder*"
in another window, initially containing an empty regexp.

As you edit the regexp in the "*RE-Builder*" buffer, the
matching parts of the target buffer will be highlighted.
#+end_defun

** Changing Case

** Counting

** Text Manipulation

** Keyboard Macros

** Text Expansion

** Indenting

#+cindex:indentation
“Indentation” refers to inserting or adjusting “whitespace characters” (space
and/or tab characters) at the beginning of a line of text.

#+heading:Enter a =<TAB>= Character
#+cindex:TAB character, enter
If you just want to insert a tab character in the buffer, type =C-q <TAB>=.
This always inserts a tab character, regardless of the value of
‘indent-tabs-mode’.

#+findex:indent-for-tab-command
#+cindex:TAB key
The simplest way to perform indentation is the =<TAB>= key.  In most major
modes, this runs the command ~indent-for-tab-command~.  The exact behavior of
=<TAB>= depends on the major mode.

In Text mode and related major modes, <TAB> normally inserts some combination
of space and tab characters to advance point to the next tab stop.  For this
purpose, the position of the first non-whitespace character on the preceding
line is treated as an additional tab stop, so you can use <TAB> to align point
with the preceding line.

If the region is active (*note Using Region::), =<TAB>= acts specially: it
indents each line in the region so that its first non-whitespace character is
aligned with the preceding line.

*** Electric Indent Mode
#+cindex:electric indent mode
In Emacs 24.4 a new minor mode called /electric indent mode/ now handles
intelligent indentation when you press RET.

**** Indenting New Lines
#+findex:electric-indent-mode
When you press =RET= Emacs will insert a newline character and then invoke the
major mode’s indentation engine.  For this to work, you have to enable the
minor mode ~electric-indent-mode~.

#+findex:newline-and-indent
- newline-and-indent ::

  Insert a NEWLINE, then indent according to major mode.  Indentation is done
  using the value of ‘indent-line-function’.  In programming language modes,
  this is the same as =TAB=.  In some text modes, where =TAB= inserts a tab,
  this command indents to the column specified by the function
  ‘current-left-margin’.


With electric indent, Emacs now also checks if you type certain block
characters --- like Python’s =:= or ={= and =}= in C --- and automatically
re-indents the current line.

**** Indenting the Current Line
#+findex:indent-for-tab-command
#+vindex:indent-line-function
#+findex:indent-region
When you press =TAB=, Emacs usually calls ~indent-for-tab-command~, a generic
proxy command that either indents your code or attempts to =TAB=-complete the
word at the point.

- indent-for-tab-command &optional ARG ::

  Indent the current line or region, or insert a tab, as appropriate.  This
  function either inserts a tab, or indents the current line, or performs
  symbol completion, depending on ‘tab-always-indent’.  The function called to
  actually indent the line or insert a tab is given by the variable
  ‘indent-line-function’.

  If a prefix argument is given, after this function indents the current line
  or inserts a tab, it also rigidly indents the entire balanced expression
  which starts at the beginning of the current line, to reflect the current
  line’s indentation.

  If ‘transient-mark-mode’ is turned on and the region is active, this function
  instead calls ‘indent-region’.  In this case, any prefix argument is ignored.


Some major modes override the =TAB= key and instead call their own specialized
indent command --- one example is the C major mode.

However, pressing =TAB= (or ~M-x indent-for-tab-command~) will, if its 
heuristic determines that it should indent, call the indentation function
stored in the variable ~indent-line-function~.

#+vindex:tab-always-indent
The variable ~tab-always-indent~ governs Emacs’s behavior when you press =TAB=.
Usually, it just indents but it also has a completion mechanism, though
seldomly used.

If ~tab-always-indent~ is ‘t’, hitting =TAB= always just indents the current
line.  If nil, hitting TAB indents the current line if point is at the left
margin or in the line’s indentation, otherwise it inserts a "real" TAB
character.  If ‘complete’, TAB first tries to indent the current line, and if
the line was already indented, then try to complete the thing at point.

#+vindex:intent-tabs-mode
If you dislike the use of tab characters and if you prefer whitespace,
customize the variable ~indent-tabs-mode~.  Indentation can insert tabs if this
is non-nil.

#+vindex:tab-width
The variable ~tab-width~ controls how many characters of spacing each tab uses.
It also controls the amount of whitespace to use if you disabled
~indent-tabs-mode~.

Finally, when Emacs indents it calls the aforementioned function in
~indent-line-function~.  The default function is ~indent-relative~, a command
that inserts an actual tab character.  Modes such as =text-mode= and
=fundamental-mode= (the default mode for a new, empty buffer) uses
~indent-relative~.  Most programming modes do not.

#+texinfo:@heading Tab Stops
#+findex:edit-tab-stops
#+findex:tabs-to-tab-stop
There is also the concept of tab stops in Emacs and you can edit the tab stops
by typing ~M-x edit-tab-stops~ and inserting =:= characters where you want
Emacs to set the tab point.  Subsequent calls to =M-i= (which calls the command
~M-x tabs-to-tab-stop~) then insert tab stops, by way of whitespace and tab
characters.

*** Indenting Regions
Regions are even more difficult to indent. How do you safely indent a region
Python code when block indentation determines program flow?  The answer is ---
you don’t.

There are two types of region indentation commands:

- “intelligent” ones that ask your major mode’s indentation engine for advice –
  something that works well with languages like HTML or C;

- and plain, fixed-width indentation for the rest.


- =TAB= :: Indents a line or region as per the major mode

- =C-M-\= :: Indents using major mode’s region indent command

- =C-x TAB= :: Rigidly indents

*** Program Indent
In programming modes, =<TAB indents the current line of code in a way that
makes sense given the code in the preceding lines.  If the region is active,
all the lines in the region are indented this way.  If point was initially
within the current line’s indentation, it is repositioned to the first
non-whitespace character on the line.

*** Tabs versus Spaces
#+vindex:indent-tabs-mode
If you prefer, all indentation can be made from spaces only.  By using spaces
only, you can make sure that your file always looks the same.

- indent-tabs-mode :: set this buffer-local variable to nil


#+vindex:tab-width
If you only care about how it looks within Emacs, another way to tackle this
problem is to set the ~tab-width~ variable in a file-local variable.

**** Convert Tabs to Spaces and Vice Versa
There are also commands to convert tabs to spaces or vice versa, always
preserving the columns of all non-whitespace text.

- tabify :: scans the region for sequences of spaces, and converts sequences of
  at least two spaces to tabs if that can be done without changing indentation.

- untabify :: changes all tabs in the region to appropriate numbers of spaces.

**** Tab Always Indent
#+vindex:tab-always-indent
The variable ~tab-always-indent~ tweaks the behavior of the =<TAB>=
(‘indent-for-tab-command’) command.  The default value, ‘t’, gives the behavior
described in *note Indentation::.  If you change the value to the symbol
=complete=, then =<TAB>= first tries to indent the current line, and if the
line was already indented, it tries to complete the text at point.  If the
value is ‘nil’, then =<TAB>= indents the current line only if point is at the
left margin or in the line’s indentation; otherwise, it inserts a tab
character.

** Sorting and Aligning

** Zapping

** Spell Checking

** Quoted Insert

** Comparing-Diffing-Merging

#+cindex:diff mode
{{{heading(Diff Mode)}}}

#+findex:diff
=M-x diff= [[diff-command][command]] produces Diff mode, which displays the differences between
two files in a =*diff*= buffer through running the ~diff~ program.  Switches
are found in the ~diff-switches~ variable (the default is =-u=, a unified
context diff).

{{{heading(Ediff Package)}}}

Ediff is a more sophisticated alternative to Diff mode.  See info:ediff.

{{{heading(Comparing a File to a Backup)}}}

=M-x diff-backup= compares  a file with its most recent  backup. If you specify
the  name of  a backup  file, this  command compares  it with  the source  file
instead. Otherwise, it is the same as =M-x diff=.

{{{heading(Compare a Buffer with its File)}}}

=M-x diff-buffer-with-file= compares a specified buffer with its corresponding
file.  This shows you what changes you would make to the file if you save the
buffer.

{{{heading(Compare Windows)}}}

=M-x compare-windows= compares the text in the current window with that in the
window that was the selected window before you selected the current one.

{{{heading(Smerge Mode)}}}

=M-x smerge-mode= turns on Smerge mode, a minor mode for editing output from
the ‘diff3’ program.

{{{heading(Emerge)}}}

The Emerge commands compare two files or buffers, and display the comparison in
three buffers: one for each input text (the “A buffer” and the “B buffer”), and
one (the “merge buffer”) where merging takes place.  The merge buffer shows the
full merged text, not just the differences.  Wherever the two input texts
differ, you can choose which one of them to include in the merge buffer.

- =M-x emerge-files= :: to merge two specific files.

- =M-x emerge-files-with-ancestor= :: to merge two files with reference to a
     common ancestor.

- =M-x emerge-buffers= :: to merge two buffers

- =M-x emerge-buffers-with-ancestor= :: to merge two buffers with reference to
     a common ancestor in a third buffer.

*** Diff Mode

#+cindex:diff mode
Used for the output of =M-x diff=.  Select Diff mode manually with =M-x
diff-mode=.

<<diff-command>>
#+attr_texinfo: :options diff OLD NEW &optional SWITCHES NO-ASYNC (interactive)
#+begin_defun
  Find  and   display  the  differences   between  OLD  and  NEW   files.  Read
  @@texinfo:@var{@@new@@texinfo:}@@ and @@texinfo:@var{@@old@@texinfo:}@@ using
  the minibuffer when called interactively  (defaults are current buffer’s file
  name  and its  backup file,  respectively).  If called  interactively with  a
  prefix argument, prompt  for ~diff~ switches. Otherwise the  swiches found in
  the variable @@texinfo:@var{@@diff-switches@@texinfo:}@@ are passed.
#+end_defun

{{{heading(Hunks)}}}

#+cindex:hunks
#+cindex:hunk header
The changes specified in a patch are grouped into “hunks”, which are contiguous
chunks of text that contain one or more changed lines.  Each hunk is preceded
by a “hunk header”, which specifies the old and new line numbers where the
hunk’s changes occur.  Diff mode highlights each hunk header

{{{subheading(File Header)}}}

#+cindex:file header
The first hunk in a patch is preceded by a file header, which shows the names
of the new and the old versions of the file, and their time stamps.

{{{subheading(Editing Hunks)}}}

- =M-n= ‘(diff-hunk-next)’ :: Move to the next hunk-start (‘diff-hunk-next’).
     With prefix argument N, move forward to the Nth next hunk.

- =M-p= ‘(diff-hunk-prev)’ :: Move to the previous hunk-start
     (‘diff-hunk-prev’).  With prefix argument N, move back to the Nth previous
     hunk.

- =M-}= ‘(diff-file-next)’ :: Move to the next file-start, in a multi-file
     patch (‘diff-file-next’).  With prefix argument N, move forward to the
     start of the Nth next file.

- =M-{= ‘(diff-file-pref)’ :: Move to the previous file-start, in a multi-file
     patch (‘diff-file-prev’).  With prefix argument N, move back to the start
     of the Nth previous file.

- =M-k= ‘(diff-hunk-kill)’ :: Kill the hunk at point (‘diff-hunk-kill’).

- =M-K= ‘(diff-file-kill)’ :: In a multi-file patch, kill the current file
     part.  (‘diff-file-kill’).

- =C-c C-a= ‘(diff-apply-hunk)’ :: Apply this hunk to its target file
     (‘diff-apply-hunk’).  With a prefix argument of ‘C-u’, revert this hunk,
     i.e. apply the reverse of the hunk, which changes the “new” version into
     the “old” version.

- =C-c C-b= ‘(diff-refine-hunk)’ :: Highlight the changes of the hunk at point
     with a finer granularity (‘diff-refine-hunk’).  This allows you to see
     exactly which parts of each changed line were actually changed.

- =C-c C-c= ‘(diff-goto-source)’ :: Go to the source file and line
     corresponding to this hunk (‘diff-goto-source’).  By default, this jumps
     to the “new” version of the file, the one shown first on the file header.
     With a prefix argument, jump to the “old” version instead.

- =C-c C-e= ‘(diff-ediff-patch)’ :: Start an Ediff session with the patch
     (‘diff-ediff-patch’).  See info:ediff

- =C-c C-n= ‘(diff-restrict-view)’ :: Restrict the view to the current hunk
     (‘diff-restrict-view’).  *Note info:emacs#Narrowing.  With a prefix argument,
     restrict the view to the current file of a multiple-file patch.  To widen
     again, use ‘C-x n w’ (‘widen’).

- =C-c C-d= ‘(diff-unified->context)’ :: Convert the entire buffer to the
     “context diff format” (‘diff-unified->context’).  With a prefix argument,
     convert only the hunks within the region.

- =C-c C-u= ‘(diff-context->unified)’ :: Convert the entire buffer to unified
     diff format (‘diff-context->unified’).  With a prefix argument, convert
     unified format to context format.  When the mark is active, convert only
     the hunks within the region.

- =C-c C-w= ‘(diff-ignore-whitespace-hunk)’ :: Re-generate the current hunk,
     disregarding changes in whitespace (‘diff-ignore-whitespace-hunk’).

- =C-x 4 A= ‘(diff-add-change-log-entries-other-window)’ :: Generate a
     ChangeLog entry, like ‘C-x 4 a’ does (*note [[info:emacs#Change%20Log]]), for
     each one of the hunks.

*** eDiff Mode
See [[info:ediff][Ediff]]

Ediff is a comprehensive visual interface to Unix diff and patch utilities.

*** sMerge
~smerge-mode~ is a minor mode to simplify editing output from the ~diff3~
program.  This is typically the result of a failed merge from a version control
system update outside VC, due to conflicting changes to a file.  Smerge mode
provides commands to resolve conflicts by selecting specific changes.

*** eMerge
See info:emacs#Emerge

{{{noindent}}}See [[info:emacs#Merge%20Commands]]

It’s not unusual for programmers to get their signals crossed and modify the
same program in two different directions.  To recover from this confusion, you
need to merge the two versions.

- =M-x emerge-files= :: Merge two specified files.

- =M-x emerge-files-with-ancestor= :: Merge two specified files, with reference
     to a common ancestor.

- =M-x emerge-buffers= :: Merge two buffers.

- =M-x emeerge-buffers-with-ancestor= :: Merge two buffers with reference to a
     common ancestor in a third buffer.


The Emerge commands compare two files or buffers, and display the comparison in
three buffers: one for each input text (the “A buffer” and the “B buffer”), and
one (the “merge buffer”) where merging takes place.  The merge buffer shows the
full merged text, not just the differences.  Wherever the two input texts
differ, you can choose which one of them to include in the merge buffer.

If a common ancestor version is available, from which the two texts to be
merged were both derived, Emerge can use it to guess which alternative is
right.  Wherever one current version agrees with the ancestor, Emerge presumes
that the other current version is a deliberate change which should be kept in
the merged version.  Use the ‘with-ancestor’ commands if you want to specify a
common ancestor text.  These commands read three file or buffer names—variant
A, variant B, and the common ancestor.

**** Interactive Merging
#+cindex:emerge mode
You control the merging by typing special “merge commands” in the merge buffer.
For each run of differences between the input texts, you can choose which one
of them to keep, or edit them both together.  The merge buffer uses a special
major mode, Emerge mode, with commands for making these choices.  But you can
also edit the buffer with ordinary Emacs commands.

Normally, the merge buffer starts out with the A version of the text.  But when
the A version of a difference agrees with the common ancestor, then the B
version is initially preferred for that difference.

{{{heading(Selected Difference)}}}

At any given time, the attention of Emerge is focused on one particular
difference, called the “selected” difference.  This difference is marked off in
the three buffers like this:

#+BEGIN_EXAMPLE

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

#+END_EXAMPLE

Emerge numbers all the differences sequentially and the mode line always shows
the number of the selected difference.

{{{heading(Exiting Emerge)}}}

Emerge leaves the merged text in the merge buffer when you exit.

- =C-x C-w= :: save the merge buffer in a file.  If you give a
numeric argument to ‘emerge-files’ or ‘emerge-files-with-ancestor’, it reads
the name of the output file using the minibuffer.  Then exiting from Emerge
saves the merged text in the output file.

- =C-]= :: abort Emerge without saving.

**** Submodes in Emerge

There are two modes for giving merge commands: Fast Mode and Edit Mode.  The
mode line indicates Edit and Fast modes with ‘E’ and ‘F’.

There are two additional submodes that affect how particular merge commands
work: Auto Advance Mode, and Skip Prefers Mode.

{{{heading(Fast Mode)}}}

- =C-c C-c f= :: switch to Fast mode (from Edit mode)

In Fast mode, basic merge commands are single characters, but ordinary Emacs
commands are disabled.

{{{heading(Edit Mode)}}}

- =e= :: swith to Edit mode (from Fast mode)

In Edit mode, all merge commands start with the prefix key ‘C-c C-c’, and the
normal Emacs commands are also available.  This allows editing the merge
buffer, but slows down Emerge operations.

{{{heading(Auto Advance Mode)}}}

If Auto Advance mode is in effect, the ‘a’ and ‘b’ commands advance to the next
difference.  This lets you go through the merge faster as long as you simply
choose one of the alternatives from the input.  The mode line indicates Auto
Advance mode with ‘A’.

{{{heading(Skip Prefers Mode)}}}

If Skip Prefers mode is in effect, the ‘n’ and ‘p’ commands skip over
differences in states “prefer-A” and “prefer-B” (*note State of Difference::).
Thus you see only differences for which neither version is presumed correct.
The mode line indicates Skip Prefers mode with ‘S’.  This mode is only relevant
when there is an ancestor.

Use the command ‘s a’ (‘emerge-auto-advance’) to set or clear Auto Advance
mode.  Use ‘s s’ (‘emerge-skip-prefers’) to set or clear Skip Prefers mode.
These commands turn on the mode with a positive argument, turn it off with a
negative or zero argument, and toggle the mode with no argument.

**** State of a Difference
In the merge buffer, a difference is marked with lines of ‘v’ and ‘^’
characters.  Each difference has one of these seven states:

- =A= :: The difference is showing the A version.  The ‘a’ command always
         produces this state; the mode line indicates it with ‘A’.

- =B= :: The difference is showing the B version.  The ‘b’ command always
         produces this state; the mode line indicates it with ‘B’.

- =default-A= or =default-B= :: The difference is showing the A or the B state
     by default, because you haven’t made a choice.  All differences start in
     the default-A state (and thus the merge buffer is a copy of the A buffer),
     except those for which one alternative is preferred (see below).

     When you select a difference, its state changes from default-A or
     default-B to plain A or B.  Thus, the selected difference never has state
     default-A or default-B, and these states are never displayed in the mode
     line.

     The command ‘d a’ chooses default-A as the default state, and ‘d b’
     chooses default-B.  This chosen default applies to all differences that
     you have never selected and for which no alternative is preferred.  If you
     are moving through the merge sequentially, the differences you haven’t
     selected are those following the selected one.  Thus, while moving
     sequentially, you can effectively make the A version the default for some
     sections of the merge buffer and the B version the default for others by
     using ‘d a’ and ‘d b’ between sections.

- =prefer-A= or =prefer-B= :: The difference is showing the A or B state
     because it is “preferred”.  This means that you haven’t made an explicit
     choice, but one alternative seems likely to be right because the other
     alternative agrees with the common ancestor.  Thus, where the A buffer
     agrees with the common ancestor, the B version is preferred, because
     chances are it is the one that was actually changed.

     These two states are displayed in the mode line as ‘A*’ and ‘B*’.

- =combined= :: The difference is showing a combination of the A and B states,
                as a result of the ‘x c’ or ‘x C’ commands. The mode line
                displays this state as ‘comb’.

                Once a difference is in this state, the ‘a’ and ‘b’ commands
                don’t do anything to it unless you give them a numeric
                argument.

** Entering Special Symbols
   #+cindex:Section § symbol
   #+cindex:symbol §
- Section § symbol :: =C-x 8 S=
* Practicals
** Exploring Emacs

** Log Files

** TRAMP

** Dired
#+cindex:dired
You  can  manipulate directories  and  files  using Emacs’s  directory  editor,
=Dired=. =Dired= makes an Emacs buffer containing a listing of a directory, and
optionally  some  of its  subdirectories.  The  buffer is  normally  read-only.
=Dired= also works with remote directories.

Ways to access =Dired=:

- From IDO Mode :: =C-x C-f C-d= when finding files to open a dired buffer in
                   that file's current directory.

- As a command :: =M-x dired= [directory|pattern]

- As a key bind :: =C-x d=; =C-x 4 d=; =C-x 5 d= [directory|pattern]

: Ex: M-x dired <RET> ~/foo/ | ~/foo/*.el | ~/foo/*/*.el <RET>

- ~dired-jump~  :: =C-x C-j=; =C-x 4 C-j= open a Dired buffer and move point to
  the line corresponding to the current file.

- =C-u= ~dired~ :: specify the ~ls~ switches in the minibuffer

#+cindex:@command{dired-listing-switches}
Dired Buffer is usually based upon ~ls -al~.  This can be configured using
~dired-listing-switches~.

#+TEXINFO: @heading See also the following extensions:

- =Wdired= :: allows one to edit the Dired buffer directly to make changes
- =Dired-X= :: =Dired Extra= --- the extra features of Dired mode

*** Dired Navigation

- ~dired-next-line~ :: =C-n=; =n=; =<SPC>=
- ~direct-previous-line~ :: =C-p=; =p=
- ~dired-unmark-backward~ :: =<DEL>=
- ~dired-goto-file~ :: =j=
- ~dired-isearch-filenames~ :: =M-s f C-s=
- ~dired-isearch-filenames-regexp~ :: =M-s f M-C-s=
- ~dired-isearch-filenames~ :: variable; default value is nil; non-nil values
  are t and =dwim=

*** Dired Marking and Unmarking

*** Dired Operations

*** Working Across Directories

**** Include Additional Directories

#+cindex:directories, include subdirectories
#+cindex:subdirectories, include
#+cindex:include subdirectories
- ~dired-maybe-insert-subdir~ ::

  - =i= :: insert this subdirectory into the same dired buffer (like ~ls -lR~)

  #+cindex:switches, @command{ls}
  #+cindex:@command{ls} switches
  - =C-u i= :: edit the ~ls~ switches; add =R= to the switches to expand
                    the whole tree starting at this subdirectory

  - [[info:emacs#Subdir%20switches][Subdir Switches]] :: for more details

- ~dired-hide-subdir~ :: =$= --- hide or unhide the current subdirectory and
     move to next directory

     - =M-$= :: (un)hide all directories

- ~dired-reset-subdir-switches~ :: reset all subdirectory switches to the
     default


**** Find Wrapper Commands
#+cindex:@command{find} wrapper commands
To recursively apply a dired or shell command, use Emac's ~find~ wrapper
commands.

All commands take the output of find and build a dired buffer relative to a
starting directory. Emacs is clever enough to notice the relative paths in what
was the filename portion of the buffer. All commands in dired work as usual.

| Commands               | Description                                                |
|------------------------+------------------------------------------------------------|
| ~find-dired~           | Calls ~find~ with a pattern                                |
| ~find-name-dired~      | Calls ~find~ with =-name= using glob patterns              |
| ~find-grep-dired~      | Calls ~find~ and ~grep~                                    |
| ~find-lisp-find-dired~ | Uses Emacs and regexp to find files (elisp implementation) |
|                        | does not use shell globbing                                |
|------------------------+------------------------------------------------------------|

** Shell Commands
The following shell commands work on generic buffers.

#+caption:Shell command key bindings
#+name:shell-command-bindings
|------------+---------------------------------------|
| Keys       | Description                           |
|------------+---------------------------------------|
| M-!        | Calls shell command and prints output |
| C-u M-!    | As above, but inserts into buffer     |
| M-&        | Like M-! but asynchronous             |
| C-u M-&    | Like C-u M-! but asynchronous         |
| M-pipe     | Pipes region to shell command         |
| C-u M-pipe | Likes M-pipe, but replaces region     |
|------------+---------------------------------------|

- [ =C-u= ] =M-!= and =M-&= :: Invoke any shell command; output is
     printed to the mini-buffer if it is only a small amount, or to a
     dedicated buffer otherwise.  Add a prefix argument to insert the
     output into the buffer.

- [ =C-u= ] =M-|= :: Takes the region as input and sends it to the
     standard input of a shell command, and returns the output to
     either the mini-buffer or a dedicated buffer.  Add a prefix
     argument to replace the region with the shell output.

*** Compiling in Emacs
=M-x compile= asynchronously runs a compilation command (by default
~make -k~).  You can run any command or script, however, and track the
output.  Error messages go to the "*compilation*" buffer.

#+caption:Compilation command key bindings
#+name:compilation-command-bindings
|-----------------------------+------------------------------------------------------|
| Commands                    | Description                                          |
|-----------------------------+------------------------------------------------------|
| =M-x compile=               | Runs a command, and tracks errors                    |
| =M-x recompile=             | Re-runs last command                                 |
| =M-g M-n=, =M-g M-p=        | Jumps to next or previous error                      |
| =C-x `=                     | Visit errors sequentially                            |
| =g= (Compilation mode)      | Re-runs last command                                 |
| =M-x kill-compilation=      | Kill the running compilation subprocess              |
| =compile-command=           | Variable holding prior command                       |
| =compilation-scroll-output= | Variable controlling scrolling of compilation buffer |
| =compilation-environment=   | Variable to control the environment passed           |
|-----------------------------+------------------------------------------------------|

*** Compilation Mode
The "*compilation*" buffer uses a major mode called Compilation mode.
This mode turns each error message in the buffer into a hyperlink; you
can move point to it and type <RET> to visit "locus" of the error
message in a separate window.

- =compilation-auto-jump-to-first-error= :: Variable allowing Emacs to
     automatically jump to the first error message that appears in the
     compilation buffer (when set to non-=nil=).

** Shells

*** Shell Mode

*** Terminal Emulator

*** eshell---Emac's Shell

* Modes
Modes are divided into two categories:

- Major Modes ::

  Provide specialized  facilities for working  on a  particular file type  or a
  particular type of non-file buffer.  They are mutually exclusive.

- Minor Modes ::

  Optional features which you can turn on or off, not necessarily specific to a
  type of  file or  buffer. They  are independent  of one  another, and  of the
  selected major mode.

** Major Modes

#+cindex:major modes
#+cindex:modes, major
Every buffer possesses  a major mode, which determines the  editing behavior of
Emacs while that  buffer is current. The  mode line normally shows  the name of
the current major mode, in parentheses

#+cindex:fundamental mode
- Fundamental Mode ::

  Least specialized major mode. This mode has no mode-specific redefinitions or
  variable settings,  so that each  Emacs command  behaves in its  most general
  manner, and each user option variable is in its default state.

For editing text of  a specific type that Emacs knows about,  such as Lisp code
or English text, you typically use a  more specialized major mode, such as Lisp
mode or Text mode. Most major modes fall into three major groups.

#+cindex:modes for normal text
1. modes for normal text
   - Text mode,
   - HTML mode,
   - SGML mode,
   - TeX mode and
   - Outline mode

#+cindex:modes for programming
2. modes for specific programming languages
   - =Lisp= mode (which has several variants),
   - =C= mode,
   - =Fortran= mode,
   - and others

#+cindex:modes for special buffers
3. are not associated directly with files; they are used in buffers created for
   specific purposes by Emacs
   - =Dired= mode for buffers made by Dired (see Dired),
   - =Message= mode for buffers made by =C-x m= (see Sending Mail), and
   - =Shell=  mode for  buffers  used  to communicate  with  an inferior  shell
     process

#+texinfo: @subheading Selecting a Major Mode

Usually, the major mode  is automatically set by Emacs, when  you first visit a
file or create a  buffer (see Choosing Modes). You can  explicitly select a new
major mode by using  an M-x command. Take the name of the  mode and add =-mode=
to get  the name  of the  command to  select that  mode (e.g.,  =M-x lisp-mode=
enters =Lisp= mode). Since every buffer has exactly one major mode, there is no
way to “turn off” a major mode; instead you must switch to a different one.

*** Mode Variables and Commands

- ~major-mode~

#+attr_texinfo: :options major-mode
#+begin_defvar
  Symbol for current  buffer’s major mode. This variable  is set automatically;
  you should not change it yourself.

  The  default or  global value  is  =fundamental-mode=. The  default value  of
  major-mode determines the major  mode to use for files that  do not specify a
  major mode,  and for new  buffers created with =C-x  b=. You can  change this
  default value via the =Customization=  interface (see Easy Customization), or
  by adding a line like this to your ~init~ file (see Init File):

  : (setq-default major-mode 'text-mode)

  If the default value  of ~major-mode~ is =nil=, the major  mode is taken from
  the previously current buffer.
#+end_defvar

To view the documentation  for the current major mode, including  a list of its
key bindings, type =C-h m= (~describe-mode~).

- ~describe-mode~

#+attr_texinfo: :options describe-mode &optional buffer
#+begin_defun
  Display documentation of current major mode  and minor modes. A brief summary
  of the minor modes comes first,  followed by the major mode description. This
  is followed by  detailed descriptions of the minor modes,  each on a separate
  page.
#+end_defun

*** Mode Hooks
#+cindex:mode hook
#+cindex:hook, mode
Every  major mode,  apart from  =Fundamental= mode,  defines a  *mode hook*,  a
customizable list of Lisp  functions to run each time the mode  is enabled in a
buffer.

Each  mode  hook  is  named  after  its major  mode,  e.g.,  Fortran  mode  has
~fortran-mode-hook~.    Furthermore,   all    text-based   major    modes   run
~text-mode-hook~,  and many  programming  language modes  (including all  those
distributed with Emacs)  run ~prog-mode-hook~, prior to running  their own mode
hooks. Hook functions can look at the value of the variable ~major-mode~ to see
which mode is actually being entered.

Mode hooks are  commonly used to enable  minor modes. For example,  you can put
the following lines in your ~init~ file  to enable =Flyspell= minor mode in all
text-based major  modes (see Spelling),  and =ElDoc=  minor mode in  Emacs Lisp
mode (see Lisp Doc):

  : (add-hook 'text-mode-hook 'flyspell-mode)
  : (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)

** Minor Modes
#+cindex:minor modes
#+cindex:modes, minor
A *minor mode* is an optional editing mode that alters the behavior of Emacs in
some well-defined way. Unlike major modes, any  number of minor modes can be in
effect at any time.

#+texinfo: @subheading Buffer Local
Some minor modes are *buffer-local*, and  can be turned on (enabled) in certain
buffers and off (disabled) in others.

#+texinfo: @subheading Global
Other minor modes are *global*: while enabled, they affect everything you do in
the Emacs session, in all buffers.

#+texinfo: @subheading Enabling Minor Modes
Each minor mode is associated with a *mode command*, whose name consists of the
mode name followed  by =-mode=. For instance, the mode  command for =Auto Fill=
mode is ~auto-fill-mode~. But unlike a major mode command, which simply enables
the mode, the  mode command for a  minor mode can either  /enable/ or /disable/
it:

- toggle minor mode ::

  invoking the mode-command with no prefix argument /toggles/ it on or off;

- turn minor mode on or off ::

  - zero or negative prefix argument turns the mode unconditionally off
  - positive prefox argument turns the mode unconditionally on
  - when called from elisp,
    - =nil= or ommitted, mode is unconditinally turned on
    - non-=nil= is handled as above for zero, negative, or positive argument

#+texinfo: @subheading Mode Variable
#+cindex:mode variable
Most minor modes  also have a *mode  variable*, with the same name  as the mode
command. Its  value is non-=nil=  if the  mode is enabled,  and =nil= if  it is
disabled. You  should run the mode  command instead of altering  this variable.
setting  the   mode  variable  through   the  Customize  interface   (see  Easy
Customization) will always properly enable or disable the mode, since Customize
automatically runs the mode command for you.

*** Buffer Local Minor Modes
#+cindex:minor modes, buffer local
- =Abbrev= mode  automatically expands  text based on  pre-defined abbreviation
  definitions. See Abbrevs.

- =Auto Fill= mode inserts newlines as  you type to prevent lines from becoming
  too long. See Filling.

- =Auto Save= mode saves the buffer  contents periodically to reduce the amount
  of work you can lose in case of a crash. See Auto Save.

- =Electric Quote= mode automatically converts quotation marks. For example, it
  requotes text  typed `like this'  to text ‘like  this’. You can  control what
  kind of text  it operates in, and  you can disable it  entirely in individual
  buffers. See Quotation Marks.

- =Enriched= mode  enables editing and  saving of formatted text.  See Enriched
  Text.

- =Flyspell= mode automatically highlights misspelled words. See Spelling.

- =Font-Lock=  mode automatically  highlights  certain textual  units found  in
  programs.  It is  enabled globally  by  default, but  you can  disable it  in
  individual buffers. See Faces.

- =Display   Line    Numbers=   mode   is   a    convenience   wrapper   around
  ~display-line-numbers~,     setting     it     using     the     value     of
  ~display-line-numbers-type~. See Display Custom.

- =Outline minor=  mode provides  similar facilities to  the major  mode called
  =Outline= mode. See  Outline Mode.

- =Overwrite= mode causes ordinary printing characters to replace existing text
  instead of shoving it to the right. For  example, if point is in front of the
  ‘B’ in ‘FOOBAR’,  then in Overwrite mode  typing a G changes  it to ‘FOOGAR’,
  instead of  producing ‘FOOGBAR’  as usual. In  =Overwrite= mode,  the command
  =C-q=  inserts the  next  character whatever  it  may  be, even  if  it is  a
  digit—this gives  you a  way to  insert a character  instead of  replacing an
  existing character. The mode command,  overwrite-mode, is bound to the Insert
  key.

- =Binary Overwrite= mode  is a variant of =Overwrite= mode  for editing binary
  files;  it treats  newlines  and tabs  like other  characters,  so that  they
  overwrite  other  characters and  can  be  overwritten  by them.  In  =Binary
  Overwrite=  mode, digits  after =C-q=  specify  an octal  character code,  as
  usual.

- =Visual Line= mode  performs word wrapping, causing long lines  to be wrapped
  at word boundaries. See Visual Line Mode.

*** Global Minor Modes
#+cindex:minor modes, global
- =Column Number= mode enables display of the current column number in the mode
  line. See Mode Line.

- =Delete Selection= mode causes text insertion to first delete the text in the
  region, if the region is active. See Using Region.

- =Icomplete= mode displays an indication of available completions when you are
  in the minibuffer and completion is active. See Icomplete.

- =Line Number=  mode enables display  of the current  line number in  the mode
  line. It is enabled by default. See Mode Line.

- =Menu Bar= mode  gives each frame a  menu bar. It is enabled  by default. See
  Menu Bars.

- =Scroll Bar= mode gives  each window a scroll bar. It  is enabled by default,
  but the scroll bar is only displayed on graphical terminals. See Scroll Bars.

- =Tool Bar= mode  gives each frame a  tool bar. It is enabled  by default, but
  the tool bar is only displayed on graphical terminals. See Tool Bars.

- =Tab Bar= mode gives each frame a tab bar. See Tab Bars.

- =Tab Line= mode gives each window a tab line. See Tab Line.

- =Transient Mark=  mode highlights the  region, and makes many  Emacs commands
  operate on the region when the mark  is active. It is enabled by default. See
  Mark.

** File Modes
When you visit  a file, Emacs chooses a major  mode automatically. Normally, it
makes the choice  based on the file  name. Sometimes it chooses  the major mode
based on special text in the file. This special text can also be used to enable
buffer-local minor modes.

#+cindex:mode variable, file-local
#+cindex:file-local variable, major mode
1. First, Emacs checks whether the file contains file-local mode variables.
   - If there is a file-local variable  that specifies a major mode, then Emacs
     uses that major mode, ignoring all other criteria.
   - There  are several  methods to  specify a  major mode  using a  file-local
     variable;
     - =; -*-Lisp-*-=
     - =; -*- mode: Lisp; -*-=
       #+cindex:file-local variable, minor mode
   - You can also use file-local variables to specify buffer-local minor modes,
     by using ~eval~ specifications.
     - =; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-=
   - Note, however, that it is usually inappropriate to enable minor modes this
     way, since most minor modes  represent individual user preferences. If you
     personally want  to use  a minor mode  for a particular  file type,  it is
     better to enable the minor mode via a major mode hook.

2. Second, if there  is no file variable specifying a  major mode, Emacs checks
   whether the file’s contents begin with =#!=.
   #+cindex:executable shell command
   #+cindex:shell command, executable
   - If  so, that  indicates that  the file  can serve  as an  executable shell
     command, which works  by running an interpreter named on  the file’s first
     line (the rest of the file is used as input to the interpreter).
   - Emacs tries to use the interpreter name to choose a mode.
   - The variable ~interpreter-mode-alist~ specifies the correspondence between
     interpreter program names and major modes.
   - When the  first line starts  with =#!=, you  usually cannot use  the =-*-=
     feature on  the first  line, because  the system  would get  confused when
     running the  interpreter. So Emacs looks  for =-*-= on the  second line in
     such files as well as on the first line.

3. Third, Emacs tries to determine the major mode by looking at the text at the
   start of the buffer, based on the variable ~magic-mode-alist~.

4. Fourth  it looks at the  file’s name. The correspondence  between file names
   and major modes is controlled by the variable ~auto-mode-alist~.

5. Finally, if  Emacs still hasn’t found  a major mode to use,  it compares the
   text at the start of the buffer to the variable ~magic-fallback-mode-alist~.
   - This variable works like magic-mode-alist, described above, except that it
     is consulted only /after/ ~auto-mode-alist~.
   - By default, magic-fallback-mode-alist contains  forms that check for image
     files, HTML/XML/SGML files, PostScript files, and Unix style Conf files.

#+texinfo: @subheading @code{interpreter-mode-alist}

   #+attr_texinfo: :options interpreter-mode-alist
   #+begin_defvar
     Alist mapping interpreter names to major modes.

     See also ~auto-mode-alist~.
   #+end_defvar

#+texinfo: @subheading @code{auto-mode-alist}

   #+attr_texinfo: :options auto-mode-alist
   #+begin_defvar
     Alist of  filename patterns  vs corresponding  major mode  functions.

     Each element looks like
     : (REGEXP  . FUNCTION)
     or
     : (REGEXP FUNCTION NON-NIL).

     (=NON-NIL=  stands for  anything that  is not  =nil=; the  value does  not
     matter.)

     Visiting a  file whose name  matches =REGEXP= specifies =FUNCTION=  as the
     mode function to use. =FUNCTION= will be called, unless it is =nil=.

     If the element has the form
     : (REGEXP FUNCTION NON-NIL)
     then after calling =FUNCTION= (if it’s not nil), we delete the suffix that
     matched =REGEXP= and search the list again for another match.

     See also ~magic-mode-alist~.
   #+end_defvar

#+texinfo: @subheading @code{magic-mode-alist}

   #+attr_texinfo: :options magic-mode-alist
   #+begin_defvar
     Alist of  buffer beginnings vs.  corresponding major mode  functions. Each
     element looks  like
     : (REGEXP  . FUNCTION)
     or
     : (MATCH-FUNCTION  . FUNCTION).
     After visiting  a file, if =REGEXP=  matches the text at  the beginning of
     the  buffer   (case-sensitively),  or  calling   =MATCH-FUNCTION=  returns
     non-=nil=,  =normal-mode=  will  call   =FUNCTION=  rather  than  allowing
     ~auto-mode-alist~ to decide the buffer’s major mode.

     If =FUNCTION= is  =nil=, then it is  not called. (That is a  way of saying
     "allow ‘auto-mode-alist’ to decide for these files.")

     It’s default value is =nil=.
   #+end_defvar

#+texinfo: @subheading @code{magic-fallback-mode-alist}

   #+attr_texinfo: :options magic-fallback-mode-alist
   #+begin_defvar
      Like ‘magic-mode-alist’ but has lower priority than ~auto-mode-alist~.
   #+end_defvar

*** Normal Mode
If you  have changed the major  mode of a buffer,  you can return to  the major
mode Emacs would  have chosen automatically, by typing  =M-x normal-mode=. This
is the same function  that ~find-file~ calls to choose the  major mode. It also
processes the file’s =-*-= line or local variables list (if any).

#+texinfo: @subheading @code{normal-mode} Command

#+attr_texinfo: :options normal-mode &optional find-file
#+begin_defun
  Choose  the major  mode  for  this buffer  automatically.  Also  sets up  any
  specified local variables of the file or its directory. Uses the visited file
  name, the =-*-= line, and the local variables spec.

  The command  =M-x normal-mode=,  when used  interactively, always  obeys file
  local variable  specifications and the  =-*-= line, and ignores  the variable
  ~enable-local-variable~.

  ~enable-local-variables~ is  ignored if you run  ~normal-mode~ interactively,
  from Lisp without specifying the optional argument =FIND-FILE=.
#+end_defun

#+texinfo: @subheading @code{enable-local-variables} Variable

#+attr_texinfo: :options enable-local-variables
#+begin_defvar
  Control use of local  variables in files you visit. The value  can be
  - =t= :: (default) A value of t means file local variables specifications are
    obeyed if all the specified variable values are safe; if any values are not
    safe, Emacs queries you, once, whether to set them all.

  - =nil= :: means always ignore the file local variables.

  - =:safe= :: means set the safe variables, and ignore the rest.

  - =:all= :: means set all variables, whether safe or not.

  - or something else :: Any other value means always query you once whether to
    set them all.

This variable also controls use of major modes specified in a =-*-= line.
#+end_defvar

*** New Major Mode

#+findex:set-visited-file-name
#+findex:write-file
#+vindex:change-major-mode-with-file-name
#+cindex:file name, set new
The commands =C-x  C-w= (~write-file~) and ~set-visited-file-name~  change to a
new major  mode if the new  file name implies  a mode (see Saving).  (=C-x C-s=
(~save-buffer~) does this too, if the  buffer wasn’t visiting a file.)

However, this does not happen if the  buffer contents specify a major mode, and
certain special major modes  do not allow the mode to change.  You can turn off
this mode-changing feature by setting ~change-major-mode-with-file-name~ to nil.

** Text Mode
Text mode is a major mode for editing files of text in a human language.

To explicitly switch to Text mode, type:
: M-x text-mode

In Text mode, only blank lines and page delimiters separate paragraphs.

Paragraphs can be indented, and adaptive filling determines what indentation to
use when filling a paragraph.

- ~indent-for-tab-command~ (=TAB=) ::

  In =Text= mode, the  =TAB= (~indent-for-tab-command~) command usually inserts
  whitespace up to the next tab stop, instead of indenting the current line.

=Text= mode  turns off  the features  concerned with  comments except  when you
explicitly invoke them.

It changes the syntax table so that apostrophes are considered part of words

*** Paragraph-Indent Text Mode

#+findex:paragraph-indent-text-mode
If  you   indent  the  first   lines  of   paragraphs,  then  you   should  use
=Paragraph-Indent Text= mode rather than =Text= mode.

In that mode, you  do not need to have blank  lines between paragraphs, because
the first-line indentation is sufficient to start a paragraph.

#+findex:paragraph-indent-minor-mode
Use =M-x  paragraph-indent-minor-mode= to enable  an equivalent minor  mode for
situations where you  shouldn’t change the major  mode---in =mail composition=,
for instance.

*** Command @code{ispell-complete-word}

#+findex:ispell-complete-word
#+cindex:@key{M-TAB}
Text  mode  binds  =M-TAB=   to  ~ispell-complete-word~.

This  command performs  completion of  the partial  word in  the buffer  before
point, using the spelling dictionary as the space of possible words.

If your  window manager defines  =M-TAB= to switch  windows, you can  type =ESC
TAB= or =C-M-i= instead.

** Outline Mode
#+cindex:Outline mode
#+findex:outline-mode
=Outline= mode is  a major mode derived from =Text=  mode, which is specialized
for editing outlines.

Entering =Outline=  mode runs  the hook ~text-mode-hook~  followed by  the hook
~outline-mode-hook~.

*** Outline Minor Mode
#+findex:outline-minor-mode
=Outline  minor= mode  is a  buffer-local minor  mode which  provides the  same
commands as the major mode, =Outline= mode, but can be used in conjunction with
other major modes.

You can  type =M-x outline-minor-mode=  to toggle  =Outline minor= mode  in the
current buffer, or use a file-local variable setting to enable it in a specific
file.

#+cindex:Outline minor mode prefix
=Outline minor= mode provides bindings with =C-c @= as the prefix.

*** Outline Format
Outline mode assumes  that the lines in  the buffer are of  two types: /heading
lines/ and /body lines/.

  - heading lines ::

    A heading line represents a topic  in the outline. Heading lines start with
    one or more  asterisk (‘*’) characters; the number  of asterisks determines
    the depth of the heading in the outline structure.

  - body lines  ::

    Any line that is not a heading line  is a body line. Body lines belong with
    the preceding heading line.

  - entry ::

    A  heading  line   together  with  all  following  body   lines  is  called
    collectively an entry.

  - subtree ::

    A heading line  together with all following deeper heading  lines and their
    body lines is called a subtree.

*** Outline Motion
Outline mode provides special motion commands that move backward and forward to
heading lines. The  following commands take numeric prefix  arguments as repeat
counts.

  - ~outline-next-visible-heading~ (=C-c C-n=) :: Next visible heading line

  - ~outline-previous-visible-heading~ (=C-c C-p=)  :: Previous visible heading
    line

  - ~outline-forward-same-level~ (=C-c C-f=) :: Next visible same level heading
    line

  - ~outline-backward-same-level~ (=C-c  C-b=) ::  Previous visible  same level
    heading line

  - ~outline-up-heading~ (=C-c C-u=) :: Lower level visible heading line

*** Outline Visability
Outline  mode provides  several commands  for temporarily  hiding or  revealing
parts of the buffer, based on the outline structure. Many of these commands act
on the current heading line. If point is on a heading line, that is the current
heading line;  if point  is on  a body line,  the current  heading line  is the
nearest preceding header line.

#+texinfo: @heading Current Heading Commands

  - ~outline-show-entry~ (=C-c  C-e=) :: Make  the current heading  line’s body
    visible

  - ~outline-hide-entry~ (=C-c  C-c=) :: Make  the current heading  line’s body
    invisible

#+texinfo: @heading Current Heading Subtree Commands
These commands  apply to the current  heading line’s subtree: its  body, all of
its subheadings, both direct and indirect, and all of their bodies.

  - ~outline-show-subtree~  (=C-c C-s=)  ::   Make everything under the current
    heading visible

  - ~outline-hide-subtree~  (=C-c C-d=)  :: Make  everything under  the current
    heading invisible

  - ~outline-hide-leaves~   (=C-c   C-l=)    ::   Make  the body of the current
    heading line, and the bodies of all its subheadings, invisible; subheadings
    are left visible.

  - ~outline-show-branches~  (=C-c    C-k=)  ::    Make all subheadings  of the
    current  heading line,  at  all levels,  visible (if  they  were hidden  by
    ~outline-hide-subtree~); bodies are left invisible;

  - ~outline-hide-other~ (=C-c C-o=) :: Hide  everything except for the heading
    or body that  point is in, plus  the headings leading up from  there to the
    top level of the outline

#+texinfo: @heading Whole Buffer Commands

  - ~outline-show-all~ (=C-c C-a=) :: Make all lines in the buffer visible

  - ~outline-hide-body~  (=C-c C-t=)  ::  Make  all body  lines  in the  buffer
    invisible

  - ~outline-hide-sublevels~ (=C-c  C-q=) :: Hide  everything except the  top n
    levels of heading lines

  - ~outline-show-children~  (=C-c C-i=)   :: Make  immediate subheadings  (one
    level down) of the current heading line visible

*** Outline Views
You can display  two views of a  single outline at the same  time, in different
windows. To do this, you must create an indirect buffer.

*** Foldout Package
The =Foldout= package extends =Outline= mode with folding commands.  In
=Foldout= mode you zoom in on a nested portion of the outline while hiding its
relatives at higher levels.

To enable:

: M-x load-library RET foldout RET

or place the following in your ~inti~ file:

#+begin_src elisp
  (with-eval-after-load "outline"
    (require 'foldout))
#+end_src

To use:

1. ~foldout-zoom-subtree~ (=C-c C-z=) : Exposes *body and 2 child subheadings*,
   while narrowing  the buffer so only  level-1 heading, the body,  and level-2
   headings are visible.

2. Now to look under one of the level-2 headings, position the cursor on it and
   use =C-c  C-z= again. This  exposes the level-2  body and its  level-3 child
   subheadings and narrows the buffer again.

3. ~foldout-zoom-subtree  ARG~ (=C-u C-c  C-z=) : For *only  child subheadings*
   specify a numeric argument.

4.  ~foldout-zoom-subtree ARG~  (=M-2  C-C  C-z=) :  The  *number  of levels*  of
   children can  be specified too (compare  =M-x outline-show-children=), e.g.,
   =M-2 C-c C-z= exposes two levels of child subheadings.

5. Zooming in on successive subheadings can be done as much as you like.

6. A string in the mode line shows how deep you’ve gone.

7.  ~foldout-zoom-subtree  NEG-ARG~ (=M-- C-c  C-z=) :  *The body only*  can be
   specified with a negative argument.

8. ~foldout-zoom-subtree ZERO-ARG~ (=M-o C-c C-z=) : *The whole subtree* can be
   expanded, similarly to =C-c C-s= (=M-x outline-show-subtree=), by specifying
   a zero argument.

9. While you’re zoomed in, you can still use Outline mode’s exposure and hiding
   functions without disturbing Foldout.

10. Also, since the buffer is narrowed, global editing actions will only affect
    text under the zoomed-in heading. This is useful for restricting changes to
    a particular chapter or section of your document.

11. ~foldout-exit-fold~ (=C-c C-x=) : To *unzoom (exit)* a fold. This hides all
    the text and subheadings under the top-level heading and returns you to the
    previous view of the buffer.

12.  ~foldout-exit-fold  NUM-ARG~ (=M-2  C-c C-x=)  : To  *exit NUM  levels* of
    folds, specify a numeric argument.

13. ~foldout-exit-fold ZERO-ARG~ (=M-0 C-c C-x=)  : To *exit all folds* specify
    a zero argument.

14. ~foldout-exit-fold NEG-ARG~ (=M--2 C-c C-x=)  : To *cancel the narrowing of
    a  fold*  without hiding  the  text  and  subheadings, specify  a  negative
    argument. For example,  =M--2 C-c C-x= exits two folds  and leaves the text
    and subheadings exposed.

#+attr_texinfo: :options foldout-mouse-modifiers
#+begin_defvar
  List of  modifier keys to apply  to foldout’s mouse events.  Default value is
  =(meta control)=.

  The   default  =(meta   control)=   makes  foldout   bind   its  functions   to
  =M-C-down-mouse-{1,2,3}=.
#+end_defvar
* Loading
All functions call the ~load~ function:

** Load Functions
#+findex:load
#+attr_texinfo: :options load filename &optional missing-ok nomessage nosuffix must-suffix
#+begin_defun

#+vindex:load-prefer-newer
This function finds and opens a file of Lisp code, evaluates all the forms in
it, and closes the file.  If the option ~load-prefer-newer~ is non-nil, then
when searching suffixes, load selects whichever version of a file (‘.elc’,
‘.el’, etc.) has been modified most recently.

#+vindex:load-path
If filename is a relative file name, ~load~ searches for the file using the
variable ~load-path~.  The current default directory is tried only if it is
specified in ~load-path~, where nil stands for the default directory.

#+vindex:load-file-name
When found, Emacs sets the value of the variable ~load-file-name~ to that
file's name.

- FILENAME ::

  Execute a file of Lisp code named FILENAME.  Append =.elc=, =.el=,
  system-dependent suffix of dynamic modules, unmodified.  See ~load-suffixes~.
  Env vars are replaced with their values by calling ~substitute-in-file-name~.

- MISSING-OK ::

  If non-nil, don’t report error if FILE doesn’t exist.

- NOMESSAGE ::

  Print messages at start and end of loading unless this is non-nil.

- NOSUFFIX ::

  If non-nil, don’t add suffixes.

- MUST-SUFFIX ::

  If non-nil, insist on the suffix =.elc= or =.el= or the module suffix.

- RETURN ::

  Returns ’t’ if the file exists and loads successfully.
#+end_defun

*** Load-File

Use this command if you wish to specify precisely the file name to load.

#+attr_texinfo: :options load-file filename
#+begin_defun
- FILENAME :: Load the file named FILENAME.  If FILENAME is a relative file
  name, then the current default directory is assumed.  This command does not
  use ~load-path~, and does not append suffixes.
#+end_defun

*** Load-Library

This command is equivalent to ~load~, except for the way it reads its argument
interactively.  This is an interface to the function ~load~.

#+attr_texinfo: :options load-library library
#+begin_defun
- LIBRARY :: This command loads the library named LIBRARY (a string).
#+end_defun

** Provide and Require
#+cindex:feature
These work in terms of named /features/.  A /feature/ is loaded the first time
another program asks for it by name.  A /feature name/ is a symbol that stands
for a collection of functions, variables, etc.  The file that defines the
functions, variabes, etc. should /provide/ the feature.  Another program that
uses them may ensure they are defined by /requiring/ the feature.  This loads
the file of definitions if it has not been loaded yet.

To /require/ the presence of a /feature/, call ~require~ with the feature name
as argument.  ~require~ looks in the global variable ~features~ to see whether
the desired feature has been provide already.  If not, it loads the feature
from the appropriate file.  This file should call ~provide~ at the top level to
add the feature to ~features~.

Features are normally named after the files that provide them, so that
~require~ need not be given the file name.

#+attr_texinfo: :options provide feature &optional subfeatures
#+begin_defun
- FEATURE :: a symbol that accounces that FEATURE is a feature of the current
  Emacs, e.g., it is loaded into the current Emacs session, and its facilities
  are or will be available for other Lisp programs.  ~provide~ ensures that
  FEATURE is added to the front of the variable ~features~ if it is not already
  there.  If it has not already been added, the ~provide~ calls any
  ~eval-after-load~ code waiting for it.

- SUBFEATURES ::  a list of symbols listing particular subfeatures supported in
  this version of FEATURE.

- RETURN VALUE :: FEATURE is returned.
#+end_defun

#+attr_texinfo: :options require feature &optional filename noerror
#+begin_defun
- FEATURE :: a symbol representing a set of code and variables to load into the
  current Emacs.  If FEATURE is not a member of the list held by the variable
  ~features~, tested by ~featurep~, then load it from FILENAME.  If FILENAME is
  omitted, the /printname/ of FEATURE is used as the file name, and ~load~ will
  try to laod this name, with an added suffixe (require).  The directories in
  ~load-path~ are searched.

- FILENAME :: if given, then load the feature from the file identified by
  FILENAME.

- NOERROR :: if non-nil, return nil if the file is not found instead of
  signalling an error.

- RETURN VALUE :: the return value is FEATURE.
#+end_defun

#+attr_texinfo: :options featurep feature &optional subfeature
#+begin_defun
- FEATURE :: the symbol to check.  This function returns t if FEATURE has
   already been provided in the current Emacs session.

- RETURN VALUE :: Boolean t if FEATURE has alreayd been provided.
#+end_defun

#+attr_texinfo: :options features
#+begin_defvar
The value of this variable is  list of symbols that are the features loaded in
the current Emacs session, put there by calls to ~provide~.
#+end_defvar
* Packages

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging


#+cindex:package
Emacs provides a standard way to distribute Emacs Lisp code to users.
A package is a collection of one or more files, formatted and bundled
in such a way that users can easily download, install, uninstall, and
upgrade it.

** Installing and Using Packages
- https://www.emacswiki.org/emacs/InstallingPackages

The most common method of installing packages of Emacs Lisp since
Emacs 24 has been *ELPA* packages.  Additional package archives such
as *MELPA* exist to supplement what is in GnuELPA.

#+cindex:UsePackage
#+cindex:use-package
[[https://github.com/jwiegley/use-package][UsePackage]] can make it easier for you to organize your package-related
configuration.

** Emacs Lisp Package Manager and Archives
#+cindex:ELPA
#+cindex:@code{package.el}
#+cindex:Tromey, Tom

- http://tromey.com/elpa/index.html


ELPA is the Emacs Lisp Package Archive, written originally by [[https://www.emacswiki.org/emacs/TomTromey][Tom Tromey]].  It
is included in GnuEmacs, starting with version 24 as ~package.el~.
~package.el~ supports multiple ELPA repositories.

*** GnuElpa

#+cindex:ELPA
#+cindex:GnuElpa
“GNU Emacs Lisp Package Archive---The default package repository for
GNU Emacs.”

- http://elpa.gnu.org

- [[http://elpa.gnu.org/packages/][Browse the Repositories]]

- [[http://git.savannah.gnu.org/cgit/emacs/elpa.git][The Gnu ELPA Repository]]

- [[https://savannah.gnu.org/projects/emacs][Gnu ELPA Project Page]]


This should already be in Emacs (for Emacs 24+):

- ~package-archives~ ::

    : (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")))


You can also add repositories one at a time:

: (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
: (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t) ; Org-mode's repository

To use it, type =M-x list-packages= in Emacs.

Since you'll probably want to use your installed packages, it's also
recommended that you add ~(package-initialize)~ somewhere in your
~$HOME/.emacs~ file.

*** Milkypostman’s Emacs Lisp Package Archive---MELPA

- https://melpa.org/

- https://www.emacswiki.org/emacs/MELPA


#+cindex:MELPA
MELPA is an ELPA-compatible package repository that contains an enormous amount
of useful Emacs packages.

#+texinfo:@heading Features

- Up-to-date packages built on our servers from upstream source

- Installable in any Emacs with 'package.el' - no local version-control tools
  needed

- Curated - no obsolete, renamed, forked or randomly hacked packages

- Comprehensive - more packages than any other archive

- Automatic updates - new commits result in new packages

- Extensible - contribute recipes via github, and we'll build the packages

**** Getting Started with MELPA

***** Installing MELPA

You need ~package.el~.  Emacs 24 on has ~package.el~ bundled.

#+cindex:@code{package-archives}
#+vindex:package-archives
#+cindex:@code{package-initialize}
Enable installation of packages from MELPA by adding an entry to
~package-archives~ after ~(require 'package)~ and before the call to
~package-initialize~ in your ~init.el~ or ~.emacs~ file:

: (add-to-list 'package-archives (cons "melpa" "https://melpa.org/packages/") t)
: (add-to-list 'package-archives (cons "melpa-stable" "https://stable.melpa.org/packages/") t)

*** How Packages Work

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html#Packaging-Basics


Whenever Emacs starts up, it automatically calls the function
‘package-initialize’ to load installed packages.  This is done after
loading the init file and before running ‘after-init-hook’.  Automatic
package loading is disabled if the user option
~package-enable-at-startup~ is nil.

This means you should NOT put package specific initialization into
your ~init.el~ except in a few ways:

- customization variables for a package can be set before a package
  has loaded;

- ~auto-mode-alist~ changes can be made in a way that does not require
  the package to be loaded before they are setup:
  : (add-to-list 'auto-mode-alist '("\\.gradle" . groovy-mode))

- mode specific customization of a package could go in a package hook
  which can be set before the package is loaded, for example:
  : (add-hook 'groovy-mode-hook (lambda () (setq tab-width 4)))

- key bindings can also be done in such a way to not cause init
  failure, even if the package is not loaded:
  : (global-set-key (kbd "C-'")     'shell-switcher-switch-buffer)

- some package specific initialization can be done with
  ~eval-after-load~


It might be easier just to move ~package-initialize~ to another point
during startup so you can ~(require)~ ELPA packages; this takes care
of a lot of the described issues:

#+begin_src emacs-lisp :eval no
  ;; basic initialization, (require) non-ELPA packages, etc.
  (setq package-enable-at-startup nil)
  (package-initialize)
  ;; (require) your ELPA packages, configure them as normal
#+end_src

#+texinfo:@heading Using with-eval-after-load For Package Config

Starting in emacs 24.4, ~with-eval-after-load~ is simpler than
~eval-after-load~:

#+begin_src emacs-lisp :eval no
  (with-eval-after-load 'abcd-mode
         (setq-default abcd-basic-offset 7) ; setting some option
         (add-to-list 'abcd-globals-list "console") ; appending to a list option
         (add-hook 'abcd-mode-hook 'prepare-some-abcd-soup) ; things to do for abcd mode buffers
         (define-key abcd-mode-map (kbd "C-c C-c") 'play-some-abcd-song) ; add some key binding for abcd mode
         )
#+end_src

** UsePackage

- https://jwiegley.github.io/use-package/

- https://github.com/jwiegley/use-package


“The ~use-package~ macro allows you to isolate package configuration
in your ~.emacs~ file in a way that is both performance-oriented and,
well, tidy.  I created it because I have over 80 packages that I use
in Emacs, and things were getting difficult to manage.  Yet with this
utility my total load time is around 2 seconds, with no loss of
functionality!”

~use-package~ is /not/ a package manager!  Although ~use-package~ does
have the useful capability to interface with package managers (see
below), /its primary purpose is for the configuration and loading of
packages/.

~use-package~ is available from Melpa and Melpa-Stable.

To install:
: M-x package-install RET use-package RET

** Slime
“The Superior Lisp Interaction Mode for Emacs”

[[file:resources/images/slime-small.png]]

- [[https://common-lisp.net/project/slime/][Slime Home]]

  “SLIME is a[n] Emacs mode for  Common Lisp development.  Inspired by existing
  systems  such  [as]  Emacs Lisp  and  ILISP,  we  are  working to  create  an
  environment for hacking Common Lisp in.”

- [[https://github.com/slime/slime][Slime on Github]]

  “SLIME extends Emacs with support for interactive programming in Common Lisp.
  The  features  are  centered  around slime-mode,  an  Emacs  minor-mode  that
  complements the  standard lisp-mode.   While lisp-mode supports  editing Lisp
  source files, slime-mode  adds support for interacting with  a running Common
  Lisp process for compilation, debugging, documentation lookup, and so on.”

- [[https://common-lisp.net/project/slime/doc/html/][Slime User Manual Version 2.22]]

  - [[https://common-lisp.net/project/slime/doc/slime.pdf][PDF]]

- [[https://github.com/slime/slime/releases][Slime Latest Release Version 2.24]]

  Slime version 2.24 released on 2019-05-27


#+texinfo: @heading SLIME Internals

#+begin_quote
SLIME is  constructed from two parts:  a user-interface written in  Emacs Lisp,
and  a supporting  server program  written in  Common Lisp.  The two  sides are
connected together with a socket and communicate using an RPC-like protocol.

The Lisp  server is primarily  written in  portable Common Lisp.   The required
implementation-specific functionality is specified  by a well-defined interface
and  implemented separately  for each  Lisp implementation.   This makes  SLIME
readily portable.
#+end_quote


#+texinfo:@heading About SLIME Mode

#+attr_texinfo: :indic b
- Slime Mode ::

  An Emacs minor-mode to enhance lisp-mode with:

  - Code evaluation, compilation, and macroexpansion.

  - Online documentation (describe, apropos, hyperspec).

  - Definition finding (aka Meta-Point aka M-.).

  - Symbol and package name completion.

  - Automatic macro indentation based on &body.

  - Cross-reference interface (WHO-CALLS, etc).

- SLDB ::

  Common Lisp debugger with an Emacs-based user interface.

- REPL :: 

  The Read-Eval-Print Loop ("top-level") is written in Emacs Lisp for tighter
  integration with Emacs.  The REPL also has builtin "shortcut" commands
  similar those of the McCLIM listener.

- Compilation notes :: 

  SLIME is able to take compiler messages and annotate them directly into
  source buffers.

- Inspector :: 

  Interactive object-inspector in an Emacs buffer.

- Compatible Implementations :: 

  - CMU Common Lisp (CMUCL)
  - Steel Bank Common Lisp (SBCL)
  - Clozure CL (a.k.a. OpenMCL)
  - LispWorks
  - Allegro CL
  - CLISP
  - Scieneer CL
  - ECL
  - Corman CL
  - ABCL

** Polymode
- https://polymode.github.io
- [[https://github.com/polymode/polymode][on GitHub]]


Polymode is  a framework for multiple  major modes (MMM) inside  a single Emacs
buffer.  It is  fast and  has  a simple  but flexible  object oriented  design.
Creating new polymodes normally takes a few lines of code.

** literate-elisp
"A  literate programming  tool to  load  Emacs Lisp  codes from  org mode  file
directly"

- https://github.com/jingtaozf/literate-elisp


It extends the Emacs load mechanism so  Emacs can load org files as lisp source
files directly.
* Special Packages
  :PROPERTIES:
  :ID:       4BACDC59-1256-480D-A680-FD3559A85C1A
  :END:
** Auctex
:PROPERTIES:
:latest:   auctex-12.3.1.tar, 2020-Oct-22, 6.36 MiB
:as-of:    2020-11-09
:END:
"AUCTEX is  an extensible package for  writing and formatting TEX  files in GNU
Emacs."

- [[https://www.gnu.org/software/auctex/index.html][Auctex Home]]
- [[https://elpa.gnu.org/packages/auctex.html][Gnu ELPA Auctex]]
- [[http://git.savannah.gnu.org/gitweb/?p=emacs/elpa.git;a=shortlog;h=refs/heads/externals/auctex][Browse ELPA’s Repo]]
- [[https://www.gnu.org/software/auctex/manual/auctex.pdf][Auctex Manual Version 12.3, 2020-10-22]]
** awesome
- https://github.com/sindresorhus/awesome#readme

** awesome-emacs
- https://github.com/emacs-tw/awesome-emacs

a community driven list of useful Emacs packages, utilities and libraries
*** Interface Enhancement
- https://github.com/emacs-tw/awesome-emacs#interface-enhancement
*** Key-bindings
- https://github.com/emacs-tw/awesome-emacs#key-bindings
*** File Manager
- https://github.com/emacs-tw/awesome-emacs#file-manager
*** Navigation
- https://github.com/emacs-tw/awesome-emacs#navigation
*** Visual
- https://github.com/emacs-tw/awesome-emacs#visual
*** Editing
- https://github.com/emacs-tw/awesome-emacs#editing
*** Kill-ring
- https://github.com/emacs-tw/awesome-emacs#kill-ring
*** Project management
- https://github.com/emacs-tw/awesome-emacs#project-management
*** Programming
- https://github.com/emacs-tw/awesome-emacs#programming
*** Completion
- https://github.com/emacs-tw/awesome-emacs#completion
*** Debugging
- https://github.com/emacs-tw/awesome-emacs#debugging
*** Document
- https://github.com/emacs-tw/awesome-emacs#document
*** Code Folding
- https://github.com/emacs-tw/awesome-emacs#code-folding
*** Error Checking
- https://github.com/emacs-tw/awesome-emacs#error-checking
*** Jump to Definition
- https://github.com/emacs-tw/awesome-emacs#jump-to-definition
*** Programming Language
- https://github.com/emacs-tw/awesome-emacs#programming-language
*** C/C++
- https://github.com/emacs-tw/awesome-emacs#cc
*** Python
- https://github.com/emacs-tw/awesome-emacs#python
*** Ruby
- https://github.com/emacs-tw/awesome-emacs#ruby
*** Lisp Family
- https://github.com/emacs-tw/awesome-emacs#lisp-family
*** Common Lisp
- https://github.com/emacs-tw/awesome-emacs#common-lisp
*** Scheme
- https://github.com/emacs-tw/awesome-emacs#scheme
*** Racket
- https://github.com/emacs-tw/awesome-emacs#racket
*** Clojure
- https://github.com/emacs-tw/awesome-emacs#clojure
*** Emacs Lisp
- https://github.com/emacs-tw/awesome-emacs#emacs-lisp
*** Web Development
- https://github.com/emacs-tw/awesome-emacs#web-development
*** JavaScrip
- https://github.com/emacs-tw/awesome-emacs#javascript
*** CoffeeScript
- https://github.com/emacs-tw/awesome-emacs#coffeescript
*** TypeScrip
- https://github.com/emacs-tw/awesome-emacs#typescript
*** PureScript
- https://github.com/emacs-tw/awesome-emacs#purescript
*** PHP
- https://github.com/emacs-tw/awesome-emacs#php
*** Java
- https://github.com/emacs-tw/awesome-emacs#java
*** Go
- https://github.com/emacs-tw/awesome-emacs#go
*** C#
- https://github.com/emacs-tw/awesome-emacs#c
*** Rust
- https://github.com/emacs-tw/awesome-emacs#rust
*** Erlang
- https://github.com/emacs-tw/awesome-emacs#erlang
*** Elixir
- https://github.com/emacs-tw/awesome-emacs#elixir
*** Haskell
- https://github.com/emacs-tw/awesome-emacs#haskell
*** Swift
- https://github.com/emacs-tw/awesome-emacs#swift
*** Scala
- https://github.com/emacs-tw/awesome-emacs#scala
*** Lua
- https://github.com/emacs-tw/awesome-emacs#lua
*** Makefile
    :PROPERTIES:
    :org-template-version: 0.6.20
    :END:
- https://github.com/emacs-tw/awesome-emacs#makefile
*** SML
- https://github.com/emacs-tw/awesome-emacs#sml
*** Groovy
- https://github.com/emacs-tw/awesome-emacs#groovy
*** Kotlin
- https://github.com/emacs-tw/awesome-emacs#kotlin
*** R
- https://github.com/emacs-tw/awesome-emacs#r
*** Julia
- https://github.com/emacs-tw/awesome-emacs#julia
*** OCaml
- https://github.com/emacs-tw/awesome-emacs#ocaml
*** ReasonML
- https://github.com/emacs-tw/awesome-emacs#reasonml
*** Nim
- https://github.com/emacs-tw/awesome-emacs#nim
*** D
- https://github.com/emacs-tw/awesome-emacs#d
*** Elm
- https://github.com/emacs-tw/awesome-emacs#elm
*** Stan
- https://github.com/emacs-tw/awesome-emacs#stan
*** MIPS Assembly
- https://github.com/emacs-tw/awesome-emacs#mips-assembly
*** RISCV Assembl
- https://github.com/emacs-tw/awesome-emacs#riscv-assembly
*** Verilog
- https://github.com/emacs-tw/awesome-emacs#verilog
*** LAMMPS
- https://github.com/emacs-tw/awesome-emacs#lammps
*** Keys Cheat Sheet
- https://github.com/emacs-tw/awesome-emacs#keys-cheat-sheet
*** Note
- https://github.com/emacs-tw/awesome-emacs#note
*** Org-mode
- https://github.com/emacs-tw/awesome-emacs#org-mode
*** Version control
- https://github.com/emacs-tw/awesome-emacs#version-control
*** Integration
- https://github.com/emacs-tw/awesome-emacs#integration
*** Console
- https://github.com/emacs-tw/awesome-emacs#console
*** Operating System
- https://github.com/emacs-tw/awesome-emacs#operating-system
*** Search
- https://github.com/emacs-tw/awesome-emacs#search
*** Pastebin
- https://github.com/emacs-tw/awesome-emacs#pastebin
*** Google
- https://github.com/emacs-tw/awesome-emacs#google
*** Blog System
- https://github.com/emacs-tw/awesome-emacs#blog-system
*** Markdown
- https://github.com/emacs-tw/awesome-emacs#markdown
*** LaTeX
- https://github.com/emacs-tw/awesome-emacs#latex
*** PDF
- https://github.com/emacs-tw/awesome-emacs#pdf
*** Internet
- https://github.com/emacs-tw/awesome-emacs#internet
*** Browser
- https://github.com/emacs-tw/awesome-emacs#browser
*** Mail
- https://github.com/emacs-tw/awesome-emacs#mail
*** IRC
- https://github.com/emacs-tw/awesome-emacs#irc
*** Chat
- https://github.com/emacs-tw/awesome-emacs#chat
*** Social Network
- https://github.com/emacs-tw/awesome-emacs#social-network
*** Web Feed
- https://github.com/emacs-tw/awesome-emacs#web-feed
*** DevOps
- https://github.com/emacs-tw/awesome-emacs#devops
*** Package Management
- https://github.com/emacs-tw/awesome-emacs#package-management
*** Package Manager
- https://github.com/emacs-tw/awesome-emacs#package-manager
*** Package Configuration
- https://github.com/emacs-tw/awesome-emacs#package-configuration
*** Package Updates
- https://github.com/emacs-tw/awesome-emacs#package-updates
*** Library
- https://github.com/emacs-tw/awesome-emacs#library
*** Appearance
- https://github.com/emacs-tw/awesome-emacs#appearance
*** Theme
- https://github.com/emacs-tw/awesome-emacs#theme
*** Multimedia
- https://github.com/emacs-tw/awesome-emacs#multimedia
*** Finance
- https://github.com/emacs-tw/awesome-emacs#finance
*** Fun
- https://github.com/emacs-tw/awesome-emacs#fun
*** Music
- https://github.com/emacs-tw/awesome-emacs#music
*** Starter Kit
- https://github.com/emacs-tw/awesome-emacs#starter-kit
*** Tutorials
- https://github.com/emacs-tw/awesome-emacs#tutorials
*** Links and resources
- https://github.com/emacs-tw/awesome-emacs#links-and-resources
** CSV Mode
- org-table-convert-region BEG END &optional SEPARATOR::

  Convert region to a table, between point BEG and END, extended to the
  beginning and ending of lines. SEPARATOR specifies the field separator in the
  lines.

  - 4 :: use the COMMA as a field separation

  - 16 :: use the TAB

  - 64 :: prompt for a regexp as a field separator

  - integer :: that many spaces

  - regexp :: use the regexp as a field separator

  - nil :: be smart and figure it out
** Magit
‘A Git Porcelain inside Emacs’

See [[https://www.masteringemacs.org/article/introduction-magit-emacs-mode-git][“An introduction to Magit, an Emacs mode for Git”]]

Magit is an interface to the version control system Git, implemented as an
Emacs package. Magit aspires to be a complete Git porcelain; it is complete
enough to allow even experienced Git users to perform almost all of their daily
version control tasks directly from within Emacs.

- [[https://magit.vc][Magit Home]]
- [[https://magit.vc/manual/magit/index.html#SEC_Contents][Magit User Manual]]


{{{heading(Staging and Unstaging)}}}

Staging and otherwise applying changes is one of the most important features in
a Git porcelain and here Magit outshines anything else, including Git itself.
Git’s own staging interface (git add --patch) is so cumbersome that many users
only use it in exceptional cases.  In Magit staging a hunk or even just part of
a hunk is as trivial as staging all changes made to a file.

{{{subheading(Status Buffer)}}}

The most visible part of Magit’s interface is the status buffer, which displays
information about the current repository. Its content is created by running
several Git commands and making their output actionable.  Among other things,
it displays information about the current branch, lists unpulled and unpushed
changes and contains sections displaying the staged and unstaged changes.  That
might sound noisy, but, since sections are collapsible, it’s not.

{{{subheading(Stage and Unstage)}}}

To stage or unstage a change one places the cursor on the change and then types
=s= or =u=.  The change can be a file or a hunk, or when the region is active
(i.e. when there is a selection) several files or hunks, or even just part of a
hunk.  The change or changes that these commands --- and many others --- would
act on are highlighted.

{{{subheading(Apply Variants)}}}

Magit also implements several other “apply variants” in addition to staging and
unstaging.  One can discard or reverse a change, or apply it to the working
tree.  Git’s own porcelain only supports this for staging and unstaging and you
would have to do something like =git diff ... | ??? | git apply ...= to
discard, revert, or apply a single hunk on the command line.  In fact that’s
exactly what Magit does internally (which is what lead to the term “apply
variants”).

{{{heading(Advanced Features)}}}

Magit fully embraces Git. It exposes many advanced features using a simple but
flexible interface instead of only wrapping the trivial ones like many GUI
clients do. Of course Magit supports logging, cloning, pushing, and other
commands that usually don’t fail in spectacular ways; but it also supports
tasks that often cannot be completed in a single step. Magit fully supports
tasks such as:

- merging
- rebasing
- cherry-picking
- reverting
- blaming


{{{noindent}}}by not only providing a command to initiate these tasks but also
by displaying context sensitive information along the way and providing
commands that are useful for resolving conflicts and resuming the sequence
after doing so.

Magit wraps and in many cases improves upon at least the following Git
porcelain commands:

- add
- am
- bisect
- blame
- branch
- checkout
- cherry
- cherry-pick
- clean
- clone
- commit
- config
- describe
- diff
- fetch
- format-patch
- init
- log
- merge
- merge-tree
- mv
- notes
- pull
- rebase
- reflog
- remote
- request-pull
- reset
- revert
- rm
- show
- stash
- submodule
- tag


Many more Magit porcelain commands are implemented on top of Git plumbing
commands.
*** Status Buffer

{{{heading(Status)}}}

#+cindex:status
#+cindex:magit-status
To display information about the current Git repository, type =M-x magit-status
RET=.  You will be using this command a lot, and should therefore give it a
global key binding.  This is what we recommend:

: (global-set-key (kbd "C-x g") 'magit-status)

{{{subheading(Status Buffer)}}}

#+cindex:status buffer
Most Magit commands are commonly invoked from the status buffer.  It can be
considered the primary interface for interacting with Git using Magit.  Many
other Magit buffers may exist at a given time, but they are often created from
this buffer.

{{{subheading(Safe State)}}}

Return to a safe state:

: git reset --hard PRE-MAGIT-STATE

{{{subheading(Refresh Status Buffer)}}}

#+cindex:refresh status buffer
#+cindex:status buffer, refresh
Go to the status buffer, while at the same time refreshing it, by typing =C-x
g=.  (When the status buffer, or any Magit buffer for that matter, is the
current buffer, then you can also use just =g= to refresh it).

{{{subheading(Move Between Sections)}}}

Move between sections using =p= and =n=.  Note that the bodies of some sections
are hidden.  Type =TAB= to expand or collapse the section at point.  You can
also use =C-tab= to cycle the visibility of the current section and its
children.

{{{subheading(Stage Changes)}}}

#+cindex:stage changes
Move to a file section inside the section named “Unstaged changes”
and type =s= to stage the changes you have made to that file.  That file now
appears under “Staged changes”.

{{{subheading(Stage and Unstage Hunks)}}}

Magit can stage and unstage individual hunks, not just complete files.  Move to
the file you have just staged, expand it using =TAB=, move to one of the hunks
using =n=, and unstage just that by typing =u=.  Note how the staging (=s=) and
unstaging (=u=) commands operate on the change at point. Many other commands
behave the same way.
** Polymode
Multiple Major Modes and How to Use SQL and Python in one Buffer

- [[https://www.masteringemacs.org/article/polymode-multiple-major-modes-how-to-use-sql-python-in-one-buffer][About Polymode]]

** Tramp
*** Open a File with Root Privilege
To open a file as Root owner from within Emacs, use the Tramp package as
follows:

: C-x C-f
: /sudo::<path/to/file>

Tramp provides access to files that Emacs cannot open directly.

=/sudo::= is shorthand for =/sudo:root@<hostname>:=
** Working with JavaScript
*** Setting up Emacs for JavaScript
    :PROPERTIES:
    :type:     article
    :author:   Nicolas Petton
    :date:     Apr 23, 2017
    :END:

    #+cindex:javascript
    #+cindex:js-mode
    #+cindex:js2-mode
    #+cindex:js2-refactor
    #+cindex:xref-js2
**** Part 1
- https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html
***** JS Mode
Emacs comes with a major mode for JavaScript named ~js-mode~.

We’ll be using  ~js2-mode~ instead, an external package  that extends ~js-mode~
and provides a very interesting  feature: instead of using regular expressions,
it parses buffers and builds an  AST for things like syntax highlighting. While
diverging  a bit  from the  traditional “Emacs  way of  doing things”,  this is
really  interesting,  and  used  as  the foundation  for  other  features  like
refactorings.

***** JS2 Mode
****** Setting Up JS2 Mode
- install and setup js2-mode like the following:

  : M-x package-install RET js2-mode RET

  #+begin_src elisp
    (require 'js2-mode)
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))

    ;; Better imenu
    (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
  #+end_src

***** JS2 Refactor
~js2-refactor~ is  a JavaScript  refactoring library for  emacs. ~js2-refactor~
adds  powerful  refactorings based  on  the  AST  generated by  ~js2-mode~.  It
provides a collection  of refactoring functions leveraging the  AST provided by
~js2-mode~.

: M-x package-install RET js2-refactor RET

Refactorings  go  from  inlining/extracting  variables  to  converting  ternary
operators  to  =if=  statements.  The   =README=  provides  the  full  list  of
keybindings.

One minor tweak  that I really couldn’t live without  is binding ~js2r-kill~ to
=C-k= in JS buffers:

#+begin_src elisp
  (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
#+end_src

This command is very similar to killing in ~paredit~: It kills up to the end of
the line, but always keeping the AST valid.

***** Xref JS2
~xref-js2~  makes  it easy  to  jump  to  function references  or  definitions.
~xref-js2~  adds  support  for  quickly  jumping  to  function  definitions  or
references to JavaScript projects in Emacs (>= 25.1).

~xref-js2~ uses ~ag~ to perform searches, so you’ll need to install it as well.
Instead of  using a tag system,  it relies on ~ag~  to query the codebase  of a
project.

: M-x package-install RET xref-js2 RET

- =M-.= :: Jump to definition
- =M-?= :: Jump to references
- =M-,= :: Pop back to where M-. was last invoked.

#+begin_src elisp
  (require 'js2-refactor)
  (require 'xref-js2)

  (add-hook 'js2-mode-hook #'js2-refactor-mode)
  (js2r-add-keybindings-with-prefix "C-c C-r")
  (define-key js2-mode-map (kbd "C-k") #'js2r-kill)

  ;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
  ;; unbind it.
  (define-key js-mode-map (kbd "M-.") nil)

  (add-hook 'js2-mode-hook (lambda ()
    (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
#+end_src

***** Summary
We still  have a  lot to  explore like  linting, getting  good auto-completion,
using snippets, setting up a REPL and debugger, etc.

**** Part 2
This time we’ll focus on getting good auto-completion with type inference.

#+cindex:tern
#+cindex:company-mode
***** Setting up Tern & company-mode for auto-completion
~Tern~ is a  great tool once setup  correctly. It parses JavaScript  files in a
project and  does type  inference to provide  meaningful completion  (with type
hints) and support for cross-references.

Unfortunately,  cross-references  with ~tern~  never  reliably  worked for  me,
that’s why I have always been using ~xref-js2~ instead for that.

For auto-completion, we’ll be using ~company-mode~ with ~tern~.

Install ~tern~:

: $ sudo npm install -g tern

Install the Emacs packages:

: M-x package-install RET company-tern RET

The Emacs  configuration is  straight-forward, we simply  enable ~company-mode~
with the ~tern~ backend for JavaScript buffers:

#+begin_src elisp
  (require 'company)
  (require 'company-tern)

  (add-to-list 'company-backends 'company-tern)
  (add-hook 'js2-mode-hook (lambda ()
			     (tern-mode)
			     (company-mode)))

  ;; Disable completion keybindings, as we use xref-js2 instead
  (define-key tern-mode-keymap (kbd "M-.") nil)
  (define-key tern-mode-keymap (kbd "M-,") nil)
#+end_src

Now, depending  on your JavaScript project,  you might want to  setup ~tern~ to
work with  your project structure.  If completion doesn’t  work out of  the box
using ~tern~ defaults you will have to set it up using a ~.tern-project~ placed
in the root folder containing your JavaScript files.

Here’s  an example  setup for  a project  that uses  ~requirejs~ and  ~jQuery~,
ignoring files from the ~bower_components~ directory:

#+begin_src js
  {
    "libs": [
      "jquery"
    ],
    "loadEagerly": [
      "./**/*.js"
    ],
    "dontLoad": [
      "./bower_components/"
    ],
    "plugins": {
      "requirejs": {
	"baseURL": "./"
      }
    }
  }
#+end_src

Once setup, ~tern~ offers superb  completion. Together with ~company-mode~, you
get great context-based completion with type inference.

When completing a function, you can hit =<F1>= to get its documentation.
** Working with JSON
See [[http://wikemacs.org/wiki/Json][WikEmacs]]
*** Built-in JSON Printers
Starting from Emacs 24.4 we have the built-in commands:

- ~json-pretty-print~
- ~json-pretty-print-buffer~


These came from the ~json-reformat~ package:
- [[https://github.com/gongo/json-reformat][json-reformat on GitHub]]

*** json Mode
- [[https://github.com/joshwnj/json-mode][json-mode on GitHub]] ::

  Major mode  for editing =JSON=  files. Extends  the builtin ~js-mode~  to add
  better syntax highlighting for =JSON= and some nice editing keybindings.

  : M-x package-install json-mode

*** flymake-json
- [[https://github.com/purcell/flymake-json][flymake-json on GitHub]]

An Emacs ~flymake~ handler for syntax-checking =JSON= using ~jsonlint~ from ~npm~.

*** json
- [[https://github.com/ryancrum/json.el][json.el on GitHub]]

This is a library for parsing and generating JSON (JavaScript Object Notation).

*** request
- [[https://tkf.github.io/emacs-request/][request.el on GitHub]]
- [[http://tkf.github.io/emacs-request/manual.html][request.el manual]]


Easy HTTP request for Emacs Lisp

~Request.el~ is  a =HTTP= request  library with multiple backends.  It supports
~url.el~ which is shipped with Emacs  and ~curl~ command line program. User can
use ~curl~ when s/he has it, as  ~curl~ is more reliable than ~url.el~. Library
author can  use ~request.el~  to avoid imposing  external dependencies  such as
~curl~ to users while giving richer experience for users who have ~curl~.

**** Installation

The latest release is =v0.3.2= 2019-11-19

: M-x package-install RET request RET

**** Examples

#+name: GET Example
#+caption: GET Example
#+begin_src elisp
  (request
   "http://httpbin.org/get"
   :params '(("key" . "value") ("key2" . "value2"))
   :parser 'json-read
   :success (cl-function
   (lambda (&key data &allow-other-keys)
	       (message "I sent: %S" (assoc-default 'args data)))))
#+end_src

#+name:GET Block Example
#+caption:Block until completion
#+begin_src elisp
  (request
   "http://httpbin.org/get"
   :sync t
   :complete (cl-function
	     (lambda (&key response &allow-other-keys)
	       (message "Done: %s" (request-response-status-code response)))))
#+end_src

#+name:Curl Authentication
#+caption:Curl Authentication
#+begin_src elisp
  (request
   "http://httpbin.org/get"
   :auth "digest" ;; or "basic", "anyauth", etc., which see curl(1)
   :complete (cl-function
	      (lambda (&key response &allow-other-keys)
		(message "Done: %s" (request-response-status-code response)))))
#+end_src

#+name:Request Binary Data
#+caption:Request Binary Data
#+begin_src elisp
  (request
   "http://httpbin.org/get"
   :encoding 'binary
   :complete (cl-function
	      (lambda (&key response &allow-other-keys)
		(message "Done: %s" (request-response-status-code response)))))
#+end_src

#+name: POST Example
#+caption: POST Example
#+begin_src elisp
  (request
   "http://httpbin.org/post"
   :type "POST"
   :data '(("key" . "value") ("key2" . "value2"))
   ;; :data "key=value&key2=value2"  ; this is equivalent
   :parser 'json-read
   :success (cl-function
   (lambda (&key data &allow-other-keys)
	       (message "I sent: %S" (assoc-default 'form data)))))
#+end_src

#+name: POST File Example
#+caption: POST FILE Example
#+begin_src elisp
  (request
   "http://httpbin.org/post"
   :type "POST"
   :files `(("current buffer" . ,(current-buffer))
	    ("data" . ("data.csv" :data "1,2,3\n4,5,6\n")))
   :parser 'json-read
   :success (cl-function
   (lambda (&key data &allow-other-keys)
	       (message "I sent: %S" (assoc-default 'files data)))))
#+end_src

#+name:Rich callback dispatch
#caption:Rich callback dispatch
#+begin_src elisp
  (request
   "http://httpbin.org/status/418"     ; try other codes, for example:
   ;; "http://httpbin.org/status/200"  ; success callback will be called.
   ;; "http://httpbin.org/status/400"  ; you will see "Got 400."
   :parser 'buffer-string
   :success
   (cl-function (lambda (&key data &allow-other-keys)
   (when data
		  (with-current-buffer (get-buffer-create "*request demo*")
		    (erase-buffer)
		    (insert data)
		    (pop-to-buffer (current-buffer))))))
   :error
   (cl-function (lambda (&key error-thrown &allow-other-keys&rest _)
   (message "Got error: %S" error-thrown)))
   :complete (lambda (&rest _) (message "Finished!"))
   :status-code '((400 . (lambda (&rest _) (message "Got 400.")))
		  (418 . (lambda (&rest _) (message "Got 418.")))))
#+end_src

#+name:Flexible PARSER option:
#+caption:Flexible PARSER option:
#+begin_src elisp
  (request
   "https://github.com/tkf/emacs-request/commits/master.atom"
   ;; Parse XML in response body:
   :parser (lambda () (libxml-parse-xml-region (point) (point-max)))
   :success (cl-function
   (lambda (&key data &allow-other-keys)
	       ;; Just don't look at this function....
	       (let ((get (lambda (node &rest names)
			    (if names
				(apply get
				       (first (xml-get-children
					       node (car names)))
				       (cdr names))
			      (first (xml-node-children node))))))
		 (message "Latest commit: %s (by %s)"
			  (funcall get data 'entry 'title)
			  (funcall get data 'entry 'author 'name))))))
#+end_src

#+name:PUT JSON data
#+caption:PUT JSON data
#+begin_src elisp
  (request
   "http://httpbin.org/put"
   :type "PUT"
   :data (json-encode '(("key" . "value") ("key2" . "value2")))
   :headers '(("Content-Type" . "application/json"))
   :parser 'json-read
   :success (cl-function
   (lambda (&key data &allow-other-keys)
	       (message "I sent: %S" (assoc-default 'json data)))))
#+end_src

#+name:PUT With Non-Ascii
#+caption:PUT JSON data including non-ascii strings
#+begin_src elisp
  (request
   "http://httpbin.org/put"
   :type "PUT"
   :data (json-encode '(("key" . "値1") ("key2" . "値2")))
   :headers '(("Content-Type" . "application/json"))
   :parser 'json-read
   :encoding 'utf-8
   :success (cl-function
	     (lambda (&key data &allow-other-keys)
	       (message "I sent: %S" (assoc-default 'json data)))))
#+end_src

#+name:Another PUT JSON example
#+caption:Another PUT JSON example (nested JSON using alist structure, how to represent a boolean & how to selectively evaluate lisp)
#+begin_src elisp
  ;; (1) Prepend alist structure with a backtick (`) rather than single quote (')
  ;;     to allow elisp evaluation of selected elements prefixed with a comma (,)
  ;; (2) This value is expected as a boolean so use the nil / t elisp alist denotation
  ;; (3) The function will be evaluated as it has been prefixed with a comma (,)
  (request
   "http://httpbin.org/put"
   :type "PUT"
   :data (json-encode `(("jsonArray" . (("item1" . "value 1") ;; (1)
					("item2" . t)         ;; (2)
					("item3" . ,(your-custom-elisp-function)))))) ;; (3)
   :headers '(("Content-Type" . "application/json"))
   :parser 'json-read
   :success (cl-function
	     (lambda (&key data &allow-other-keys)
	       (message "I sent: %S" (assoc-default 'json data)))))
#+end_src

#+name:GET with Unix domain socket data
#+caption:GET with Unix domain socket data
#+begin_src elisp
  (request
   "http:/hello.txt"
   :unix-socket "/tmp/app.sock"
   :parser (lambda () (buffer-string))
   :success (cl-function
	     (lambda (&key data &allow-other-keys)
	       (message "Got: %s" data))))
#+end_src

**** Configuration for ~request-el~

- *Variables*

  - request-storage-directory :: Directory to store data related to request.el.

    : request-storage-directory "~/.emacs.d/request"

  - request-curl :: Executable for curl command.

    : request-curl "curl"

  - request-backend :: Backend to be used for HTTP request. Automatically set
    to curl if curl command is found.

    : request-backend 'curl

  - request-timeout :: Default request timeout in second. nil means no timeout.

    : request-timeout nil

  - request-log-level :: Logging level for request. One of
    =error/warn/info/verbose/debug=.  -1 means no logging.

    : request-log-level '-1

  - request-message-level :: Logging level for request. See
    ~request-log-level~

    : request-message-level 'warn
* Additional Resources
:PROPERTIES:
:appendix: t
:END:
** WikEmacs

#+cindex:WikEmacs
- http://wikemacs.org/wiki/Main_Page

** Bastien’s Emacs Training
- https://github.com/bzg/emacs-training

** Mastering Emacs in One Year
- https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org
- http://blog.binchen.org
** How to Learn Emacs---A Hand-drawn One-pager for Beginners
- https://sachachua.com/blog/2013/05/how-to-learn-emacs-a-hand-drawn-one-pager-for-beginners/
- https://sachachua.com/blog/
** Emacs Rocks
- http://emacsrocks.com
** Planet Emacsen
- https://github.com/hober/planet.emacsen.org
- web site is currently /down/
- https://planet.emacslife.com (unofficial version)
** Awesome Emacs
- https://github.com/emacs-tw/awesome-emacs
** Using Emacs Series
- https://cestlaz.github.io/stories/emacs/
** Xah Emacs and Tutorial
- http://ergoemacs.org/index.html
- http://ergoemacs.org/emacs/emacs.html
** Emacs Mini Tutorial
- [[http://tuhdo.github.io/emacs-tutor.html][Emacs Mini Manual (PART 1) - THE BASICS]]
** r/emacs
- https://www.reddit.com/r/emacs
** Emacs StackExchange
- https://emacs.stackexchange.com
** Effective emacs
- https://a-nickels-worth.blogspot.com/2007/11/effective-emacs.html

* Equality
Equality can be tested between objects, or between the contents of objects
(using the data type of the object).
** Equality Between Objects
#+attr_texinfo: :options eq object1 object2
#+begin_defun
Tests for object equality, not content equality.  Two distinct objects that
contain the same content are not ~eq~.

- OBJECT1 :: an object; fixnums (small integers) with the same value are ~eq~.
  Symbols with the same name are ~eq~.

- OBJECT2 :: an object;

- RETURN VALUE :: =t= if OBJECT1 and OBJECT2 are the same object; =nil=
  otherwise.
#+end_defun

* Variables
** Examining Variables

- describe-variable (=C-h v=) :: Display the value and documentation of variable
  VAR

- set-variable :: Change the value of variable VAR to VALUE.  Limited to user
  options (customizable variables)

- setq :: Set the value of any variable

- eval-expression (=M-:=, =C-j=) :: To execute such an expression, type ‘M-:’
  (‘eval-expression’) and enter the expression in the minibuffer (*note Lisp
  Eval::).  Alternatively, go to the ‘*scratch*’ buffer, type in the
  expression, and then type ‘C-j’


The only way to alter the variable in future sessions is to put something in
your initialization file.

** Directory Variables

** Local Variables
#+cindex:local variables
#+cindex:buffer-local variables
#+cindex:per-buffer variables
Almost any variable can be made “local” to a specific Emacs buffer.  This means
that its value in that buffer is independent of its value in other buffers.  A
few variables are always local in every buffer.  Every other Emacs variable has
a “global” value which is in effect in all buffers that have not made the
variable local.  A few variables cannot be local to a buffer because they are
always local to each display instead.

#+findex:make-local-variable
- make-local-variable :: reads the name of a variable and makes it local to the
  current buffer.
  #+findex:make-variable-buffer-local
- make-variable-buffer-local :: marks a variable so it will become local
  automatically whenever it is set.  once a variable has been marked in this
  way, the usual ways of setting the variable automatically do
  ‘make-local-variable’ first.  We call such variables “per-buffer” variables.
  The per-buffer’s global value is the initial value of the variable for each
  new buffer.
  #+findex:kill-local-variable
- kill-local-variable :: makes a specified variable cease to be local to the
  current buffer.  The global value of the variable henceforth is in effect in
  this buffer.
  #+findex:setq-default
- setq-default :: set the global value of a variable, regardless of whether the
  variable has a local value in the current buffer.  This is is the only way to
  set the global value of a variable that has been marked with
  ‘make-variable-buffer-local’.
  #+findex:default-value
- default-value :: This function takes a symbol as argument and returns its
  default value.  The argument is evaluated; usually you must quote it
  explicitly.

*** Local Variables in Files
A file can specify local variable values to use when editing the file with
Emacs.  Visiting the file or setting a major mode checks for local variable
specifications; it automatically makes these variables local to the buffer, and
sets them to the values specified in the file.

There are two ways to specify file local variable values:

1. in the first or second line

   : -*- mode: MODENAME; VAR: VALUE; ... -*-

   You can specify any number of variable/value pairs in this way, each pair
   with a colon and semicolon.  The VALUEs are used literally, and not
   evaluated.

   You can use ‘M-x add-file-local-variable-prop-line’ instead of adding
   entries by hand.  This command prompts for a variable and value, and adds
   them to the first line in the appropriate way.

   ‘M-x delete-file-local-variable-prop-line’ prompts for a variable, and
   deletes its entry from the line.

   The command ‘M-x copy-dir-locals-to-file-locals-prop-line’ copies the
   current directory-local variables to the first line.

   Keywords that have special meanings as file variables (including the local
   variables list) are:

   - mode :: enables the specified major mode
   - coding :: specifies the coding system for character code conversion
   - unibyte :: load or compile a file of Emacs Lisp in unibyte mode if value
     is t
   - eval :: evaluate the specified Lisp expression (the value returned is
     ignored)

2. with a local variables list.

   : Local Variables:
   : <variable>: <value>
   : End:

    Instead of typing in the local variables list directly, you can use the
   command ‘M-x add-file-local-variable’.  The command ‘M-x
   delete-file-local-variable’ deletes a variable from the list.  ‘M-x
   copy-dir-locals-to-file-locals’ copies directory-local variables to the
   list.


#+texinfo:@heading Setting Minor Modes
#+cindex:minor mode, setting
To enable or disable a minor mode in a local variables list, use the ‘eval’
keyword with a Lisp expression that runs the mode command.

#+texinfo:@heading Processing Local Variables

#+vindex:enable-local-variables
The variable ‘enable-local-variables’ allows you to change the way Emacs
processes local variables.  Its default value is ‘t’, which specifies the
behavior described above.  If it is ‘nil’, Emacs simply ignores all file local
variables.  ‘:safe’ means use only the safe values and ignore the rest.  Any
other value says to query you about each file that has local variables, without
trying to determine whether the values are known to be safe.

#+vindex:enable-local-eval
The variable ‘enable-local-eval’ controls whether Emacs processes ‘eval’
variables.  The three possibilities for the variable’s value are ‘t’, ‘nil’,
and anything else, just as for ‘enable-local-variables’.  The default is
‘maybe’, which is neither ‘t’ nor ‘nil’, so normally Emacs does ask for
confirmation about processing ‘eval’ variables.

#+vindex:save-local-eval-forms
As an exception, Emacs never asks for confirmation to evaluate any
‘eval’ form if that form occurs within the variable
‘safe-local-eval-forms’.
* Lisp Data Types and Structures
#+cindex:data type
#+cindex:atom
#+cindex:object
#+cindex:primitive data type

- primitive built-in data types :: a few fundamental object types are built
  into Emacs. From these primitives every other type is constructed.

  - integer

  - float

  - cons

  - symbol

  - string

  - vector

  - hash-table

  - subr

  - byte-code function

  - record

  - special types---see [[info:elisp#Editing Types][Editing Types]]

- data type :: a set of possible objects.  Types can overlap, and objects can
  belong to two or more types.  Thus, one cannot ask for /the/ type of an
  object, but rather whether an object belongs to /a/ type or not.  Type
  declarations do not exist in Emacs Lisp.  A Lisp variable can have any type
  of value, and it remembers whatever value you store in it, type and all.  But
  see [[info:elisp#Variables with Restricted Values][Restricted Values]].

    #+cindex:object
- object :: piece of data in a Lisp program. Every object belongs to one
  /primitive type/. Lisp objects are “self-typing”, that is, the primitive type
  of each object is implicit in the object itself. Lisp “knows” what kind of
  object an object is and will not let the programmer treat it as something
  else.

  #+cindex:attom
- atom :: an atom is any object except a cons cell.

  #+cindex:cons cell
- cons cell :: a cons cell is an object that consists of two slots, called the
  CAR slot and the CDR slot. Each slot can “hold” any Lisp object. We also say
  that the CAR of this cons cell is whatever object its CAR slot currently
  holds, and likewise for the CDR.

  #+cindex:list
- list :: a list is a series of cons cells, linked together so that the CDR
  slot of each cons cell holds either the next cons cell or the empty list. The
  empty list is actually the symbol ‘nil’. Because most cons cells are used as
  part of lists, we refer to any structure made out of cons cells as a “list
  structure”. A Lisp list thus works as a “linked list” built up of cons cells

- predicate data-type functions :: Each primitive type has a corresponding Lisp
  function that checks whether an object is a member of that type.

** Printed Representation
#+cindex:printed representation
#+cindex:read syntax
#+cindex:Lisp printer
#+cindex:printer, Lisp
#+findex:prin1
#+cindex:hash notation
#+findex:read
#+cindex:expression
#+cindex:evaluation
#+cindex:input functions
- printed representation ::
  The /printed representation/ of an object is the format of the output
  generated by the Lisp printer, ~prin1~, for that object.  Every data type has
  a unique printed representation.

- read syntax :: The “read syntax” of an object is the format of the input
  accepted by the Lisp reader (the function ~read~) for that object.  In most
  cases, an object’s printed representation is also a read syntax for the
  object, but some types have no read syntax.  See [[info:elisp#Special Read Syntax][Special Read Syntax]].

- hash notation :: Objects without read syntax are printed in “hash notation”,
  =#<type-name object-name>=.  Hash notation cannot be read at all.  The Lisp
  reader will signal an ‘invalid-read-syntax’ error whenever it encounters
  =#<=.

- expression :: In Lisp, an /expression/ is primarily a Lisp object and only
  secondarily the /text/ that is the object’s read syntax.

- evaluation  ::  When one  evaluates  an  expression interactively,  the  Lisp
  interpreter first /reads/ the textual  representation of it, producing a Lisp
  object, and  then /evaluates/ that  object.  See [[info:elisp#Evaluation][Evaluation]].   Evaluation and
  reading are separate activities.  Reading returns the Lisp object represented
  by the text that is read; the object may or may not be evaluated later.

  See [[info:elisp#Input
   Functions][Input Functions]] for a description of ~read~, the basic function for reading
  objects.

** Comments
#+cindex:comment
In Lisp, an unescaped semicolon (=;=) starts a comment if it is not within a
string or character constant.  The Lisp reader discards comments; they do not
become part of the Lisp objects which represent the program within the Lisp
system.

*** Comment Conventions
- =;= ::

  Comments that start with a single semicolon, =;=, should all be aligned to
  the same column on the right of the source code.  Such comments usually
  explain how the code on that line does its job.

- =;;= ::

  Comments that start with two semicolons, ==;;==, should be aligned to the
  same level of indentation as the code.  Such comments usually describe the
  purpose of the following lines or the state of the program at that point.

  We also normally use two semicolons for comments outside functions.

  If a function has no documentation string, it should instead have a
  two-semicolon comment right before the function, explaining what the function
  does and how to call it properly.  Explain precisely what each argument means
  and how the function interprets its possible values.  It is much better to
  convert such comments to documentation strings, though.

- =;;;= ::

  Comments that start with three semicolons, =;;;=, should start at the left
  margin.  We use them for comments which should be considered a heading by
  Outline minor mode.  By default, comments starting with at least three
  semicolons (followed by a single space and a non-whitespace character) are
  considered headings, while comments starting with two or fewer are not.
  Historically, triple-semicolon comments have also been used for commenting
  out lines within a function, but this use is discouraged.  When commenting
  out entire functions, use two semicolons.

- =;;;;= ::

  Comments that start with four semicolons, =;;;;=, should be aligned to the
  left margin and are used for headings of major sections of a program.

*** Some Comment Functions
Because comments are such an important part of programming, Emacs provides
special commands for editing and inserting comments.  It can also do spell
checking on comments with Flyspell Prog mode (*note Spelling::).

- ~comment-dwim~ (=M-;=) ::

  Insert or realign comment on current line.  If the region is active, comment
  or uncomment the region instead.  In this case, supplying a positive ARG adds
  that many comment characters, or if negative, removes that many.

  #+attr_texinfo: :options comment-dwim arg
  #+begin_defun
  Call the comment command you want (“Do What I Mean”).

  If the region is active and ‘transient-mark-mode’ is on, call
  [[comment-region][~comment-region~]] (unless it only consists of comments, in which case it calls
  [[uncomment-region][~uncomment-region~]]).

  Else, if the current line is empty, call [[comment-insert-comment-function][~comment-insert-comment-function~]] if
  it is defined, otherwise insert a comment and indent it.  If the line is
  blank, the comment is indented to the same position where <TAB> would indent
  to; if the line is non-blank, the comment is placed after the last
  non-whitespace character on the line, somewhere between [[comment-column][~comment-column~]] and
  [[comment-fill-column][~comment-fill-column~]] if possible.  Point is placed after the comment
  character.

  - ARG (=C-u M-;=) :: Else if a prefix ARG is specified, call [[comment-kill][~comment-kill~]].
    The comment is saved to the kill ring, and you can reinsert it on another
    line by moving the end of that line, doing =C-y=, and then =M-;= to realin
    the comment.

  Else, call [[comment-indent][~comment-indent~]].  If a line already contains the [[comment-start][~comment-start~]]
  string, this command realigns it to the conventional alignment and moves
  point after.  Comments starting in column 0 are not moved.
  #+end_defun


If you are typing a comment and wish to continue it to another line, type =M-j=
or =C-M-j= ([[comment-indent-new-line][~comment-indent-new-line~]]).  This breaks the current line, and
inserts the necessary comment delimiters and indentation to continue the
comment.

- ~comment-line~ (=C-x C-;=) ::
  <<comment-line>>

  Comments or uncomments complete lines.

  #+attr_texinfo: :options comment-line N
  #+begin_defun
  Comment or uncomment current line and leave point after it.  If region is
  active, comment lines in active region instead.  Unlike ‘comment-dwim’, this
  always comments whole lines.

  - N :: With positive prefix, apply to N lines including current one.  With
    negative prefix, apply to -N lines above.  Also, further consecutive
    invocations of this command will inherit the negative argument.
  #+end_defun

- ~comment-region~ (=C-c C-c=) ::
  <<comment-region>>

  Add comment delimiters to all the lines in the region, even if the region is
  inactive.

  Use =C-c C-c= in C-like languages.

  #+attr_texinfo: :options comment-region begin end &optional arg
  #+begin_defun
  Comment or uncomment each line in the region.

  With just =C-u prefix arg=, uncomment each line in region BEG .. END.

  - ARG :: Numeric prefix ARG means use ARG comment characters.  If ARG is
    negative, delete that many comment characters instead.


  The strings used as comment starts are built from [[comment-start][~comment-start~]] and
  ~comment-padding~; the strings used as comment ends are built from
  ~comment-end~ and ~comment-padding~.
  #+end_defun

  For C-like modes, you can configure the exact effect of =M-;= by setting the
  variables [[c-indent-comment-alist][~c-indent-comment-alist~]] and [[c-indent-comments-syntactically-p][~c-indent-comments-syntactically-p~]].

- ~uncomment-region~ ::
  <<uncomment-region>>

  #+attr_texinfo: :options uncomment-region begin end &optional arg
  #+begin_defun
  Uncomment each line in the BEGIN .. END region.

  - ARG :: The numeric prefix ARG can specify a number of chars to remove from
    the comment delimiters.
  #+end_defun

- ~comment-indent-new-line~ (=C-M-j=, =M-j=) ::
  <<comment-indent-new-line>>

  If you are typing a comment and wish to continue it to another line, type
  ‘M-j’ or ‘C-M-j’ (‘comment-indent-new-line’).  This breaks the current line,
  and inserts the necessary comment delimiters and indentation to continue the
  comment.

  Like ‘<RET>’ followed by inserting and aligning a comment.

  This command is intended for styles where you write a comment per line,
  starting a new comment (and terminating it if necessary) on each line.  If
  you want to continue one comment across several lines, use M-x
  newline-and-indent.

  #+attr_texinfo: :options comment-indent-new-line &optional soft
  #+begin_defun
  Break line at point and indent, continuing comment if within one. This
  indents the body of the continued comment under the previous comment line.

  - SOFT :: The inserted newline is marked hard if variable ‘use-hard-newlines’
    is true, unless optional argument SOFT is non-nil.
  #+end_defun

- ~comment-insert-comment-function~ (a variable) ::
  <<comment-insert-comment-function>>

  #+attr_texinfo: :options comment-insert-comment-function
  #+begin_defvar
  Function to insert a comment when a line doesn’t contain one.
  #+end_defvar

- ~comment-kill~ ::
  <<comment-kill>>

  #+attr_texinfo: :options comment-kill arg
  #+begin_defun
  Kill the first comment on this line, if any.

  - ARG :: With prefix ARG, kill comments on that many lines starting with this
    one.
  #+end_defun

- ~comment-indent~ ::
  <<comment-indent>>

  #+attr_texinfo: :options comment-indent &optional continue
  #+begin_defun
  Indent this line’s comment to ‘comment-column’, or insert an empty comment.

  - CONTINUE :: if non-nil, use the ‘comment-continue’ markers if any.
  #+end_defun

- ~comment-set-column~ (=C-x ;=) ::

  #+attr_texinfo: :options comment-set-column arg
  #+begin_defun
  Set the comment column based on point.  With no ARG, set the comment column
  to the current column.

  - ARG :: With just minus as arg, kill any comment on this line.

    With any other ARG, set comment column to indentation of the previous
    comment and then align or create a comment on this line at that column.
  #+end_defun

- ~comment-column~ (a variable) ::
  <<comment-column>>

  #+attr_texinfo: :options comment-column
  #+begin_defvar
  Column to indent right-margin comments to.  Each mode may establish a
  different default value for this variable; you can set the value for a
  particular mode using that mode’s hook.
  #+end_defvar

- ~comment-continue~ (a variable) ::

  #+attr_texinfo: :options comment-continue
  #+begin_defvar
  Continuation string to insert for multiline comments.  This string will be
  added at the beginning of each line except the very first one when commenting
  a region with a commenting style that allows comments to span several lines.
  It should generally have the same length as [[comment-start][~comment-start~]] in order to
  preserve indentation.
  #+end_defvar

- ~comment-start~ (a variable) ::
  <<comment-start>>

  #+attr_texinfo: :options comment-start
  #+begin_defvar
  String to insert to start a new comment, or nil if no comment syntax.
  #+end_defvar

- ~comment-fill-column~ (a variable) ::
  <<comment-fill-column>>

  #+attr_texinfo: :options comment-fill-column
  #+begin_defvar
  Column to use for ‘comment-indent’.  If nil, use ‘fill-column’ instead.
  #+end_defvar

- ~comment-style~ (a variable) ::

  Its value is =indent=.

  #+attr_texinfo: :options comment-style
  #+begin_defvar
  Style to be used for ‘comment-region’.
  #+end_defvar

- ~comment-styles~ (a variable) ::

  #+attr_texinfo: :options comment-styles
  #+begin_defvar
  Comment region style definitions.

  - =plain=
  - =indent-or-triple=
  - =indent=
  - =aligned=
  - =box=
  - =extra-line=
  - =multi-line=
  - =box-multi=
  #+end_defvar

- ~c-indent-comment-alist~ (a variable) ::
  <<c-indent-comment-alist>>

- ~c-indent-comments-syntactically-p~ (a variable) :: 
  <<c-indent-comments-syntactically-p>>

*** Multi-Line Comments


*** Lists in Elisp
:PROPERTIES:
:appendix: t
:END:

**** Lists and Cons Cells

#+cindex:cons cell
#+cindex:CAR, CDR

#+texinfo:@heading Proper Lists---CDR is a List

#+cindex:proper list
#+cindex:nil
Also by convention, the CDR of the last cons cell in a list is ‘nil’.  We call
such a ‘nil’-terminated structure a “proper list”.  In Emacs Lisp, the symbol
‘nil’ is both a symbol and a list with no elements.  For convenience, the
symbol ‘nil’ is considered to have ‘nil’ as its CDR (and also as its CAR).

Hence, the CDR of a proper list is always a proper list.  The CDR of a nonempty
proper list is a proper list containing all the elements except the first.

#+texinfo:@heading Dotted Lists

#+cindex:dotted list
If the CDR of a list’s last cons cell is some value other than ‘nil’, we call
the structure a “dotted list”, since its printed representation would use
dotted pair notation

#+texinfo:@heading List Structure

#+cindex:list structure
Because most cons cells are used as part of lists, we refer to any structure
made out of cons cells as a “list structure”.

#+texinfo:@heading Read Syntax and Printed Representation

#+cindex:read syntax, list
#+cindex:printed representation, list
The read syntax and printed representation for lists are identical, and consist
of a left parenthesis, an arbitrary number of elements, and a right
parenthesis.

: (a b c)
: () or nil
: ((a b c) (d e f))

Upon reading, each object inside the parentheses becomes an element of the
list.  That is, a cons cell is made for each element.  The CAR slot of the cons
cell holds the element, and its CDR slot refers to the next cons cell of the
list, which holds the next element in the list.  The CDR slot of the last cons
cell is set to hold ‘nil’.

#+texinfo:@heading Dotted Pair Notation

#+cindex:dotted pair notation
/Dotted pair notation/ is a general syntax for cons cells that represents the
CAR and CDR explicitly.

In this syntax, =(A . B)= stands for a cons cell whose CAR is the object A and
whose CDR is the object B.  In dotted pair notation, the list =(1 2 3)= is
written as (=1 . (2 . (3 . nil)))=.

Dotted pair notation is more general than list syntax because the CDR does not
have to be a list.  However, it is more cumbersome in cases where list syntax
would work.  For ‘nil’-terminated lists, you can use either notation, but list
notation is usually clearer and more convenient.  When printing a list, the
dotted pair notation is only used if the CDR of a cons cell is not a list.

You can combine dotted pair notation with list notation to represent
conveniently a chain of cons cells with a non-‘nil’ final CDR.  You write a dot
after the last element of the list, followed by the CDR of the final cons cell.
For example, =(rose violet . buttercup)= is equivalent to =(rose . (violet
. buttercup))=.  The list =(rose violet)= is equivalent to =(rose . (violet))=.
Similarly, the three-element list =(rose violet buttercup)= is equivalent to
=(rose . (violet . (buttercup)))=.
**** Association Lists

#+cindex:association list
#+cindex:stack
An /association list/ or /alist/ is a specially-constructed list whose elements
are cons cells.  In each element, the CAR is considered a “key”, and the CDR is
considered an “associated value”.  Association lists are often used as stacks,
since it is easy to add or remove associations at the front of the list.

#+begin_src emacs-lisp :eval no
  (setq alist-of-colors
        '((rose . red) (lily . white) (buttercup . yellow)))
#+end_src

Above, ~alist-of-colors~ is an alist of three elements.  In each element, the
first object is the key, and the second is the value.
**** List Variables
**** Modifying Lists
**** Sets
**** Association Lists
**** Property Lists


*** Arrays in Elisp

An /array/ object has slots that hold a number of other Lisp objects, called
the elements of the array.  Any element of an array may be accessed in constant
time.  When you create an array, other than a char-table, you must specify its
length.  You cannot specify the length of a char-table, because that is
determined by the range of character codes.

#+cindex:array types
Emacs defines four types of array, all one-dimensional:

- “strings” (*note String Type::)
- “vectors” (*note Vector Type::)
- “bool-vectors” (*note Bool-Vector Type::)
- “char-tables” (*note Char-Table Type::)


#+cindex:vector
#+cindex:char-table
#+cindex:bool-vector
Vectors and char-tables can hold elements of any type, but strings can only
hold characters, and bool-vectors can only hold ‘t’ and ‘nil’.

#+texinfo:@heading Shared Characteristics

#+cindex:characteristics, array
All four kinds of array share these characteristics:

   - The first element of an array has index zero, the second element has index
     1, and so on.  This is called “zero-origin” indexing.  For example, an
     array of four elements has indices 0, 1, 2, and 3.

   - The length of the array is fixed once you create it; you cannot change the
     length of an existing array.

   - For purposes of evaluation, the array is a constant---i.e., it evaluates
     to itself.

   - The elements of an array may be referenced or changed with the functions
     ‘aref’ and ‘aset’, respectively (*note Array Functions::).


#+texinfo:@heading Text Characters

In principle, if you want an array of text characters, you could use either a
string or a vector.  In practice, we always choose strings for such
applications, for four reasons:

   - They occupy one-fourth the space of a vector of the same elements.

   - Strings are printed in a way that shows the contents more clearly as text.

   - Strings can hold text properties.  *Note Text Properties::.

   - Many of the specialized editing and I/O facilities of Emacs accept only
     strings.  For example, you cannot insert a vector of characters into a
     buffer the way you can insert a string.  *Note Strings and Characters::.


By contrast, for an array of keyboard input characters (such as a key
sequence), a vector may be necessary, because many keyboard input characters
are outside the range that will fit in a string.

**** Functions that Operate on Arrays

* The Sequence Data Type

** Cons Cells
*** Cons Cells in General

A /cons cell/ is a primitive data object that represents an ordered pair. That
is, it has two slots, and each slot “holds”, or “refers to”, some Lisp object.
One slot is known as the CAR, and the other is known as the CDR.
*** Cons Cell Functions

**** Cons Cell Constructors

**** Non-Destructive Cons Cell Functions

**** Destructive Cons Cell Functions

** Sequences
*** In General

#+cindex:sequence data type
#+texinfo: @subheading A Sequence is an Ordered Set of Elements

A “sequence” is a Lisp object that represents an ordered set of elements and is
the union of two other Lisp types:

- lists and
- arrays

The common property that all sequences have is that each is /an ordered
collection of elements/.

Sequence types share important similarities:

- all have a length L, and
- all have elements which can be indexed from zero to L minus one

*** Sequence Functions
**** Sequence Constructors
**** Non-Destructive Sequence Functions
**** Destructive Sequence Functions
*** Lists
**** In General

#+texinfo: @subheading A List is a Sequence of Cons Cells

#+cindex:list data type
A /list/ is a combination or sequence of zero or more elements called cons
cells (a primitive object). A list can hold elements of any type, and its
length can be easily changed by adding or removing elements.

Finding the Nth element requires looking through N cons cells, so elements
farther from the beginning of the list take longer to access. But it is easy to
add elements to the list, and remove elements.

Two important differences between lists and vectors is that:

- two or more lists can share part of their structure;
- you can insert or delete elements in a list without copying the whole list.


#+texinfo: @subheading Lists are Constructed from Cons Cells

#+cindex:cons cells
#+cindex:CAR slot
#+cindex:CDR slot
Lists are built up from /cons cells/. A “list” is a series of cons cells,
linked together so that the CDR slot of each cons cell holds either the next
cons cell or the empty list. The empty list is actually the symbol ‘nil’. There
is one cons cell for each element of the list.

By convention, the CARs of the cons cells hold the elements of the list, and
the CDRs are used to chain the list (this asymmetry between CAR and CDR is
entirely a matter of convention; at the level of cons cells, the CAR and CDR
slots have similar properties). Hence, the CDR slot of each cons cell in a list
refers to the following cons cell.

**** Association Lists---alist

#+cindex:association list
#+cindex:alist
#+cindex:stack
An association list is a list in which the CAR of a cons cell is considered to
be a "key" and the CDR is considered to be an "associated value." In some
cases, the associated value is stored in the CAR of the CDR. Association lists
are often used as stacks, since it is easy to add or remove associations at the
front of the list.

**** List Constructors

**** Non-Destructive List Functions

**** Destructive List Functions

*** Arrays
**** Arrays in General

#+cindex:array data type
An /array/ is a fixed-length sequence of objects with one slot for each
element. All elements are accessible in constant time. They are further
subdivided into

- strings,
- vectors,
- char-tables and
- bool-vectors.

**** Vectors

Vectors can hold elements of any type.
**** Strings

String elements must be characters.
** Sequence Functions
*** Building Cons Cells and Lists

Lists reside at the very heart of Lisp. ‘cons’ is the fundamental list-building
function.

#+findex:cons
#+attr_texinfo: :options cons object1 object2
#+begin_defun
This function is the most basic function for building new list structure. It
creates a new cons cell, making OBJECT1 the CAR, and OBJECT2 the CDR. It then
returns the new cons cell.

The arguments OBJECT1 and OBJECT2 may be any Lisp objects, but most often
OBJECT2 is a list.

‘cons’ is often used to add a single element to the front of a list. This is
called “consing the element onto the list”.
#+end_defun

#+findex:list
#+attr_texinfo: :options list &rest objects
#+begin_defun
This function creates a list with OBJECTS as its elements (or ‘nil’ if no
objects are given). The resulting list is always ‘nil’-terminated.
#+end_defun

#+findex:make-list
#+attr_texinfo: :options make-list length object
#+begin_defun
This function creates a list of LENGTH elements, in which each element is
OBJECT.
#+end_defun

#+findex:append
#+attr_texinfo: :options append &rest sequences
#+begin_defun
This function returns a list containing all the elements of SEQUENCES. The
SEQUENCES may be lists, vectors, bool-vectors, or strings, but the last one
should usually be a list. All arguments except the last one are copied, so none
of the arguments is altered.

The final argument to ‘append’ may be any Lisp object. The final argument is
not copied or converted; it becomes the CDR of the last cons cell in the new
list.

See ‘nconc’ in *note Rearrangement::, for a way to join lists with no copying.

An empty sequence contributes nothing to the value returned by ‘append’. As a
consequence of this, a final ‘nil’ argument forces a copy of the previous
argument. This once was the usual way to copy a list, before the function
‘copy-sequence’ was invented.

With the help of ‘apply’, we can append all the lists in a list of lists:

: (apply 'append '((a b c) nil (x y z) nil))
: ⇒ (a b c x y z)
#+end_defun

#+findex:copy-tree
#+attr_texinfo: :options copy-tree &optional vecp
#+begin_defun
This function returns a copy of the tree TREE. If TREE is a cons cell, this
makes a new cons cell with the same CAR and CDR, then recursively copies the
CAR and CDR in the same way.

if VECP is non-‘nil’, it copies vectors too (and operates recursively on their
elements.
#+end_defun

#+findex:flatten-tree
#+attr_texinfo: :options flatten-tree tree
#+begin_defun
This function returns a “flattened” copy of TREE, that is, a list containing
all the non-‘nil’ terminal nodes, or leaves, of the tree of cons cells rooted
at TREE.
#+end_defun

#+findex:number-sequence
#+attr_texinfo: :options number-sequence from &optional to separation
#+begin_defun
This function returns a list of numbers starting with FROM and incrementing by
SEPARATION, and ending at or just before TO. SEPARATION can be positive or
negative and defaults to 1.

All arguments are numbers. Floating-point arguments can be tricky.

The Nth element of the list is computed by the exact formula ‘(+ FROM (* N
SEPARATION))’. Thus, if one wants to make sure that TO is included in the list,
one can pass an expression of this exact type for TO.
#+end_defun

*** Sequence Predicate Functions

The following predicates test whether a Lisp object is an atom, whether it is a
cons cell or is a list, or whether it is the distinguished object ‘nil’. (Many
of these predicates can be defined in terms of the others, but they are used so
often that it is worth having them.)

#+texinfo: @subheading Object Predicates

#+findex:null
#+findex:not
#+attr_texinfo: :options null object
#+begin_defun
This function returns ‘t’ if OBJECT is ‘nil’, and returns ‘nil’ otherwise.

#+texinfo: @subheading NULL and NOT

This function is identical to ‘not’, but as a matter of clarity we use ‘null’
when OBJECT is considered a list and ‘not’ when it is considered a truth value
#+end_defun

#+findex:atom
#+attr_texinfo: :options atom object
#+begin_defun
This function returns ‘t’ if OBJECT is an atom, ‘nil’ otherwise. All objects
except cons cells are atoms.

#+texinfo: @subheading NIL

The symbol ‘nil’ is an atom and is also a list; it is the only Lisp object that
is both.
#+end_defun

#+findex:consp
#+attr_texinfo: :options consp object
#+begin_defun
This function returns ‘t’ if OBJECT is a cons cell, ‘nil’ otherwise.

#+texinfo: @subheading NIL

‘nil’ is not a cons cell, although it _is_ a list.
#+end_defun

#+texinfo: @subheading List Predicates

#+findex:listp
#+attr_texinfo: :options listp object
#+begin_defun
This function returns ‘t’ if OBJECT is a cons cell or ‘nil’. Otherwise, it
returns ‘nil’.
#+end_defun

#+findex:nlistp
#+attr_texinfo: :options nlistp object
#+begin_defun
This function is the opposite of ‘listp’: it returns ‘t’ if OBJECT is not a
list. Otherwise, it returns ‘nil’.
#+end_defun

#+findex:proper-list-p
#+attr_texinfo: :options proper-list-p object
#+begin_defun
This function returns the length of OBJECT if it is a proper list, ‘nil’
otherwise. In addition to satisfying ‘listp’, a proper list is neither circular
nor dotted.
#+end_defun

#+texinfo: @subheading Sequence Predicates

#+findex: sequencep
#+attr_texinfo: :options sequencep object
#+begin_defun
Predicate function to determine if OBJECT is a _sequence_ type:
- list
- vector
- string
- bool-vector
- char-table

See also =seqp=.
#+end_defun

#+texinfo: @subheading Array Predicates

#+attr_texinfo: :options arrayp object
#+begin_defun
This function returns ‘t’ if OBJECT is an array (i.e., a vector, a
string, a bool-vector or a char-table).
#+end_defun

*** Basic Sequence Functions

#+findex:length
#+attr_texinfo: :options length sequence
#+begin_defun
This function returns the number of elements in SEQUENCE.

*Note Definition of safe-length::, for the related function =safe-length=.

See also =string-bytes=, in *note Text Representations.
#+end_defun

#+findex:safe-length list
#+attr_texinfo: :options safe-length list
#+begin_defun
This function returns the length of LIST, with no risk of either an error or an
infinite loop. If LIST is not ‘nil’ or a cons cell, ‘safe-length’ returns 0.
#+end_defun

#+findex:copy-sequence
#+attr_texinfo: :options copy-sequence seqr
#+begin_defun
This function returns a copy of SEQR, which should be either a sequence or a
record. The copy is the same type of object as the original, and it has the
same elements in the same order.

The elements of the copy are not copies; they are identical (‘eq’) to the
elements of the original. Changes made within these elements, as found via the
copy, are also visible in the original.

If the argument is a string with text properties, the property list in the copy
is itself a copy, not shared with the original’s property list. However, the
actual values of the properties are shared

This function does not work for dotted lists.

See also ‘append’ in *note Building Lists::, ‘concat’ in *note Creating
Strings::, and ‘vconcat’ in *note Vector Functions::, for other ways to copy
sequences.
#+end_defun

#+findex:reverse
#+attr_texinfo: :options reverse sequence
#+begin_defun
This function creates a new sequence whose elements are the elements of
SEQUENCE, but in reverse order. The original argument SEQUENCE is _not_
altered.
#+end_defun

#+findex:nreverse
#+attr_texinfo: :options nreverse sequence
#+begin_defun
This function reverses the order of the elements of SEQUENCE. Unlike ‘reverse’
the original SEQUENCE may be modified. To avoid confusion, we usually store the
result of ‘nreverse’ back in the same variable which held the original list:

: (setq x (nreverse x))

For the vector, it is even simpler because you don’t need setq:

: (setq x (copy-sequence [1 2 3 4]))
: (nreverse x)

Note that unlike ‘reverse’, this function doesn’t work with strings. Although
you can alter string data by using ‘aset’, it is strongly encouraged to treat
strings as immutable even when they are mutable.
#+end_defun

#+findex:sort
#+cindex:stable sort
#+cindex:sort, stable
#+cindex:antisymmetric sort
#+cindex:transitive sort
#+attr_texinfo: :options sort sequence predicate
#+begin_defun
This function sorts SEQUENCE stably; it may be used only for lists and vectors.
If SEQUENCE is a list, it is modified destructively. It compares elements using
PREDICATE. A stable sort is one in which elements with equal sort keys maintain
their relative order before and after the sort. Stability is important when
successive sorts are used to order elements according to different criteria.

Save the result of ‘sort’ and use that. Most often we store the result back
into the variable that held the original list:

: (setq nums (sort nums #'<))

#+texinfo: @subheading PREDICATE FUNCTION
The argument PREDICATE must be a function that accepts two arguments. It is
called with two elements of SEQUENCE. To get an increasing order sort, the
PREDICATE should return non-‘nil’ if the first element is “less” than the
second, or ‘nil’ if not.

The comparison function PREDICATE must give reliable results for any given pair
of arguments, at least within a single call to ‘sort’. It must be
“antisymmetric”; that is, if A is less than B, B must not be less than A. It
must be “transitive”—that is, if A is less than B, and B is less than C, then A
must be less than C. If you use a comparison function which does not meet these
requirements, the result of ‘sort’ is unpredictable.

#+texinfo: @subheading DESTRUCTIVE SORT
The destructive aspect of ‘sort’ for lists is that it rearranges the cons cells
forming SEQUENCE by changing CDRs. A nondestructive sort function would create
new cons cells to store the elements in their sorted order. If you wish to make
a sorted copy without destroying the original, copy it first with
‘copy-sequence’ and then sort.

*Note Sorting, for more functions that perform sorting. See ‘documentation’ in
*note Accessing Documentation::, for a useful example of ‘sort’.
#+end_defun

*** Accessing Sequence Elements

#+texinfo: @subheading Cons Elements Using `car’ and `cdr’

#+findex:car
#+attr_texinfo: :options car cons-cell
#+begin_defun
This function returns the value referred to by the first slot of the cons cell
CONS-CELL, e.g., the CAR of the CONS-CELL. If the CONS-CELL is ‘nil’, it
returns ‘nil’. An error is signaled if the argument is not a cons cell or
‘nil’.
#+end_defun

#+findex:car-safe
#+attr_texinfo: :options car-safe object
#+begin_defun
This function lets you take the CAR of a cons cell while avoiding errors for
other data types. It returns the CAR of OBJECT if OBJECT is a cons cell, ‘nil’
otherwise. It does not signal an error if OBJECT is not a list or ‘nil’.
#+end_defun

#+findex:cdr
#+attr_texinfo: :options cdr cons-cell
#+begin_defun
This function returns the value referred to by the second slot of the cons cell
CONS-CELL, e.g., the CDR of the CONS-CELL. If the CONS-CELL is ‘nil’, it
returns ‘nil’. An error is signaled if the argument is not a cons cell or
‘nil’.
#+end_defun

#+findex:cdr-safe
#+attr_texinfo: :options cdr-safe object
#+begin_defun
This function lets you take the CDR of a cons cell while avoiding errors for
other data types. It returns the CDR of OBJECT if OBJECT is a cons cell, ‘nil’
otherwise. It does not signal an error if OBJECT is not a list or ‘nil’.
#+end_defun

#+texinfo: @subheading Sequence Elements

#+findex:elt
#+attr_texinfo: :options elt sequence index
#+begin_defun
This function returns the element of SEQUENCE indexed by INDEX (starting from
zero). Whereas the function ~nth~ applies only to lists and ~aref~ applies to
arrays, this function applies to any kind of sequence. (Note that ~nth~ takes
its arguments in opposite order).

Legitimate values of INDEX are integers ranging from 0 up to one less than the
length of SEQUENCE. If SEQUENCE is a list and the INDEX is out of range, NIL is
returned.  Otherwise, an =args-out-of-range= error is returned.

This function generalizes ‘aref’ and ‘nth’.
#+end_defun

#+findex:nth
#+attr_texinfo: :options nth n list
#+begin_defun
This function returns the Nth element of LIST (using zero indexing), or ‘nil’
if N is out of bounds.
#+end_defun

#+findex:aref
#+attr_texinfo: :options aref arr index
#+begin_defun
This function returns the INDEXth element of the array or record ARR. The first
element is at index zero.
#+end_defun

#+findex:nthcdr n list
#+attr_texinfo: :options nthcdr n list
#+begin_defun
This function returns the Nth CDR of LIST. In other words, it skips past the
first N links of LIST and returns what follows. If N is zero, ‘nthcdr’ returns
all of LIST. If the length of LIST is N or less, ‘nthcdr’ returns ‘nil’.
#+end_defun

#+findex:last
#+attr_texinfo: :options last list &optional n
#+begin_defun
This function returns the last link of LIST. The ‘car’ of this link is the
list’s last element. If LIST is null, ‘nil’ is returned. If N is non-‘nil’, the
Nth-to-last link is returned instead, or the whole of LIST if N is bigger than
LIST’s length.
#+end_defun

#+findex:butlast
#+attr_texinfo: :options butlast x &optional n
#+begin_defun
This function returns the list X with the last element, or the last N elements,
removed. If N is greater than zero it makes a copy of the list so as not to
damage the original list.
#+end_defun

#+findex:nbutlast
#+attr_texinfo: :options nbutlast x &optional n
#+begin_defun
This is a version of ‘butlast’ that works by destructively modifying the ‘cdr’
of the appropriate element, rather than making a copy of the list.
#+end_defun

#+findex:caar
#+attr_texinfo: :options caar cons-cell
#+begin_defun
This is the same as ‘(car (car CONS-CELL))’.
#+end_defun

#+findex:cadr
#+attr_texinfo: :options cdar cons-cell
#+begin_defun
This is the same as ‘(car (cdr CONS-CELL))’ or ‘(nth 1 CONS-CELL)’.
#+end_defun

#+findex:cdar
#+attr_texinfo: :options cdar cons-cell
#+begin_defun
This is the same as ‘(cdr (car CONS-CELL))’.
#+end_defun

#+findex:cddr
#+attr_texinfo: :options cddr cons-cell
#+begin_defun
This is the same as ‘(cdr (cdr CONS-CELL))’ or ‘(nthcdr 2 CONS-CELL)’.
#+end_defun

#+texinfo: @subheading cXXXr

In addition to the above, 24 additional compositions of ‘car’ and ‘cdr’ are
defined as ‘cXXXr’ and ‘cXXXXr’, where each ‘X’ is either ‘a’ or ‘d’. ‘cadr’,
‘caddr’, and ‘cadddr’ pick out the second, third or fourth elements of a list,
respectively (‘cl-second’, ‘cl-third’, and ‘cl-fourth’).

*** Modifying Existing List Structures
You can modify the CAR and CDR contents of a cons cell with the primitives
‘setcar’ and ‘setcdr’. These are destructive operations because they change
existing list structure. Destructive operations should be applied only to
mutable lists, that is, lists constructed via ‘cons’, ‘list’ or similar
operations.

#+texinfo: @subheading Modifying Cons Cells

#+findex:setcar
#+attr_texinfo: :options setcar cons object
#+begin_defun
This function stores OBJECT as the new CAR of CONS, replacing its previous CAR.
In other words, it changes the CAR slot of CONS to refer to OBJECT. It returns
the value OBJECT.
#+end_defun

#+findex:setcdr
#+attr_texinfo: :options setcdr cons object
#+begin_defun
This function stores OBJECT as the new CDR of CONS, replacing its previous CDR.
In other words, it changes the CDR slot of CONS to refer to OBJECT. It returns
the value OBJECT.

You can delete elements from the middle of a list by altering the CDRs of the
cons cells in the list.

It is equally easy to insert a new element by changing CDRs.
#+end_defun

#+texinfo: @subheading Modifying Lists

#+findex:push
#+cindex:generalized variable
#+attr_texinfo: :options push element listname
#+begin_defun
This macro creates a new list whose CAR is ELEMENT and whose CDR is the list
specified by LISTNAME, and saves that list in LISTNAME. In the simplest case,
LISTNAME is an unquoted symbol naming a list, and this macro is equivalent to
‘(setq LISTNAME (cons ELEMENT LISTNAME))’.

‘listname’ can be a generalized variable. In that case, this macro does the
equivalent of ‘(setf LISTNAME (cons ELEMENT LISTNAME))’.

See ‘pop’, which removes the first element from a list.
#+end_defun

#+findex:pop
#+cindex:generalized variable
#+attr_texinfo: :options pop listname
#+begin_defun
This macro provides a convenient way to examine the CAR of a list, and take it
off the list, all at once. It removes the first element from the list, saves
the CDR into LISTNAME, then returns the removed element. LISTNAME can be a
generalized variable. In that case, this macro saves into LISTNAME using
‘setf’.

See ~setf~, ~push~.
#+end_defun

#+texinfo: @subheading Modifying Array Elements

#+attr_texinfo: :options aset array index object
#+begin_defun
This function sets the INDEXth element of ARRAY to be OBJECT. It returns
OBJECT.  The ARRAY should be mutable.
#+end_defun

#+texinfo: @heading Rearranging Lists

Here are some functions that rearrange lists destructively by modifying the
CDRs of their component cons cells. These functions are destructive because
they chew up the original lists passed to them as arguments, relinking their
cons cells to form a new list that is the returned value.

#+findex:nconc
#+attr_texinfo: :options nconc &rest lists
#+begin_defun
This function returns a list containing all the elements of LISTS. Unlike
‘append’, the LISTS are _not_ copied. Instead, the last CDR of each of the
LISTS is changed to refer to the following list. The last of the LISTS is not
altered. All arguments but the last should be mutable lists (do _not_ use a
constant list).
#+end_defun

#+attr_texinfo: :options fillarray array object
#+begin_defun
This function fills the array ARRAY with OBJECT, so that each element of ARRAY
is OBJECT. It returns ARRAY.
#+end_defun

*** Modifying List Variables

Here are convenient ways to modify a list stored in a variable.

#+findex:add-to-list
#+attr_texinfo: :options add-to-list symbol element &optional append compare-fn
#+begin_defun
This function sets the variable SYMBOL by consing ELEMENT onto the old value,
if ELEMENT is not already a member of that value. It returns the resulting
list, whether updated or not. The value of SYMBOL had better be a list already
before the call. ‘add-to-list’ uses COMPARE-FN to compare ELEMENT against
existing list members; if COMPARE-FN is ‘nil’, it uses ‘equal’.

Normally, if ELEMENT is added, it is added to the front of SYMBOL, but if the
optional argument APPEND is non-‘nil’, it is added at the end.

The argument SYMBOL is not implicitly quoted; ‘add-to-list’ is an ordinary
function, like ‘set’ and unlike ‘setq’. Quote the argument yourself if that is
what you want.
#+end_defun

#+findex:add-to-ordered-list
#+attr_texinfo: :options add-to-ordered-list symbol element &optional order
#+begin_defun
This function sets the variable SYMBOL by inserting ELEMENT into the old value,
which must be a list, at the position specified by ORDER. If ELEMENT is already
a member of the list, its position in the list is adjusted according to ORDER.
Membership is tested using ‘eq’. This function returns the resulting list,
whether updated or not.
#+end_defun
*** Lists as Sets

#+cindex:set, list
#+cindex:list as set
A sequence is normally considered an ordered collection.  It can be
considered as a set though.

These functions treat a list as an unordered mathematical set---they consider a
value an element of a set if it appears in the list without reference to order.

- union :: To form the union of two sets, use ‘append’ and remove duplicates
  using ‘delete-dups’.

- add-to-list :: See the function ‘add-to-list’ for a way to add an element to
  a list stored in a variable and used as a set.

#+texinfo: @subheading Functions Using ‘eq’

#+findex:memq
#+attr_texinfo: :options memq object list
#+begin_defun
This function tests to see whether OBJECT is a member of LIST. If it is, ‘memq’
returns a list starting with the first occurrence of OBJECT. Otherwise, it
returns ‘nil’. The letter ‘q’ in ‘memq’ says that it uses ‘eq’ to compare
OBJECT against the elements of the list.
#+end_defun

#+findex:delq
#+attr_texinfo: :options delq object list
#+begin_defun
This function destructively removes all elements ‘eq’ to OBJECT from LIST, and
returns the resulting list. The letter ‘q’ in ‘delq’ says that it uses ‘eq’ to
compare OBJECT against the elements of the list, like ‘memq’ and ‘remq’.
Typically, when you invoke ‘delq’, you should use the return value by assigning
it to the variable which held the original list.

: (setq flowers (delq 'rose flowers))

If you want to delete elements that are ‘equal’ to a given value, use ‘delete’.
#+end_defun

#+findex:remq
#+attr_texinfo: :options remq object list
#+begin_defun
This function returns a copy of LIST, with all elements removed which are ‘eq’
to OBJECT. The letter ‘q’ in ‘remq’ says that it uses ‘eq’ to compare OBJECT
against the elements of ‘list’.
#+end_defun

#+texinfo: @subheading Function Using ‘eql’

#+findex:memql
#+attr_texinfo: :options memql object list
#+begin_defun
oThe function ‘memql’ tests to see whether OBJECT is a member of LIST, comparing
members with OBJECT using ‘eql’, so floating-point elements are compared by
value. If OBJECT is a member, ‘memql’ returns a list starting with its first
occurrence in LIST. Otherwise, it returns ‘nil’.
#+end_defun

#+texinfo: @subheading Functions Using ‘equal’

#+findex:member
#+attr_texinfo: :options member object list
#+begin_defun
The function ‘member’ tests to see whether OBJECT is a member of LIST,
comparing members with OBJECT using ‘equal’. If OBJECT is a member, ‘member’
returns a list starting with its first occurrence in LIST. Otherwise, it
returns ‘nil’.
#+end_defun

#+findex:delete
#+attr_texinfo: :options delete object sequence
#+begin_defun
This function removes all elements ‘equal’ to OBJECT from SEQUENCE, and returns
the resulting sequence. As with ‘delq’, you should typically use the return
value by assigning it to the variable which held the original list. If
‘sequence’ is a vector or string, ‘delete’ returns a copy of ‘sequence’ with
all elements ‘equal’ to ‘object’ removed.
#+end_defun

#+findex:remove
#+attr_texinfo: :options remove object sequence
#+begin_defun
This function is the non-destructive counterpart of ‘delete’. It returns a copy
of ‘sequence’, a list, vector, or string, with elements ‘equal’ to ‘object’
removed.
#+end_defun

#+findex:member-ignore-case
#+attr_texinfo: :options member-ignore-case object list
#+begin_defun
This function is like ‘member’, except that OBJECT should be a string and that
it ignores differences in letter-case and text representation: upper-case and
lower-case letters are treated as equal, and unibyte strings are converted to
multibyte prior to comparison.
#+end_defun

#+findex:delete-dups
#+attr_texinfo: :options delete-dups list
#+begin_defun
This function destructively removes all ‘equal’ duplicates from LIST, stores
the result in LIST and returns it. Of several ‘equal’ occurrences of an element
in LIST, ‘delete-dups’ keeps the first one.
#+end_defun
* Elisp
** Evaluate Emacs Lisp Expressions
*Emacs Lisp mode* is the major mode for editing Emacs Lisp.

- =emacs-lisp-mode=

*** Eval Buffer
- =(eval-buffer)= ::

  Execute the accessible portion of current buffer as Lisp code.  You can use
  =C-x n n= to limit the part of buffer to be evaluated.

  When called from a Lisp program (i.e., not interactively), this function
  accepts up to five optional arguments:

  - BUFFER :: the buffer to evaluate (buffer or srtring) (current buffer if
    'nil')

  - PRINTFLAG :: controls printing of output by output functions;
    - 'nil' means discard
    - 't’ means print

  - FILENAME :: the file name to use for 'load-history'

  - UNIBYTE :: if non-'nil', specifies 'load-convert-to-unibyte'

  - DO-ALLOW-PRINT :: if non-'nil', output functions should work normally;
    output is displayed in echo area.

  It will heed =-*- lexical-binding: t -*-= setting in heading; otherwise, the
  buffer will be evaluated without lexical binding.

*** Eval Region
- =(eval-region)= ::

  Execute the region as Lisp code.

  When called from programs, expects two arguments, giving starting and ending
  indices in the current buffer of the text to be executed.

  - START :: start point of region

  - END :: end point of region

  - PRINTFLAG :: 'nil' means to discard printed output

  - READ-FUNCTION :: if non-'nil', use an alternate function to read each
    expression.  It’s one argument is the input stream for reading characters.

*** Eval S-Expression
- =(eval-last-sexp)= :: =C-x C-e=

  Evaluate sexp  before point; print  value in the echo  area. Interactively,
  with a non ‘-’ prefix argument, print output into current buffer.

  It is one of few commands that are globally available to most modes, and it
  only works if you have the point at the end of an s-expression.

  Normally, this function truncates long output according to the value of the
  variables:

  - eval-expression-print-length
  - eval-expression-print-level

  With a prefix argument of '0', do not truncate.

  If ‘eval-expression-debug-on-error’ is non-nil, which is the default, this
  command arranges for all errors to enter the debugger.

  There are a couple of limitations that make this command a poor tool to use
  if you are writing and testing elisp code, because it cannot update variables
  declared with =defvar= or =defcustom=, and it goes with saying that having to
  move point to the end of the expression every time you want to eval the sexp
  is annoying as well.

*** Eval Defun
    - =eval-defun= :: =C-M-x=

      Evaluate  the top-level  form containing  point, or  after point.  If the
      current defun is  actually a call to ‘defvar’  or ‘defcustom’, evaluating
      it this way resets the variable using its initial value expression.

      If  ‘eval-expression-debug-on-error’ is  non-nil, which  is the  default,
      this command arranges for all errors to enter the debugger.

      With a prefix argument, instrument the code for Edebug.


This command is designed for a  typical hacker’s write-eval-test cycle. You can
type =C-M-x=  anywhere in  a form,  and it will  evaluate the  outer-most form,
ensuring that you won’t accidentally evaluate only a part of a larger form.

It has  built-in support for Edebug.  Using the universal argument  =C-u= Emacs
will evaluate  the form as normal,  but enable debug instrumentation.  The next
time it is  run it kicks off the  debugger and lets you step  through the code,
with every evaluation showing its value (if any) in the echo area.

*** Eval Expression
- =eval-expression= :: =M-:=

  Evaluate EXP and print value in the echo area.

  When called interactively, read an Emacs  Lisp expression and evaluate it. If
  invoked with  the universal argument =C=u=,  the output of the  expression is
  inserted into the buffer.

  It evaluates code in the context of the buffer it is invoked from.

- =repeat-complex-command= :: =C-x M-:=

  Edit and  re-evaluate last  complex command,  or ARGth  from last.  A complex
  command  is one  that  used the  minibuffer.  The command  is  placed in  the
  minibuffer as a Lisp form for  editing. The result is executed, repeating the
  command as changed.

  You can  use the  minibuffer history  commands M-n and  M-p to  get different
  commands to edit and resubmit.

*** Interactive Evaluation and Executing Lisp Expressions
Emacs has major modes for variants of Lisp, including Emacs Lisp and
Scheme.  They provide special commands for executing Lisp expressions.

**** Prog Mode
Major mode for editing programming language source code.

- =prog-indent-sexp= :: =C-M-q=

  Indent the expression after point.

  When interactively called with prefix, indent the enclosing defun instead.

- =prog-mode-hook= ::

**** Lisp Data Mode
Major mode for buffers holding data written in Lisp syntax. The base major mode
for editing Lisp code (used also for Emacs Lisp).

- =prog-indent-sexp= ::

  Indent the expression after point.

  When interactively called with prefix, indent the enclosing defun instead.

Parent mode is *Prog Mode*.

- =lisp-data-mode-hook=

**** Lisp Mode
Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.

Lisp mode is the major mode for editing programs written in
general-purpose Lisp dialects, such as Common Lisp. Emacs uses Lisp
mode automatically for files whose names end in ‘.l’, ‘.lsp’, or
‘.lisp’.

- =M-x lisp-mode=

- =lisp-eval-last-sexp= :: =C-x C-e=

  Send the previous sexp to an inferior (external) Lisp process.
  Prefix argument means switch to the Lisp buffer afterwards.

Parent mode is *Lisp Data Mode*.

**** Inferior Lisp Mode
Parent mode is *Comint Mode*.

Major  mode  for  interacting  with  an inferior  Lisp  process.  Runs  a  Lisp
interpreter as a subprocess of Emacs, with Lisp I/O through an Emacs buffer.

- =inferior-lisp-program= ::

  controls which Lisp interpreter is run.

**** Emacs Lisp Mode
Major mode for editing Lisp code and Lisp source files to run in
Emacs.

- =emacs-lisp-mode= ::  mode command

- =eval-defun= :: =C-M-x=

  Evaluate the top-level form containing point,  or after point. If the current
  defun is actually  a call to ‘defvar’ or ‘defcustom’,  evaluating it this way
  resets the variable using its  initial value expression This command arranges
  for all errors to enter the debugger.

  With a prefix argument, instrument the code for Edebug.

- =eval-expression= :: =M-:=

  Evaluate EXP and print value in the echo area. When called
  interactively, read an Emacs Lisp expression and evaluate it.

- =eval-last-sexp= :: =C-x C-e=

  Evaluate  sexp  before point  print  value  in the  echo  area.
  Interactively,  with a  non ‘-’  prefix argument,  print output
  into current buffer.

- =eval-region= and =eval-buffer= ::

  The command ‘M-x eval-region’ parses  the text of the region as
  one or more Lisp expressions,  evaluating them one by one. ‘M-x
  eval-buffer’ is similar but evaluates the entire buffer.

Parent mode is *Lisp Data Mode*.

**** Lisp Interaction Mode
#+cindex:scratch buffer
#+cindex:lisp interaction mode
#+cindex:mode, lisp interaction
When  Emacs starts  up,  it contains  a buffer  named  =*scratch*=, which  is
provided for evaluating Emacs Lisp  expressions interactively using the major
mode *Lisp Interaction  Mode*, whose parent mode is *Emacs  Lisp Mode*, whose
parent mode is *Lisp Data Mode*, and whose parent mode is *Prog Mode*.

- =M-x lisp-interaction-mode= ::

  Major mode for typing and evaluating Lisp forms in an interactive
  Emacs Lisp session.

  Parent mode is *Emacs Lisp Mode*.

  This mode  is like Lisp  mode except that =M-x  eval-print-last-sexp= (=C-j=)
  evals the Lisp expression before point, and prints its value into the buffer,
  advancing point.

- =eval-print-last-sexp= :: =C-j=

  Evaluate sexp before point; print value into current buffer.

- =completion-at-point= :: =C-M-i=

- =indent-pp-sexp= :: =C-M-q=

- =eval-defun= :: =C-M-x=

***** The Scratch Buffer---*scratch*

 This buffer is  provided for evaluating Emacs  Lisp expressions interactively.
 Its major mode is Lisp Interaction mode.

 This buffer is useful for throw-away  scripts and quick code evaluation. If you
 put  point at  the  end of  an  sexp and  type =C-j=  Emacs  will evaluate  the
 expression and print the result straight into the buffer.

 - =eval-print-last-sexp= :: =C-j=

   Evaluate sexp before point; print value into current buffer, truncating. With
   a prefix argument of zero, there is no truncation.

   If ‘eval-expression-debug-on-error’  is non-nil,  which is the  default, this
   command arranges for all errors to enter the debugger.

- =initial-scratch-message= ::

  Variable to  control the initial  message in the buffer.  Set it to  either a
  documentation string or ’nil’ to suppress it.
**** The Interactive Emacs Lisp Mode---ielm
#+cindex:interactive emacs lisp mode (ielm)
#+cindex:mode, interactive emacs lisp (ielm)
#+cindex:ielm
An  alternative way  (to *Lisp  Interactive Mode*)  of evaluating  Emacs Lisp
expressions  interactively  is  to  use *Inferior  Emacs  Lisp  mode*,  which
provides  an interface  rather like  *Shell mode*  for evaluating  Emacs Lisp
expressions.  Type  ~M-x ielm~  to create  an *ielm*  buffer which  uses this
mode.

- =M-x ielm= ::

  Run the elisp REPL. The mode inherits from =comint= (command history, limited
  TAB completion).

  =*=, =**=, =***= to get the last three outputs from the shell.

  Working buffer---a  buffer through which  your changes are  evaluated. Typing
  =C-c C-b= allows  you to choose ielm’s  working buffer, so that  all the code
  you evaluate thereafter will be treated as  if you executed it in the context
  of that  buffer. This functionality  comes in handy  if you are  dealing with
  buffer-local variables or changes that’re specific to one buffer only.

  - Auto-Complete ::

    By default ielm is not supported in auto complete.  To make it so, add this
    code to you =.emacs=:


#+begin_src elisp
  (defun ielm-auto-complete ()
    "Enables `auto-complete' support in \\[ielm]."
    (setq ac-sources '(ac-source-functions
		       ac-source-variables
		       ac-source-features
		       ac-source-symbols
		       ac-source-words-in-same-mode-buffers))
    (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
    (auto-complete-mode 1))
  (add-hook 'ielm-mode-hook 'ielm-auto-complete)
#+end_src

**** Scheme Mode
Parent mode is *Prog Mode*.

Major mode for editing Scheme code. Editing commands are similar to
those of ‘lisp-mode’.

In addition, if an inferior Scheme process is running, some additional
commands will be defined, for evaluating expressions and controlling
the interpreter, and the state of the process will be displayed in the
mode line of all Scheme buffers.

Use =M-x run-scheme= to start an inferior Scheme using the more
general ‘cmuscheme’ package.

- =scheme-send-last-sexp= :: =C-x C-e=

  Send the previous sexp to the inferior Scheme process.

- =scheme-mode-hook= ::

**** Inferior Scheme Mode
Major mode for interacting with an inferior Scheme process. Like
Inferior Lisp mode, but for Scheme.

Parent mode is *Comint Mode*.

A Scheme process can be fired up with =M-x run-scheme=.

- =scheme-send-last-sexp= :: =C-x C-e=

- =inferior-scheme-mode-hook= ::

**** Shell Mode
The  major mode  for Shell  buffers  is *Shell  mode*.  Many  of its  special
commands are  bound to the ‘C-c’  prefix, and resemble the  usual editing and
job control characters present in ordinary  shells, except that you must type
‘C-c’ first.

Shell  mode is  a derivative  of *Comint  mode*, a  general-purpose mode  for
communicating with interactive  subprocesses.  Most of the  features of Shell
mode actually  come from  Comint mode.   The special  features of  Shell mode
include
- the directory tracking feature, and
- a few user commands.

**** Eshell
*Eshell* is a  shell-like command interpreter implemented in  Emacs Lisp.  It
invokes no external processes except for  those requested by the user.  It is
intended to  be an  alternative to  the IELM  (*note Emacs  Lisp Interaction:
(emacs)Lisp Interaction.) REPL  for Emacs _and_ with an  interface similar to
command shells such as  ‘bash’, ‘zsh’, ‘rc’, or ‘4dos’.  It  has its own Info
manual.

*Eshell* is a “command shell” written  in Emacs Lisp.  Everything it does, it
uses Emacs’s  facilities to  do.  This  means that Eshell  is as  portable as
Emacs itself.  It  also means that cooperation with Lisp  code is natural and
seamless.

You can evaluate elisp in *Eshell* directly from the prompt.

Unlike  regular  system  shells,  *Eshell*  never  invokes  kernel  functions
directly, such as  ‘exec(3)’.  Instead, it uses the  Lisp functions available
in the Emacs Lisp library.  It does  this by transforming the input line into
a callable  Lisp form.   The command can  be either an  Elisp function  or an
external  command.   To  see  the  Lisp form  that  will  be  invoked,  type:
‘eshell-parse-command "echo hello"’

** Functions
*** Calling--Invoking Functions
#+texinfo: @heading Evaluation
The  most  common  way of  invoking  a  function  is  by /evaluating/  a  list.
Evaluating  the  list =(concat  "a"  "b")=  calls  the function  ~concat~  with
arguments "a" and "b".

#+texinfo: @heading @code{funcall}
Occasionally you  need to  compute at run  time which function  to call.  To do
that, use the function ~funcall~.

#+attr_texinfo: :options funcall function &rest arguments
#+begin_defun
  Call first argument as a function,  passing remaining arguments to it.

  Return the value that =FUNCTION= returns.

  : (funcall ’cons ’x ’y) ==> (x . y)

  Since ~funcall~  is a function,  all of its arguments,  including =FUNCTION=,
  are evaluated  before ~funcall~ is  called. This means  that you can  use any
  expression to obtain the function to  be called. It also means that ~funcall~
  does not see the expressions you  write for the arguments, only their values.
  These values are not evaluated a second time in the act of calling function

  The  argument =FUNCTION=  must  be  either a  Lisp  function  or a  primitive
  function. Special forms and macros are not allowed.
#+end_defun

#+texinfo: @heading @code{funcall-interactively}
If you need to use ~funcall~ to call a command and make it behave as if invoked
interactively, use ~funcall-interactively~.

#+attr_texinfo: :options funcall-interactively function &rest arguments
#+begin_defun
  Like ~funcall~  but marks the call  as interactive. I.e. arrange  that within
  the called function ~called-interactively-p~ will return non-=nil=.
#+end_defun

#+texinfo: @heading @code{call-interactively}
Some functions are  user-visible *commands*, which can  be called interactively
(usually by a key sequence). It is possible to invoke such a command exactly as
though it was called interactively, by using the ~call-interactively~ function.

#+attr_texinfo: :options call-interactively function &optional record-flag keys
#+begin_defun
  Call =FUNCTION=, providing =ARGS= according to its interactive calling specs.
  Return the value =FUNCTION= returns.

  The function contains  a specification of how to do  the argument reading. In
  the case  of user-defined functions, this  is specified by placing  a call to
  the  function ~interactive~  at  the  top level  of  the  function body.
#+end_defun

#+texinfo: @heading @code{apply}
When you  also need to determine  at run time  how many arguments to  pass, use
~apply~. ~apply~ calls function with  =ARGUMENTS=, just like ~funcall~ but with
one difference: the last of =ARGUMENTS= is  a list of objects, which are passed
to =FUNCTION=  as separate arguments,  rather than a  single list. We  say that
~apply~  /spreads/  this  list  so  that each  individual  element  becomes  an
argument.

=FUNCTION= must  either be  a Lisp  function or  a primitive  function; special
forms and macros do not make sense in ~apply~.

#+attr_texinfo: :options apply function &rest arguments
#+begin_defun
  Call =FUNCTION= with remaining =args=, using last =arg= as list of =args=.

  Then return the value =FUNCTION= returns.

  With a  single argument, call  the argument’s  first element using  the other
  elements as =args=.

  : (apply '+ 1 2 '(3 4)) ==> 10.
#+end_defun
*** Partial Application

#+cindex:partial application
Here’s how to do partial application in Emacs Lisp:

#+attr_texinfo: :options apply-partially func &rest args
#+begin_defun
  Return a function  that is a partial application of  =FUNC= to =ARGS=. =ARGS=
  is a  list of the first  N arguments to pass  to =FUNC=. The result  is a new
  function which does the same as =FUNC=, except that the first N arguments are
  fixed at the values with which this function was called.
#+end_defun
*** Mapping Functions
#+cindex:mapping functions
A /mapping function/ applies a given function  (not a special form or macro) to
each element of a list or other collection.

This section describes
 - ~mapcar~ :: ~apply~ =FUNCTION= to each element of =SEQUENCE=; return a list
   of results
 - ~mapc~  :: like  ~mapcar~  except ~apply~  function  for side-effects  only;
   return =SEQUENCE=
 - ~mapconcat~ ::
 - ~mapcan~ ::

There are other sections that discuss:
 - ~mapatoms~
 - ~maphash~
 - ~map-char-table~

**** Function ~mapcar~
~mapcar~ applies  function to each element  of sequence in turn,  and returns a
list of the results.

#+attr_texinfo: :options mapcar function sequence
#+begin_defun
  Apply =FUNCTION= to each element of =SEQUENCE=, and make a list of the results.

  The result  is a list (always)  just as long  as =SEQUENCE=.

  =SEQUENCE= may be a list, a vector, a bool-vector, or a string (not char-table).
#+end_defun

#+texinfo: @subheading Examples of @code{mapcar}

#+begin_example
  (mapcar 'car '((a b) (c d) (e f)))
       ⇒ (a c e)
  (mapcar '1+ [1 2 3])
       ⇒ (2 3 4)
  (mapcar 'string "abc")
       ⇒ ("a" "b" "c")

  ;; Call each function in my-hooks.
  (mapcar 'funcall my-hooks)
#+end_example

#+caption:Define Function @{mapcar*}
#+name:mapcar*
#+begin_src elisp
  (defun mapcar* (function &rest args)
    "Apply FUNCTION to successive cars of all ARGS.
  Return the list of results."
    ;; If no list is exhausted,
    (if (not (memq nil args))
        ;; apply function to CARs.
        (cons (apply function (mapcar 'car args))
              (apply 'mapcar* function
                     ;; Recurse for rest of elements.
                     (mapcar 'cdr args)))))

;  (mapcar* 'cons '(a b c) '(1 2 3 4))
;       ⇒ ((a . 1) (b . 2) (c . 3))
#+end_src

**** Function ~mapcan~ 

This function applies =FUNCTION= to  each element of =SEQUENCE=, like ~mapcar~,
but instead  of collecting the  results into a list,  it returns a  single list
with all  the elements of  the results (which must  be lists), by  altering the
results (using ~nconc~).

#+attr_texinfo: :options mapcan
#+begin_defun
  Apply =FUNCTION=  to each element of  =SEQUENCE=, and concatenate the  results by
  altering  them  (using  ~nconc~).

  =SEQUENCE= may be a list, a vector, a bool-vector, or a string.
#+end_defun

#+texinfo: @subheading Example of @code{mapcan}

#+begin_src elisp
  ; Contrast this:
  (mapcar 'list '(a b c d))
       ⇒ ((a) (b) (c) (d))
  ;; with this:
  (mapcan 'list '(a b c d))
       ⇒ (a b c d)
#+end_src

**** Function ~mapconcat~ 

~mapconcat~ applies =FUNCTION= to each  element of sequence; the results, which
must be sequences of characters  (strings, vectors, or lists), are concatenated
into  a single  string return  value. Between  each pair  of result  sequences,
~mapconcat~  inserts the  characters from  =SEPARATOR=,  which also  must be  a
string, or a vector or list of characters.

#+attr_texinfo: :options mapconcat sequence separator
#+begin_defun
  Apply =FUNCTION= to  each element of =SEQUENCE=, and ~concat~  the results as
  strings. =SEQUENCE= may be a list, a vector, a bool-vector, or a string.

  In between each pair of results,  stick in =SEPARATOR=. =SEPARATOR= must be a
  string, a vector, or a list of characters.

  =FUNCTION= must be a  function of one argument, and must  return a value that
  is a sequence of characters: either a  string, or a vector or list of numbers
  that are valid character codepoints.
#+end_defun

#+texinfo: @subheading Example of @code{mapconcat}

#+begin_src elisp
  (mapconcat 'symbol-name
             '(The cat in the hat)
             " ")
       ⇒ "The cat in the hat"

  (mapconcat (lambda (x) (format "%c" (1+ x)))
             "HAL-8000"
             "")
       ⇒ "IBM.9111"
#+end_src

** Run an External Lisp or Scheme Session
You can  run an  external Lisp  or Scheme session  as a  subprocess or
inferior process of Emacs, and pass expressions to it to be evaluated.

*** Inferior Lisp Session

- =M-x run-lisp= :: =(run-lisp CMD)= Alias of =inferior-lisp=.

  To begin an external Lisp session, type =M-x run-lisp=. This runs the program
  named =lisp=,  and sets it  up so  that both input  and output go  through an
  Emacs buffer named  =*inferior-lisp*=. This command also switches  back to an
  existing inferior  lisp job. To  change the name of  the Lisp program  run by
  ‘M-x run-lisp’, change the variable ‘inferior-lisp-program’.

- =inferior-lisp= :: =(inferior-lisp CMD)=

  Run an inferior Lisp process, input and output via buffer ‘*inferior-lisp*’.

  If there  is a process already  running in ‘*inferior-lisp*’, just  switch to
  that buffer.

  With  argument, allows  you to  edit the  command line  (default is  value of
  ‘inferior-lisp-program’).

- =inferior-lisp-mode= ::

  The major mode for the *lisp*  buffer is *Inferior Lisp mode*, which combines
  the characteristics of Lisp mode and Shell mode.

  To send  input to the Lisp  session, go to the  end of the *lisp*  buffer and
  type the input,  followed by <RET>. Terminal output from  the Lisp session is
  automatically inserted in the buffer.

- =inferior-lisp-program= ::

  Variable holding the namne of the lisp program to run with =run-lisp=.

- =lisp-mode= ::

  When you edit a Lisp program in Lisp mode, you can type =C-M-x=
  (=lisp-eval-defun=) to send an expression from the Lisp mode buffer
  to a Lisp session that you had started with =M-x run-lisp=. The
  expression sent is the top-level Lisp expression at or following
  point. The resulting value goes as usual into the =*inferior-lisp*=
  buffer.

*** Inferior Scheme Session

The facilities for editing Scheme code, and for sending expressions to
a Scheme subprocess, are very similar. If an inferior Scheme process
is running, some additional commands will be defined, for evaluating
expressions and controlling the interpreter, and the state of the
process will be displayed in the mode line of all Scheme buffers.

- =M-x scheme-mode= ::

  Scheme source files are edited in Scheme mode.

- =M-x run-scheme= ::

  Initiate a  Scheme session, or  run an inferior Scheme  process. The
  buffer for  interacting with  Scheme is  named ‘*scheme*’  using the
  =cmuscheme' package.

- =scheme-send-definition= :: =C-M-x=, =C-c C-e=

  Send the current definition to the inferior Scheme process.

- =scheme-program-name= ::

  Program invoked by the ‘run-scheme’ command. It's current value is
  "scheme".

  If the file ‘~/.emacs_SCHEMENAME’ or
  ‘~/.emacs.d/init_SCHEMENAME.scm’ exists, it is given as initial
  input.

- =scheme-mode-hook= ::

*** External Scheme
- =scheme-mode= ::

  Parent mode is *Prog Mode*.

  Major mode for editing Scheme code.  Editing commands are similar to those of
  ‘lisp-mode’.

*** SLIME Mode
- [[https://github.com/slime/slime][SLIME on GitHub]]
- [[https://common-lisp.net/project/slime/doc/html/index.html#SEC_Contents][SLIME User Manual, version 2.24]]


SLIME extends  Emacs with support  for interactive programming in  Common Lisp.
The  features  are  centered  around =slime-mode=,  an  Emacs  minor-mode  that
complements the  standard =lisp-mode=. While =lisp-mode=  supports editing Lisp
source files, =slime-mode=  adds support for interacting with  a running Common
Lisp process for compilation, debugging, documentation lookup, and so on.

SLIME is  constructed from two parts:  a user-interface written in  Emacs Lisp,
and  a supporting  server program  written in  Common Lisp.  The two  sides are
connected together with a socket and communicate using an RPC-like protocol.

- CMU Common Lisp (CMUCL),
- Steel Bank Common Lisp (SBCL)
- Clozure Common Lisp (CCL)
- LispWorks
- Allegro Common Lisp (ACL),
- CLISP
- Armed Bear Common Lisp (ABCL)
- Corman Common Lisp
- Scieneer Common Lisp (SCL)
- Embedded Common Lisp (ECL)

**** SLIME Installation
Install SLIME using Emacs’ package manager.

Define a default Lisp program using the variable =inferior-lisp-program=.

: (setq inferior-lisp-program "/opt/sbcl/bin/sbcl")

SLIME can be run using the command =slime=.

: [C-u] M-x slime

This    command    runs    the   command    =inferior-lisp=,    which    starts
=inferior-lisp-mode= and starts  an inferior lisp process; and  then starts the
lisp  server "Swank";  and establishes  a socket  connection between  Emacs and
Lisp;  and starts  a  REPL buffer  where  you can  enter  Lisp expressions  for
evaluation.

With a prefix argument, Emacs will prompt for the program.

** Edit Lisp Code
- [[https://www.cliki.net/Editing+Lisp+Code+with+Emacs][Editing Lisp Code with Emacs]]

*** Structured Editing
Structured editing is a  way of editing source code which  attempts, as much as
is possible,  to keep  the source  code consistently  valid. This  means, among
other  things, that  the inserting  of an  open parenthesis  should insert  the
closing one as well.

- paredit mode

  - [[http://mumble.net/~campbell/emacs/paredit.html][paredit cheat sheet]]

- parinfer mode
** Pcase Macro
   :PROPERTIES:
   :date:     Jan 21, 2016
   :author:   John Wiegley
   :END:
Emacs: Pattern Matching with pcase

- http://www.newartisans.com/2016/01/pattern-matching-with-pcase/


This is  a tutorial  on how to  use the  pcase macro in  modern flavors  of GNU
Emacs.
** Nonlocal Exits

#+cindex:nonlocal exit
#+cindex:exit, nonlocal
A *nonlocal  exit* is  a transfer  of control from  one point  in a  program to
another remote point. A *nonlocal exit*  can occur intentionally through use of
~catch~ and ~throw~, or unintentionally, through the occurrence of an =error=.

The  following sections  discuss  intentional  non-local exists,  unintentional
non-local exits,  and making sure  your process  remains in a  consistent state
following a non-local exit.

*** ~catch~ and ~throw~---Explicit Nonlocal Exits

#+texinfo: @subsubheading Catch and Throw Concepts
- catch
- throw

#+findex:throw
#+findex:catch
The function ~throw~ performs a *nonlocal exit* on request. It is used inside a
~catch~, and jumps back to that ~catch~.

#+caption:Simple example of catch-throw
#+name:simple-catch-throw
#+begin_src elisp
(defun foo-outer ()
  (catch 'foo
    (foo-inner)))

(defun foo-inner ()
  …
  (if x
      (throw 'foo t))
  …)
#+end_src

In  the  above  example,  the  ~throw~ specifies  =foo=,  and  the  ~catch~  in
~foo-outer~ specifies the same symbol, so that ~catch~ is the applicable one.

#+attr_texinfo: :options catch tag body
#+begin_defun
~catch~ establishes a  return point for the ~throw~ function.  The return point
is distinguished from other such return points  by =tag=, which may be any Lisp
object except =nil=.

~catch~ evaluates the forms of the body  in textual order. If the forms execute
normally (without error  or nonlocal exit) the  value of the last  body form is
returned from the ~catch~.

If a  ~throw~ is executed during  the execution of =body=,  specifying the same
value  =tag=, the  ~catch~  form exits  immediately; the  value  it returns  is
whatever was specified as the second argument of ~throw~.
#+end_defun

#+attr_texinfo: :options throw tag value
#+begin_defun
The purpose of ~throw~ is to  return from a return point previously established
with ~catch~. The  argument =tag= is used to choose  among the various existing
return points; it must be ~eq~ to the value specified in the ~catch~. If multiple
return points match =tag=, the innermost one is used.

The argument =value= is used as the value to return from that ~catch~.
#+end_defun

The  ~throw~  form,  if  executed,  transfers  control  straight  back  to  the
corresponding  ~catch~,  which  returns  immediately. The  code  following  the
~throw~ is not executed.  The second argument of ~throw~ is  used as the return
value of the ~catch~. The function  ~throw~ finds the matching ~catch~ based on
the first argument: it  searches for a ~catch~ whose first  argument is ~eq~ to
the one specified in the ~throw~. If there is more than one applicable ~catch~,
the innermost one takes precedence.

Executing  ~throw~  exits all  Lisp  constructs  up  to the  matching  ~catch~,
including function calls. The bindings are unbound, just as they are when these
constructs exit  normally. ~throw~  restores the buffer  and position  saved by
~save-excursion~, and the narrowing status saved by ~save-restriction~. It also
runs any  cleanups established with  the ~unwind-protect~ special form  when it
exits that form.

The ~throw~ need not  appear lexically within the ~catch~ that  it jumps to. It
can equally well be called from another function called within the ~catch~.

*** Errors---Unintentional Nonlocal Exits

#+texinfo: @subsubheading Error Concepts
- signal, error
- handle, error
- =error= handling, =error= handlers
- ~unwind-protect~ function, cleanup expressions
- ~condition-case~ function, recover control

#+cindex:errors
#+cindex:signal, error
#+cindex:error signal
When Emacs Lisp  attempts to evaluate a  form that, for some  reason, cannot be
evaluated, it  [[*Error Signaling][signals  an error]].  When an error  is signaled,  Emacs’s default
reaction is  to print an error  message and terminate execution  of the current
command.

#+findex:unwind-protect
In complicated programs,  simple termination may not be what  you want. In such
cases,  you would  use  the function  [[*Cleaning  Up  from Nonlocal  Exits][unwind-protect]]  to establish  /cleanup
expressions/ to be evaluated in case of error.

#+cindex:error handler
#+findex:condition-case
Occasionally, you may  wish the program to continue execution  despite an error
in a subroutine. In these  cases, you would use the function [[*Using condition-case to Trap  and Handle Errors with Handlers][condition-case]] to
establish [[*Error Processing---Error Debugging][error handlers]] to recover control in case of error.

Resist the temptation  to use error handling to transfer  control from one part
of the program to another; use ~catch~ and ~throw~ instead.

**** Error Signaling

#+texinfo: @subsubheading Error Signaling Concepts
- =error= signaling
- =error= processing
- =error= handling
- =error= symbol
- =error= message
- function ~error~
- function ~signal~

#+cindex:error signalling
#+cindex:error processing
*Signaling  an error*  means  beginning /error  processing/. Error  processing
normally aborts all or part of the  running program and returns to a point that
is set up to handle the error.

#+findex:error
#+findex:signal
Most =errors= are  signaled automatically within Lisp primitives.  You can also
signal =errors= explicitly with the functions ~error~ and ~signal~.

#+texinfo: @heading The @code{error} Function---The Error Message

#+cindex:error message
- =error message= ::

  Every =error= specifies an =error message=.  The message should state what is
  wrong, not how things ought to be. The convention in Emacs Lisp is that error
  messages should start with a capital letter, but should not end with any sort
  of punctuation.

#+attr_texinfo: :options error format-string &rest args
#+begin_defun

The function ~error~ /signals/ an =error=  with an =error message=. It works by
calling ~signal~  with two arguments:  the *error  symbol* =error=, and  a list
containing the string returned by ~format-message~.

- error message ::

  The   eror   message  is   constructed   by   applying  ~format-message~   to
  =format-string=  and  =args=. To  signal  with  MESSAGE without  interpreting
  format characters like ‘%’, ‘`’ and ‘'’, use =(error "%s" MESSAGE)=.
#+end_defun

#+texinfo: @heading The @code{signal} Function

#+cindex:error symbol
#+cindex:error conditions
#+attr_texinfo: :options signal error-symbol data
#+begin_defun
The function ~signal~ /signals/ an =error= named by =ERROR-SYMBOL=. It does not
return.

If the  =error= is not handled,  the two arguments (=ERROR-SYMBOL=  and =DATA=)
are used  in printing  an =error  message=. Normally,  this =error  message= is
provided  by the  =error-message= property  of =ERROR-SYMBOL=.  The number  and
significance of the objects in =DATA= depend on =ERROR-SYMBOL=.

- ERROR-SYMBOL

  The argument =ERROR-SYMBOL= must be an /error symbol/---a symbol defined with
  [[*Error Symbols---Condition  Names][~define-error~]]. An  /error symbol/  is a  symbol with  an =error-conditions=
  property that is a list of /condition/ names.

- DATA ::

  The argument  =DATA= is  a list  of additional Lisp  objects relevant  to the
  circumstances of the =error=. Its elements  are printed as part of the /error
  message/.
#+end_defun

#+texinfo: @heading The @code{user-error} Function

#+cindex:user errors
#+attr_texinfo: :options user-error format-string &rest args
#+begin_defun
This  function behaves  exactly like  ~error~, except  that it  uses the  /error
symbol/ =user-error= rather than =error=. As the name suggests, this is intended
to  report errors  on the  part of  the user,  rather than  errors in  the code
itself.
#+end_defun

**** Error Processing---Error Debugging

#+texinfo: @subsubheading Error Processing Concepts
- ~signal~
- error handler
- ~condition-case~ function
- =debug-on-error= variable
- =command-error-function= variable


#+cindex:handler, error
#+cindex:error handler
#+findex:condition-case
When an  =error= is /signaled/, ~signal~  searches for an active  *handler* for
the =error= ([[*Using condition-case to Trap and Handle Errors with Handlers][next]]).

- *handler* :: a  sequence of Lisp expressions designated to  be executed if an
  error happens in part of the Lisp program.

  If the  =error= has an applicable  *handler*, the *handler* is  executed, and
  control  resumes  following  the  handler.  The  *handler*  executes  in  the
  environment of the ~condition-case~ that established it; all functions called
  within that ~condition-case~ have already been exited, and the handler cannot
  return to them.

  If there is no applicable handler  for the =error=, it terminates the current
  command and  returns control to the  editor command loop. The  command loop’s
  handler  uses the  =error=  symbol  and associated  data  to  print an  error
  message.

#+texinfo: @heading The Debugger

#+vindex:debug-on-error
An error that has no explicit handler  may call the Lisp debugger. The debugger
is enabled if the variable ~debug-on-error~ is non-=nil=.

Unlike /error handlers/,  the debugger runs in the environment  of the =error=,
so that you can examine values of  variables precisely as they were at the time
of the =error=.

#+attr_texinfo: :options command-error-function
#+begin_defvar
This variable, if non-=nil=, specifies a  function to use to handle errors that
return  control to  the  Emacs command  loop. The  function  should take  three
arguments:
1. =data=,  a list of  the same form that  ~condition-case~ would bind  to its
  variable;
2. =context=, a string describing the situation in which the error occurred, or
   (more often) =nil=;
3. =caller=,  the Lisp function  which called  the primitive that  signaled the
   error.
#+end_defvar

**** Using condition-case to Trap and Handle Errors with Handlers

#+texinfo: @subsubheading Error Handling Concepts

- error trapping
- error handling, handlers
- ~condition-case~ special form
- error symbol
- error condition names
- error description
- ~debug-on-error~ variable
- ~debug-on-signal~ variable
- ~error-message-string~ function

#+texinfo: @heading condition-case

#+cindex:trap error
#+cindex:error trap
#+cindex:error description
#+findex:condition-case
You can  arrange to  /trap/ =errors=  occurring in  a part  of your  program by
establishing an =error handler=, with the special form ~condition-case~.

#+attr_texinfo: :options condition-case var protected-form handlers…
#+begin_defun

  Each ~error~  that occurs has an  /error symbol/ that describes  what kind of
  ~error~ it  is, and which describes  also a list of  /condition names/. Emacs
  searches all the active ~condition-case~ forms for a /handler/ that specifies
  one   or  more   of   these  /condition   names/;   the  innermost   matching
  ~condition-case~ handles the ~error~. Within this ~condition-case~, the first
  applicable  /handler/ handles  the error.  After  executing the  body of  the
  /handler/, the ~condition-case~ returns normally, using the value of the last
  form in the handler body as the overall value.

  - PROTECTED-FORM ::

    This special  form establishes the  /error handlers/ =HANDLERS=  around the
    execution of =PROTECTED-FORM=. If  =PROTECTED-FORM= executes without error,
    the value  it returns becomes  the value  of the ~condition-case~  form; in
    this case, the ~condition-case~ has no effect.

  - HANDLERS  ::

    Each of the =HANDLER= s is a list of the form ~(conditions body…)~.

    =CONDITIONS=  is an  /error condition  name/ to  be handled,  or a  list of
    /condition names/ (which  can include ~debug~ to allow the  debugger to run
    before the handler). A condition name of =t= matches any condition.

    =BODY= is  one or more  Lisp expressions to  be executed when  this handler
    handles an error.

  - VAR ::

    The  argument =VAR=  is a  variable.  ~condition-case~ does  not bind  this
    variable  when executing  the  ~protected-form~, only  when  it handles  an
    ~error~. At  that time, it binds  =VAR= locally to an  /error description/,
    which  is  a  list  giving  the particulars  of  the  ~error~.  The  /error
    description/ has the form =(error-symbol . data)=. The handler can refer to
    this list to decide  what to do. If =VAR= is =nil=,  that means no variable
    is bound.  Then the error symbol  and associated data are  not available to
    the handler.

  Sometimes it  is necessary to  re-throw a signal caught  by ~condition-case~,
  for some outer-level handler to catch. Here’s how to do that:
  : (signal (car err) (cdr err))
  where =ERR= is the /error description/ variable.
#+end_defun

***** Condition-Case Examples

#+caption:Simple ~condition-case~ Example
#+name:simple-condition-case-example
#+begin_src elisp
(condition-case nil
    (delete-file filename)
  (error nil))
#+end_src

This /catches/ any =error= on file deletion and returns =nil=. You can also use
the macro ~ignore-errors~ in a simple case like this.

- The  condition-case construct  is  often  used to  /trap/  =errors= that  are
  predictable,   such   as   failure   to   open  a   file   in   a   call   to
  insert-file-contents.

- It is  also used to /trap/  =errors= that are totally  unpredictable, such as
  when the program evaluates an expression read from the user.

- The second argument  of ~condition-case~ is called the  *protected form*. The
  *error  handlers* go  into effect  when this  form begins  execution and  are
  deactivated  when this  form  returns.  They remain  in  effect  for all  the
  intervening time. In  particular, they are in effect during  the execution of
  functions called by this form, in their subroutines, and so on.

- Strictly  speaking,  =errors=  can  be   signaled  only  by  Lisp  primitives
  (including ~signal~ and ~error~) called by the protected form.

- The arguments after the protected form are *handlers*. Each handler lists one
  or more /condition names/ (which are symbols) to specify which errors it will
  handle. The =error symbol= specified when an =error= is signaled also defines
  a list of /condition names/. A handler applies to an =error= if they have any
  /condition names/ in common.

- The search  for an applicable  *handler* checks all the  established handlers
  starting with the most recently established one.

- If  you  want   to  be  able  to   debug  =errors=  that  are   caught  by  a
  ~condition-case~, set the variable ~debug-on-signal~ to a non-=nil= value.

- You can  also specify that a  particular handler should let  the debugger run
  first, by writing =debug= among the conditions, like this:

  #+caption:Run Debugger First on File Deletion
  #+name:run-debugger-first-on-file-deletion
  #+begin_src elisp
    (condition-case nil
	(delete-file filename)
      ((debug error) nil))
  #+end_src

  The  effect  of  =debug=  here  is  only  to  prevent  ~condition-case~  from
  suppressing  the call  to the  debugger. Any  given =error=  will invoke  the
  debugger only  if ~debug-on-error~ and  the other usual  filtering mechanisms
  say it should.


#+texinfo: @subheading Example Error Handlers

#+caption: Example Handlers
#+name:example-handlers
#+begin_example
(error nil)

(arith-error (message "Division by zero"))

((arith-error file-error)
 (message
  "Either division by zero or failure to open a file"))
#+end_example

#+texinfo: @heading Handling a Specific Error
Here is an example of using ~condition-case~ to handle the =error= that results
from dividing by zero. The *handler*  displays the /error message/ (but without
a beep),  then returns a  very large  number. The handler  specifies *condition
name*  =arith-error= so  that it  will handle  only =division-by-zero=  errors.
Other kinds of errors will not be handled (by this ~condition-case~).

#+caption:Handling a Specific Error
#+name:handling-specific-error
#+begin_src elisp
  (defun safe-divide (dividend divisor)
    (condition-case err
	;; Protected form.
	(/ dividend divisor)
      ;; The handler.
      (arith-error                        ; Condition.
       ;; Display the usual message for this error.
       (message "%s" (error-message-string err))
       1000000)))
  ⇒ safe-divide

  (safe-divide 5 0)
       -| Arithmetic error: (arith-error)
  ⇒ 1000000

  (safe-divide nil 3)
       error→ Wrong type argument: number-or-marker-p, nil
#+end_src

#+texinfo: @subheading Handling All Kinds of Errors

#+texinfo: @heading Handling All Errors
Here is a condition-case that catches all kinds of errors, including those from
~error~:

#+caption:Handling All Errors
#+name:handling-all-errors
#+begin_src elisp
  (setq baz 34)
       ⇒ 34

  (condition-case err
      (if (eq baz 35)
	  t
	;; This is a call to the function error.
	(error "Rats!  The variable %s was %s, not 35" 'baz baz))
    ;; This is the handler; it is not a form.
    (error (princ (format "The error was: %s" err))
	   2))
  -| The error was: (error "Rats!  The variable baz was 34, not 35")
  ⇒ 2
#+end_src

***** Additional Error Handling Concepts

#+texinfo: @heading @code{condition-case-unless-debug} Macro

#+attr_texinfo: :options macro condition-case-unless-debug var protected-form handlers…
#+begin_deffn
The  macro   ~condition-case-unless-debug~  provides  another  way   to  handle
debugging of such  forms. It behaves exactly like  ~condition-case~, unless the
variable ~debug-on-error~  is non-=nil=, in which  case it does not  handle any
errors at all.
#+end_deffn

Once Emacs  decides that a  certain *handler*  handles the =error=,  it returns
control to that *handler*.

- Emacs unbinds all variable bindings made by binding constructs that are being
  exited,
- and  executes the  cleanups  of  all ~unwind-protect~  forms  that are  being
  exited.
- Once  control arrives  at  the  handler, the  body  of  the handler  executes
  normally.
- After   execution  of   the  handler   body,  execution   returns  from   the
  condition-case form.  All it can do is clean up and proceed.


#+texinfo: @heading @code{error-message-string} Function
#+attr_texinfo: :options error-message-string error-descriptor
#+begin_defun
  This  function  returns  the  /error  message  string/  for  a  given  /error
  descriptor/. It  is useful  if you want  to handle an  error by  printing the
  usual error message for that error.
#+end_defun

#+texinfo: @heading Resemblance to Catch and Throw
Error signaling and  handling have some resemblance to ~throw~  and ~catch~ but
they  are entirely  separate  facilities:  An =error=  cannot  be  caught by  a
~catch~, and a ~throw~ cannot be handled by an error handler.

- using ~throw~ when  there is no suitable ~catch~ signals  an =error= that can
  be handled.

**** Ignoring Errors

#+texinfo: @subsubheading Ignoring Errors Concepts
- ~ignore-errors~ macro
- ~ignore-error~ macro
- ~with-demoted-errors~ macro

#+attr_texinfo: :options Macro ignore-errors body…
#+begin_deffn
  This construct  executes =BODY=,  ignoring any errors  that occur  during its
  execution. If  the execution  is without  error, ~ignore-errors~  returns the
  value of the last form in body; otherwise, it returns =nil=.

  Here’s  the example  at  the  beginning of  this  subsection rewritten  using
  ~ignore-errors~:

  : (ignore-errors
  :    (delete-file filename))
#+end_deffn

#+attr_texinfo: :options Macro ignore-error condition body…
#+begin_deffn
  This macro is  like ~ignore-errors~, but will only ignore  the specific error
  condition specified. =CONDITION= can also be a list of error conditions.

  : (ignore-error end-of-file
  :     (read ""))
#+end_deffn

#+attr_texinfo: :options Macro with-demoted-errors format body…
#+begin_deffn
  This  macro  is  like  a  milder  version  of  ~ignore-errors~.  Rather  than
  suppressing errors  altogether, it converts  them into messages. It  uses the
  string  =FORMAT= to  format the  message.  =FORMAT= should  contain a  single
  ‘%’-sequence; e.g.,  "Error: %S". Use ~with-demoted-errors~  around code that
  is not  expected to signal  errors, but should be  robust if one  does occur.
  Note  that   this  macro   uses  ~condition-case-unless-debug~   rather  than
  ~condition-case~.
#+end_deffn

**** Error Symbols---Condition Names

#+texinfo: @subsubheading Error Symbols Concepts
- =error=
- =error symbol=
- =error conditions=
- =condition names=
- ~define-error~ function
- ~signal~ function

#+texinfo: @heading Errors

#+texinfo: @subheading Error Symbols

#+cindex:error symbol
#+cindex:symbol, error
When you /signal/ an =error=, you specify an /error symbol/ to specify the kind
of =error= you have  in mind. Each =error= has one and  only one /error symbol/
to categorize it.

#+texinfo: @subheading Error Conditions and Condition Names

#+cindex:error conditions
#+cindex:condition names
These  narrow classifications  are grouped  into a  hierarchy of  wider classes
called /error conditions/, identified by  /condition names/. The narrowest such
classes belong to the /error symbols/ themselves: each /error symbol/ is also a
/condition name/. There are also  /condition names/ for more extensive classes,
up to the /condition name/ =error= which takes in all kinds of errors.

Thus,  each ~error~  has one  or more  /condition names/:
- =error=,
- the  /error symbol/  if  that is  distinct  from  =error=,
- and perhaps  some  intermediate classifications.

***** Function ~define-error~ 
#+cindex:parent condition
#+findex:signal
#+attr_texinfo: :options define-error name message &optional parent
#+begin_defun
  Define =NAME= as a new =error= symbol.  =PARENT= is either a signal or a list
  of signals from which it inherits. =MESSAGE=  is a string that will be output
  to the  echo area if such  an =error= is  signaled without being caught  by a
  ~condition-case~.

  : (define-error 'new-error "A new error" 'my-own-errors)

  This  =error=  has  several  /condition names/:  =new-error=,  the  narrowest
  classification; =my-own-errors=, which we  imagine is a wider classification;
  and all the conditions of =my-own-errors= which should include =error=, which
  is the widest of all.

  - PARENT ::

    In order  for a symbol  to be  an /error symbol/,  it must be  defined with
    ~define-error~ which takes a =PARENT= condition (defaults to =error=). This
    =PARENT= defines  the conditions that  this kind  of error belongs  to. The
    transitive set of =PARENTS= always  includes the /error symbol/ itself, and
    the symbol =error=.

  - MESSAGE ::

    In addition to its  parents, the /error symbol/ has a  /message/ which is a
    string to  be printed when  that =error= is  signaled but not  handled. The
    error string should start with a capital  letter but it should not end with
    a period. This is for consistency with the rest of Emacs.


  Only an explicit call to ~signal~ in your code can signal =new-error=.

  : (signal 'new-error '(x y))
  :      error→ A new error: x, y

  This  =error= can  be  handled through  any of  its  /condition names/.  This
  example   handles   =new-error=  and   any   other   errors  in   the   class
  =my-own-errors=:

  #+begin_src elisp
    (condition-case foo
        (bar nil t)
      (my-own-errors nil))
  #+end_src
#+end_defun

***** The Power and Utility of Error /Condition Names/ 

#+cindex:error-conditions property of error
#+cindex:error-message property of error
Internally, the set of parents is  stored in the =error-conditions= property of
the =error= symbol and the message is stored in the =error-message= property of
the =error= symbol.

#+cindex:error condition names
#+cindex:error symbol
The  significant  way that  =errors=  are  classified  is by  their  /condition
names/---the  names used  to match  =errors= with  handlers. An  /error symbol/
serves only  as a convenient  way to specify  the intended /error  message/ and
list of /condition names/.

By  contrast,  using  only  /error symbols/  without  /condition  names/  would
seriously decrease  the power  of ~condition-case~.  /Condition names/  make it
possible to categorize =errors= at various  levels of generality when you write
an error handler.
**** Standard Errors
This is a list of the more  important error symbols in standard Emacs. The list
includes each symbol’s message.

- error :: "error"
- quit :: "Quit"; note that the error symbol =quit= does not have the condition
  =error=, because quitting is not considered an error.
- args-out-of-range :: "Args out of range"
- arith-error :: "Arithmetic error"
- beginning-of-buffer :: "Beginning of buffer"
- buffer-read-only :: "Buffer is read-only"
- circular-list :: "List contains a loop"
- cl-assertion-failed :: "Assertion failed"
- coding-system-error :: "Invalid coding system"
- cyclic-function-indirection :: "Symbol's chain of function indirections contains a loop"
- cyclic-variable-indirection :: "Symbol's chain of variable indirections contains a loop"
- dbus-error :: "D-Bus error"
- end-of-buffer :: "End of buffer"
- end-of-file ::  "End of file  during parsing"; note  that it pertains  to the
  Lisp reader, not to file I/O.
- file-already-exists :: a subcategory of= file-error=
- file-date-error ::  a subcategory of =file-error=; it occurs when ~copy-file~
  tries and fails to set the last-modification time of the output file.
- file-error  ::     We  do not list the /error-strings/ of  this error and its
  subcategories, because the  /error message/ is normally  constructed from the
  =DATA= items  alone when the  error condition =file-error= is  present. Thus,
  the /error-strings/ are not very relevant.
- file-missing :: a subcategory of =file-error=;
- compression-error :: a subcategory of =file-error=;
- file-locked :: a subcategory of =file-error=;
- file-supersession :: a subcategory of =file-error=;
- file-notify-error :: a subcategory of =file-error=;
- ftp-error :: a subcategory of =file-error=;
- invalid-function :: "Invalid function"
- invalid-read-syntax :: "Invalid read syntax" or "Trailing garbage following expression"
- invalid-regexp :: "Invalid regexp"
- mark-inactive :: "The mark is not active now"
- no-catch :: "No catch for tag"
- range-error :: "Arithmetic range error"
- overflow-error :: "Arithmetic overflow error"; a subcategory of =range-error=;
- scan-error :: "Scan error"
- search-failed :: "Search failed"
- setting-constant :: "Attempt to set a constant symbol"
- text-read-only :: "Text is read-only"; a subcategory of =buffer-read-only=;
- undefined-color :: "Undefined color"
- user-error :: the empty string
- user-search-failed :: This  is like =search-failed=, but  doesn’t trigger the
  debugger, like =user-error=.
- void-function :: "Symbol's function definition is void"
- void-variable :: "Symbol's value as variable is void"
- wrong-number-of-arguments :: "Wrong number of arguments"
- wrong-type-argument :: "Wrong type argument"
- unknown-image-type :: "Cannot determine image type"
*** Cleaning Up from Nonlocal Exits

#+texinfo: @subsubheading Error Clean Up Concepts
- ~unwind-protect~ special form
- ~with-temp-buffer~ macro


#+findex:unwind-protect
The ~unwind-protect~ construct is essential whenever you temporarily put a data
structure in an inconsistent state; it  permits you to make the data consistent
again in the event of an error or throw.

#+attr_texinfo: :options unwind-protect body-form cleanup-forms…
#+begin_defun
  ~unwind-protect~   executes   =BODY-FORM=   with   a   guarantee   that   the
  =CLEANUP-FORMS= will  be evaluated if  control leaves =BODY-FORM=,  no matter
  how that happens. =BODY-FORM= may complete normally, or execute a ~throw~ out
  of  the   ~unwind-protect~,  or   cause  an  =error=;   in  all   cases,  the
  =CLEANUP-FORMS= will be evaluated.

  If  =BODY-FORM=  finishes normally,  ~unwind-protect~  returns  the value  of
  =BODY-FORM=, after it evaluates the =CLEANUP-FORMS=.

  If =BODY-FORM= does not finish, ~unwind-protect~ does not return any value in
  the normal sense.

  Only  =BODY-FORM=  is  protected  by  the ~unwind-protect~.  If  any  of  the
  =CLEANUP-FORMS= themselves  exits nonlocally (via  a ~throw~ or  an =error=),
  ~unwind-protect~  is not  guaranteed to  evaluate the  rest of  them. If  the
  failure of  one of the  =CLEANUP-FORMS= has  the potential to  cause trouble,
  then protect it with another ~unwind-protect~ around that form.
#+end_defun

#+texinfo: @heading Macro ~with-temp-buffer~ 

For example, here we make an invisible  buffer for temporary use, and make sure
to kill it before finishing:

#+begin_src elisp
  (let ((buffer (get-buffer-create " *temp*")))
    (with-current-buffer buffer
      (unwind-protect
	  body-form
	(kill-buffer buffer))))
#+end_src

#+findex:with-temp-buffer
Emacs includes  a standard macro  called ~with-temp-buffer~ which  expands into
more or less the code shown above.

#+texinfo: @heading Example of ~unwind-protect~ 

Here is an actual  example derived from an FTP package.  It creates a =process=
to  try  to  establish a  connection  to  a  remote  machine. As  the  function
~ftp-login~ is highly  susceptible to numerous problems that the  writer of the
function  cannot  anticipate, it  is  protected  with  a form  that  guarantees
deletion of the process in the event of failure. Otherwise, Emacs might fill up
with useless subprocesses.

#+begin_src elisp
  (let ((win nil))
    (unwind-protect
	(progn
	  (setq process (ftp-setup-buffer host file))
	  (if (setq win (ftp-login process host user password))
	      (message "Logged in")
	    (error "Ftp login failed")))
      (or win (and process (delete-process process)))))
#+end_src

This example  has a small bug:  if the user types  =C-g= to quit, and  the quit
happens immediately  after the  function ~ftp-setup-buffer~ returns  but before
the variable =process= is set, the process will not be killed. There is no easy
way to fix this bug, but at least it is very unlikely.

* Files---Buffers---Windows---Frames---Terminals
** Files
** Buffers
- BUFFER ::

  A “buffer” is a Lisp object containing text to be edited. Buffers are used to
  hold the contents of files that are  being visited; there may also be buffers
  that  are not  visiting files.  Only one  buffer is  designated the  “current
  buffer” at  any time. Each buffer,  including the current buffer,  may or may
  not be displayed in any windows.

  Buffers appear to Lisp programs as a  special data type. You can think of the
  contents  of  a buffer  as  a  string that  you  can  extend; insertions  and
  deletions may occur in any part of the buffer.

  A Lisp  buffer object contains numerous  pieces of information. Some  of this
  information is directly accessible to the programmer through variables, while
  other information is accessible only through special-purpose functions.

- BUFFER-LOCAL VARIABLES ::

  Buffer-specific  information  that  is   directly  accessible  is  stored  in
  “buffer-local”  variable  bindings,  which   are  variable  values  that  are
  effective only  in a particular  buffer. This  feature allows each  buffer to
  override the values of certain variables. Most major modes override variables
  such as ‘fill-column’ or ‘comment-column’ in this way.

Some functions and variables relate to  visiting files in buffers, while others
relate to the display of buffers in windows.

#+attr_texinfo: :options bufferp object
#+begin_defun
  This function returns ‘t’ if OBJECT is a buffer, ‘nil’ otherwise.
#+end_defun
** Windows
This section describes the functions and variables related to Emacs windows.
*** Concepts of Windows
- WINDOW :: A *window* is an area of the screen that is used to display a buffer.
  Windows are  represented by a special  Lisp object type.

- LIVE WINDOW :: A *live window* is one that is actually displaying a buffer in
  a frame.

- INTERNAL WINDOW :: Not a live window.

- VALID WINDOW   ::

  A valid window is one that is either  live or internal. A valid window can be
  deleted. Then  it is no longer  *valid*, but the Lisp  object representing it
  might be  still referenced from other  Lisp objects. A deleted  window may be
  made valid again by restoring a saved window configuration.

- FRAME ::

  Windows are grouped into frames. Each frame contains at least one window; the
  user can subdivide it into  multiple, non-overlapping windows to view several
  buffers at once. When a window is created, resized, or deleted, the change in
  window space  is taken  from or given  to the adjacent  windows, so  that the
  total area of the frame is unchanged.

- SELECTED WINDOW ::

  In  each frame,  at  any time,  exactly  one Emacs  window  is designated  as
  *selected* within the frame.

- WINDOW TREE ::

  The windows in each frame are organized into a window tree.

  - LEAF NODES :: The leaf nodes of  each window tree are live windows—the ones
    actually displaying buffers.

  - INTERNAL  NODES ::  The  internal nodes  of the  window  tree are  internal
    windows, which are not live.

#+attr_texinfo: :options selected-window
#+begin_defun
  This function returns the selected window (which is always a live window).
#+end_defun

#+attr_texinfo: :options windowp object
#+begin_defun
  Returns t if object is a window, otherwise returns nil.
#+end_defun

#+attr_texinfo: :options window-live-p object
#+begin_defun
  Returns t if object is a live window and nil otherwise.
#+end_defun

#+attr_texinfo: :options window-valid-p object
#+begin_defun
  You can distinguish valid windows from deleted windows with ~window-valid-p~.

  This function returns t if object is a /live window/, or an /internal window/
  in a /window  tree/. Otherwise, it returns nil, including  for the case where
  object is a /deleted window/.
#+end_defun

*** Displaying a Buffer in a Window
** Frames and Terminals
- FRAME ::

  A “frame”  is a  screen object that  contains one or  more Emacs  windows. In
  Emacs Lisp, a “frame object” is a  Lisp object that represents a frame on the
  screen.

  A frame initially  contains a single main window and/or  a minibuffer window;
  you can  subdivide the  main window vertically  or horizontally  into smaller
  windows.

- TERMINAL ::

  A “terminal”  is a  display device  capable of displaying  one or  more Emacs
  frames. In Emacs Lisp, a “terminal object” is a Lisp object that represents a
  terminal.There is no  primitive for creating terminal objects.  There are two
  classes of terminals:
  1. “text  terminals”; non-graphics-capable  displays, including  ‘xterm’ and
    other terminal  emulators. On a  text terminal, each Emacs  frame occupies
    the terminal’s  entire screen; although  you can create  additional frames
    and switch between them, the terminal only shows one frame at a time.
  2. “graphical  terminals”; are managed  by graphical display systems  such as
     the  X  Window   System,  which  allow  Emacs  to   show  multiple  frames
     simultaneously on the same display.

  Each terminal object has the following ATTRIBUTES:

  - *name* of device used by the terminal, e.g. =/dev/tty=

  - terminal and keyboard *coding systems* used on the terminal

  - kind of *display* associated with the terminal
    - x
    - t
    - w32
    - ns
    - pc

  - list of terminal *parameters*

- MULTIPLE TERMINALS ::

  On GNU  and Unix systems, you  can create additional frames  on any available
  terminal,  within a  single Emacs  session, regardless  of whether  Emacs was
  started on a text or graphical  terminal. Emacs can display on both graphical
  and text  terminals simultaneously. This  comes in handy, for  instance, when
  you connect to the same session from several remote locations. *Note Multiple
  Terminals.

*** Frame and Terminal Functions
#+attr_texinfo: :options framep object
#+begin_defun
  This predicate  returns a  non-‘nil’ value  if OBJECT is  a frame,  and ‘nil’
  otherwise. For a  frame, the value indicates which kind  of display the frame
  uses:

  - t :: text terminal
  - x :: x graphical terminal
  - w32 :: MS-Windows graphical terminal
  - ns :: GNUstep or Macintosh Cocoa graphical terminal
  - pc :: MS-DOS terminal
#+end_defun

#+attr_texinfo: :options frame-terminal &optional frame
#+begin_defun
  This function returns  the terminal object that displays  =FRAME=. If =FRAME=
  is ‘nil’ or unspecified, it defaults to the selected frame.
#+end_defun

#+attr_texinfo: :options terminal-live-p object
#+begin_defun
  This predicate  returns a non-‘nil’ value  if =OBJECT= is a  terminal that is
  live (i.e., not deleted), and ‘nil’ otherwise. For live terminals, the return
  value indicates what kind of frames  are displayed on that terminal; the list
  of possible values is the same as for ‘framep’ above.
#+end_defun

#+attr_texinfo: :options terminal-name &optional terminal
#+begin_defun
  This  function returns  the file  name  of the  device used  by TERMINAL.

  - TERMINAL ::

    If =TERMINAL=  is omitted  or ‘nil’,  it defaults  to the  selected frame’s
    terminal.

    =TERMINAL= can also be a frame, meaning that frame’s terminal.
#+end_defun

#+attr_texinfo: :options terminal-list
#+begin_defun
  This function returns a list of all live terminal objects.
#+end_defun

#+attr_texinfo: :options get-device-terminal device
#+begin_defun
  This function returns a terminal whose device name is given by =DEVICE=.

  - DEVICE ::

    If DEVICE is a string, it can be either the file name of a terminal device,
    or the name of an X display  of the form ‘HOST:SERVER.SCREEN’.

    If DEVICE  is a frame, this  function returns that frame’s  terminal;

    ‘nil’ means  the selected frame.

    Finally, if  DEVICE is a terminal  object that represents a  live terminal,
    that terminal is returned.
#+end_defun

#+attr_texinfo: :options delete-terminal &optional terminal force
#+begin_defun
  - TERMINAL ::

    This function deletes all frames on =TERMINAL= and frees the resources used
    by  it.  It runs  the  abnormal  hook ~delete-terminal-functions~,  passing
    =TERMINAL= as  the argument  to each  function. If  TERMINAL is  omitted or
    ‘nil’, it defaults to the selected frame’s terminal. TERMINAL can also be a
    frame, meaning that frame’s terminal.

  - FORCE ::

    Normally, this function signals an error  if you attempt to delete the sole
    active terminal, but if =FORCE= is non-‘nil’, you are allowed to do so.
#+end_defun

*** Creating Frames
Call the function ~make-frame~.

#+attr_texinfo: :options Command make-frame &optional parameters
#+begin_deffn
This function creates and returns a new frame, displaying the current buffer.

- PARAMETERS ::

  an alist  of frame parameters for  the new frame. Each  element of PARAMETERS
  should have the form (NAME . VALUE)

  - (name . STRING) -- frame is named STRING

  - (width . NUMBER) -- frame should be NUMBER characters in width

  - (height . NUMBER) -- frame should be NUMBER text lines high

  - (minibuffer . t) -- the frame should have a minibuffer

  - (minibuffer . nil) -- the frame should have no minibuffer

  - (minibuffer . only) -- the frame should contain only a minibuffer window

  - (minibuffer . WINDOW) -- the frame should use WINDOW as its minibuffer window

  - (window-system . nil) -- the frame should be displayed on a terminal device

  - (window-system . x) -- the frame should be displayed in an X window

  - (display . ":0") -- the frame should appear on display :0

  - (terminal . TERMINAL) -- the frame should use the terminal object TERMINAL

  - any  parameter not  specified in  =PARAMETERS= default  to values  found in
    ~default-frame-alist~.

- HOOKS ::

  - ~before-make-frame-hook~ ::  A normal  hook run  by ‘make-frame’  before it
    creates the frame.

  - ~after-make-frame-functions~ :: An abnormal  hook run by ~make-frame~ after
    it  created  the  frame.   Each  function  in  ~after-make-frame-functions~
    receives one argument, the frame just created.

  - ~server-after-make-frame-hook~ :: A  normal hook run when  the Emacs server
    creates a client frame. When this hook  is called, the created frame is the
    selected one.

- PARAMETER-VARIABLE ::

  - ~frame-inherited-parameters~ ::  This variable specifies the  list of frame
    parameters that a newly created  frame inherits from the currently selected
    frame.
#+end_deffn

* Display of Buffers
Here are some functions, macros, and  user options Relating to the display that
Emacs presents.

** Temporary Displays
*Temporary displays* are used by Lisp programs  to put output into a buffer and
then present it to the user for perusal rather than for editing.

*** Display as a Help Buffer

#+attr_texinfo: :options with-output-to-temp-buffer buffer-name body
#+begin_defun
  Bind ‘standard-output’ to  buffer =BUFFER-NAME=, eval =BODY=,  then show that
  buffer.

  This function  executes the  forms in  =BODY= while  arranging to  insert any
  output they print into the buffer named =BUFFER-NAME=, which is first created
  if necessary, and put  into =Help= mode. It does not  make the buffer current
  for =BODY=.

  - BUFFER-NAME ::

    The string  =BUFFER-NAME= specifies  the temporary  buffer, which  need not
    already exist. The argument  must be a string, not a  buffer. The buffer is
    erased initially (with no questions asked),  and it is marked as unmodified
    after this function exits.

  - BODY ::

    This  function binds  =STANDARD-OUTPUT= to  the temporary  buffer, then  it
    evaluates the  forms in  =BODY=. At  the end of  =BODY=, this  marks buffer
    =BUFFER-NAME= unmodified and  displays it in a window, but  does not select
    it.

    By default, the setup hook puts  the buffer into =Help= mode before running
    =BODY=. If =BODY= does  not change the major mode, the  show hook makes the
    buffer read-only, and scans it for function and variable names to make them
    into clickable cross-references.

  - HOOKS ::

    Several hooks are available for customizing the behavior of this construct;

    - ~temp-buffer-setup-hook~   ::    hook run  before evaluating  =BODY=, and
      =BUFFER-NAME= is current.

    - ~temp-buffer-show-hook~  ::  hook  run  after  displaying  the  temporary
      buffer, and with the temporary buffer being current.

  - RETURN :: The value of the last form in =BODY= is returned.

  - ~temp-buffer-show-function~       ::      If   this  variable  is  non-nil,
    ~with-output-to-temp-buffer~  calls it  as  a  function to  do  the job  of
    displaying a  =help= buffer. The function  gets one argument, which  is the
    buffer it should display.
#+end_defun

*** Macros for Display of Non-help Buffers

 #+attr_texinfo: :options with-temp-buffer-window buffer-or-name action quit-function body
 #+begin_defmac
   As with  ~with-output-to-temp-buffer~, it executes =BODY=  while arranging to
   insert  any output  it  prints  into the  buffer  named =BUFFER-OR-NAME=  and
   displays  that buffer  in some  window. Unlike  ~with-output-to-temp-buffer~,
   however, it does not automatically switch that buffer to =Help= mode.

   - BUFFER-OR-NAME ::

     specifies  the temporary  buffer. It  can be  either a  buffer, which  must
     already exist, or a string, in which case a buffer of that name is created,
     if  necessary.  The buffer  is  marked  as  unmodified and  read-only  when
     ~with-temp-buffer-window~ exits.

   - ACTION ::

     The ACTION argument  can have a non-nil and non-list  value. This means to
     display the buffer in a window other  than the selected one, even if it is
     already  displayed in  the selected  window. Non-interactive  calls should
     always supply a list or nil.

     It passes  the =ACTION= argument  to ~display-buffer~ in order  to display
     the  buffer.  It should  specify  a  buffer  display  action of  the  form
     =(FUNCTIONS . ALIST)=.

     - =FUNCTIONS= is either  an "action function" or a possibly  empty list of
       action functions.  An /action function/  is a function that  accepts two
       arguments:
       1. the  buffer to display;  and
       2. an action  alist.
       Based  on those  arguments, it  should try  to display  the buffer  in a
       window and  return that  window. Action functions  use the  action alist
       passed to them to fine-tune their behaviors.

     - =ALIST= is  a possibly  empty "action  alist". An  /action alist/  is an
       association list mapping symbols to values.

     - ACTION FUNCTIONS :: Action functions and  the action they try to perform
       are:

       - ‘display-buffer-same-window’
       - ‘display-buffer-reuse-window’
       - ‘display-buffer-in-previous-window’
       - ‘display-buffer-use-some-window’
       - ‘display-buffer-pop-up-window’
       - ‘display-buffer-below-selected’
       - ‘display-buffer-at-bottom’
       - ‘display-buffer-pop-up-frame’
       - ‘display-buffer-in-child-frame’
       - ‘display-buffer-no-window’

   - ACTION-ALIST ENTRIES ::

     - ‘inhibit-same-window’
     - ‘inhibit-switch-frame’
     - ‘reusable-frames’
     - ‘pop-up-frame-parameters’
     - ‘window-height’
     - ‘window-width’
     - ‘preserve-size’
     - ‘window-parameters’
     - ‘allow-no-window’
     - ‘body-function’

   - QUIT-FUNCTION ::

     If this argument  is non-nil, it should  be a function that  is called with
     two arguments: the window showing the  buffer and the result of =BODY=. The
     final return value is then whatever ~quit-function~ returns.

   - HOOKS ::

     - ~temp-buffer-window-setup-hook~

     - ~temp-buffer-window-show-hook~
 #+end_defmac

 #+attr_texinfo: :options with-current-buffer-window buffer-or-name action quit-function &rest body
 #+begin_defmac
   Like   ~with-temp-buffer-window~   but   makes  the   buffer   specified   by
   =BUFFER-OR-NAME= current for running =BODY=.
 #+end_defmac

 #+attr_texinfo: :options with-displayed-buffer-window buffer-or-name action quit-function &rest body
 #+begin_defmac
   Like  ~with-current-buffer-window~  but  displays  the  buffer  specified  by
   =BUFFER-OR-NAME= before running =BODY=.
 #+end_defmac

*** Changing the Size of a Temporary Buffer Window
A window showing  a temporary buffer can  be fitted to the size  of that buffer
using the following mode:

#+attr_texinfo: :options {Minor mode} temp-buffer-resize-mode
#+begin_defvr
  When  this minor  mode is  enabled, windows  showing a  temporary buffer  are
  automatically resized to fit their buffer’s contents.

  A window  is resized if  and only  if it has  been specially created  for the
  buffer.

  By default, this mode uses  ~fit-window-to-buffer~ (see Resizing Windows) for
  resizing. You  can specify  a different function  by customizing  the options

  - ~temp-buffer-max-height~ and
  - ~temp-buffer-max-width~.
#+end_defvr

#+attr_texinfo: :options {User option} temp-buffer-max-height
#+begin_defvr
  This option specifies the maximum height  (in lines) of a window displaying a
  temporary buffer  when ~temp-buffer-resize-mode~ is  enabled.

  It can  also be  a function  to be  called to  choose the  height for  such a
  buffer.  It gets  one  argument, the  buffer, and  should  return a  positive
  integer.
#+end_defvr

#+attr_texinfo: :options {User option} temp-buffer-max-width
#+begin_defvr
  This option specifies the maximum width of a window (in columns) displaying a
  temporary buffer when temp-buffer-resize-mode is enabled.

  It can also be a function to be called to choose the width for such a buffer.
  It gets one argument, the buffer, and should return a positive integer.
#+end_defvr

*** Momentary Display
 #+attr_texinfo: :options momentary-string-display string position &optional char message
 #+begin_defun
   This function momentarily displays string in the current buffer at position.

   - STRING :: string to display in current buffer

   - POS :: Position in current buffer to display string at.  =POS= can be a
     marker, in which case only its value is used; its buffer is ignored.

   - EXIT-CHAR ::  Optional  third arg =EXIT-CHAR= can be a  character, event or
     event description  list, defaulting to  =SPC=. If  the next input  event is
     =CHAR=, it is  ignored and the function returns, otherwise  it is available
     as input.

   - MESSAGE  :: If  non-nil,  display  the =MESSAGE=  in  the  echo area  while
     =STRING= is displayed. If nil, instructions to type =CHAR= are displayed in
     the echo area.

   - RETURN :: This function’s return value is not meaningful.
 #+end_defun

* Interacting with the System
:PROPERTIES:
:appendix: t
:END:
** Processes
:PROPERTIES:
:appendix: t
:END:

#+texinfo:@heading Subprocesses

#+cindex:process
#+cindex:subprocess
#+cindex:child process
#+cindex:parent process
#+cindex:synchronous process
#+cindex:asynchronous process
Emacs Lisp programs can invoke other programs in processes of their own.  These
are called “subprocesses” or “child processes” of the Emacs process, which is
their “parent process”.  A subprocess of Emacs may be “synchronous” or
“asynchronous”, depending on how it is created.  When you create a synchronous
subprocess, the Lisp program waits for the subprocess to terminate before
continuing execution.  When you create an asynchronous subprocess, it can run
in parallel with the Lisp program.  This kind of subprocess is represented
within Emacs by a Lisp object which is also called a “process”.  Lisp programs
can use this object to communicate with the subprocess or to control it.

#+attr_texinfo: :options processp object
#+begin_defun
This function returns ‘t’ if OBJECT represents an Emacs process object, ‘nil’
     otherwise.  The process object can represent a subprocess running a
     program or a connection of any supported type.
#+end_defun

#+texinfo:@heading System Processes

#+cindex:system process
In addition to subprocesses of the current Emacs session, you can also access
other processes running on your machine.  These are /system processes/.

*** Creating Subprocesses---In General

#+cindex:new subprocess, create
There are three primitives that create a new subprocess in which to run a
program.

#+cindex:@code{call-process}
#+cindex:@code{call-process-region}
#+cindex:@code{make-process}
#+attr_texinfo: :indic code
- call-process ::

  creates a synchronous process

- call-process-region ::

  creates a synchronous process

- make-process ::

  creates an asynchronous process and returns a process object


The three functions are called in similar fashions; their common arguments are
described here first.

#+texinfo:@heading The Program to Run

In all cases, the functions *specify the program to be run*.

#+texinfo:@subheading exec-path

#+vindex:exec-path
#+vindex:PATH
#+vindex:default-directory
The filename may contain =~=, =.=, and =..=.  If the file name is relative, the
variable ‘exec-path’ contains a list of directories to search.  Emacs
initializes ‘exec-path’ when it starts up, based on the value of the
environment variable ‘PATH’.  ~nil~ in the list refers to ~default-directory~.
The variable ~exec-directory~ can also supply a directory to search.

Your ~exec-path~ has the contents:

#+name:your-exec-path
#+header: :results value :exports results
#+begin_src emacs-lisp
exec-path
#+end_src

#+attr_texinfo: :options exec-directory
#+begin_defun
The value of this variable is a string, the name of a directory that contains
     programs that come with GNU Emacs and are intended for Emacs to invoke.
     The program ‘movemail’ is an example of such a program; Rmail uses it to
     fetch new mail from an inbox.
#+end_defun

Your ~exec-directory~ has the value:

#+name:your-exec-directory
#+header: :results value :exports results
#+begin_src emacs-lisp
exec-directory
#+end_src

Use the function ‘substitute-in-file-name’ to perform environment variable
substitutions (`$HOME').

#+attr_texinfo: :options substitute-in-file-name filename
#+begin_defun
Substitute environment variables referred to in FILENAME.
‘$FOO’ where FOO is an environment variable name means to substitute
the value of that variable.

    (substitute-in-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"
#+end_defun

#+texinfo:@heading Filename Arguments

#+cindex:filename arguments
Each of the subprocess-creating functions has a BUFFER-OR-NAME argument that
specifies where the output from the program will go.  It should be a buffer or
a buffer name; if it is a buffer name, that will create the buffer if it does
not already exist.  It can also be ‘nil’, which says to discard the output,
unless a custom filter function handles it.

For synchronous processes, you can send the output to a file instead of a
buffer.

#+texinfo:@heading Standard Streams

#+cindex:standard streams
#+cindex:standard output, error, input
#+cindex:streams, standard
#+cindex:redirection, standard streams
By default, both standard output and standard error streams go to the same
destination, but all the 3 primitives allow optionally to direct the standard
error stream to a different destination.

#+texinfo:@heading Process Command-Line Arguments

All three of the subprocess-creating functions allow to specify command-line
arguments for the process to run.  The command-line arguments must all be
strings, and they are supplied to the program as separate argument strings.

- For ‘call-process’ and ‘call-process-region’, these come in the form of a
  ‘&rest’ argument, ARGS.

- For ‘make-process’, both the program to run and its command-line arguments
  are specified as a list of strings.


#+texinfo:@heading Inheriting Environment

#+cindex:subprocess environment
The subprocess inherits its environment from Emacs, but you can specify
overrides for it with ‘process-environment’.


#+vindex:default-directory
The subprocess gets its current directory from the value of
‘default-directory’.

**** Specifying Shell Arguments

#+attr_texinfo: :options shell-quote-argument argument
#+begin_defun
This function returns a string that represents, in shell syntax, an argument
     whose actual contents are ARGUMENT.  It should work reliably to
     concatenate the return value into a shell command and then pass it to a
     shell for execution.  The function is designed to work with the syntax of
     your system’s standard shell.

     Here’s an example of using ‘shell-quote-argument’ to construct a
     shell command:

          (concat "diff -u "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))
#+end_defun

#+texinfo:@heading Command-Line Argument Processing

The following two functions are useful for combining a list of individual
command-line argument strings into a single string, and taking a string apart
into a list of individual command-line arguments.

#+attr_texinfo: :options combine-and-quote-strings list-of-strings &optional separator
#+begin_defun
     This function concatenates LIST-OF-STRINGS into a single string, quoting
     each string as necessary.  It also sticks the SEPARATOR string between
     each pair of strings; if SEPARATOR is omitted or ‘nil’, it defaults to ‘"
     "’.  The return value is the resulting string.

     The strings in LIST-OF-STRINGS that need quoting are those that include
     SEPARATOR as their substring.  Quoting a string encloses it in double
     quotes ‘"..."’.  In the simplest case, if you are consing a command from
     the individual command-line arguments, every argument that includes
     embedded blanks will be quoted.
#+end_defun

#+attr_texinfo: :options split-string-and-unquote string &optional separators
#+begin_defun
     This function splits STRING into substrings at matches for the regular
     expression SEPARATORS, like ‘split-string’ does.  In addition, it removes
     quoting from the substrings.  It then makes a list of the substrings and
     returns it.
#+end_defun

*** Creating Synchronous Subprocesses

After a “synchronous process” is created, Emacs waits for the process to
terminate before continuing.  While Emacs waits for the synchronous subprocess
to terminate, the user can quit by typing ‘C-g’.  The first ‘C-g’ tries to kill
the subprocess with a ‘SIGINT’ signal; but it waits until the subprocess
actually terminates before quitting.  If during that time the user types
another ‘C-g’, that kills the subprocess instantly with ‘SIGKILL’ and quits
immediately.  The synchronous subprocess functions return an indication of how
the process terminated.

**** call-process---a primitive

#+attr_texinfo: :options call-process program &optional infile destination display &rest args
#+begin_defun
     This function calls PROGRAM and waits for it to finish.

     The current working directory of the subprocess is set to the current
     buffer’s value of ‘default-directory’ if that is local (as determined by
     ‘unhandled-file-name-directory’), or "~" otherwise.  If you want to run a
     process in a remote directory use ‘process-file’.

     #+attr_texinfo: :indic @var
     - infile :: The standard input for the new process comes from file INFILE
       if INFILE is not ‘nil’, and from the null device otherwise.
     - destination :: The argument DESTINATION says where to put the process
       output.  Here are the possibilities:
       #+attr_texinfo: :indic b
       - a buffer ::

       - a buffer name (a string) ::

       - t :: Insert the output in the current buffer, before point.

       - nill :: Discard the output

       - 0 :: Discard the output, and return ‘nil’ immediately without waiting
         for the subprocess to finish.

       - (:file FILE-NAME) :: Send the output to the file name specified,
         overwriting it if it already exists.

       - (REAL-DESTINATION ERROR-DESTINATION) :: Keep the standard output
         stream separate from the standard error stream; deal with the ordinary
         output as specified by REAL-DESTINATION, and dispose of the error
         output according to ERROR-DESTINATION.  If ERROR-DESTINATION is ‘nil’,
         that means to discard the error output, ‘t’ means mix it with the
         ordinary output, and a string specifies a file name to redirect error
         output into.

         You can’t directly specify a buffer to put the error output in; that
         is too difficult to implement.  But you can achieve this result by
         sending the error output to a temporary file and then inserting the
         file into a buffer when the subprocess finishes.

     - display :: If DISPLAY is non-‘nil’, then ‘call-process’ redisplays the
       buffer as output is inserted.  Otherwise the function ‘call-process’
       does no redisplay, and the results become visible on the screen only
       when Emacs redisplays that buffer in the normal course of events.

     - args :: The remaining arguments, ARGS, are strings that specify command
       line arguments for the program.  Each string is passed to PROGRAM as a
       separate argument.

     - Return Value :: The value returned by ‘call-process’ (unless you told it
       not to wait) indicates the reason for process termination.  A number
       gives the exit status of the subprocess; 0 means success, and any other
       value means failure.  If the process terminated with a signal,
       ‘call-process’ returns a string describing the signal.  If you told
       ‘call-process’ not to wait, it returns ‘nil’.

#+end_defun
**** call-process-region---a primitive

#+attr_texinfo: :options call-process-region start end program &optional delete destination display &rest args
#+begin_defun
     This function sends the text from START to END as standard input to a
     process running PROGRAM.  It deletes the text sent if DELETE is non-‘nil’;
     this is useful when DESTINATION is ‘t’, to insert the output in the
     current buffer in place of the input.

     #+attr_texinfo: :indic var
     - destination, display ::

       The arguments DESTINATION and DISPLAY control what to do with the output
       from the subprocess, and whether to update the display as it comes in.
       For details, see the description of ‘call-process’, above.  If
       DESTINATION is the integer 0, ‘call-process-region’ discards the output
       and returns ‘nil’ immediately, without waiting for the subprocess to
       finish.

     - args ::

       The remaining arguments, ARGS, are strings that specify command line
       arguments for the program.

     - Return Value ::

       The return value of ‘call-process-region’ is just like that of
       ‘call-process’: ‘nil’ if you told it to return without waiting;
       otherwise, a number or string which indicates how the subprocess
       terminated.
#+end_defun

#+texinfo:@heading Example using ~call-process-region~

In the following example, we use ~call-process-region~ to run the ~cat~
utility, with standard input being the first five characters in buffer =foo=
(the word =input=).  ~cat~ copies its standard input into its standard output.
Since the argument DESTINATION is ‘t’, this output is inserted in the current
buffer.

#+begin_example
---------- Buffer: foo ----------
input★
---------- Buffer: foo ----------

(call-process-region 1 6 "cat" nil t)
     ⇒ 0

---------- Buffer: foo ----------
inputinput★
---------- Buffer: foo ----------
#+end_example
**** call-process-shell-command

#+attr_texinfo: :options call-process-shell-command command &optional infile destination display
#+begin_defun
#+attr_texinfo: :indic var
- COMMAND :: This function executes the shell command COMMAND synchronously.


The other arguments are handeled as in [[*call-process---a primitive][~call-process~]].
#+end_defun

**** call-shell-region

#+attr_texinfo: :options call-shell-region start end command &optional delete destination
#+begin_defun
This function sends the text from START to END as standard input to an inferior
shell running COMMAND.  This function is similar than ~call-process-region~,
with process being a shell.

The arguments DELETE, DESTINATION and the return value are like in
~call-process-region~.
#+end_defun

**** shell-command-to-string

#+findex:shell-command-to-string
This function executes COMMAND (a string) as a shell command, then returns the
command’s output as a string.

**** process-lines

#+attr_texinfo: :options process-lines program &rest args
#+begin_defun
This function runs PROGRAM, waits for it to finish, and returns its output as a
list of strings.  Each string in the list holds a single line of text output by
the program; the end-of-line characters are stripped from each line.

The arguments beyond PROGRAM, ARGS, are strings that specify command-line
arguments with which to run the program.

This function works by calling [[*call-process---a primitive][~call-process~]], so program output is decoded in
the same way as for ~call-process~.
#+end_defun

**** process-file

#+attr_texinfo: :options process-file program &optional infile buffer display &rest args
#+begin_defun
      This function processes files synchronously in a separate process.  It is
     similar to ~call-process~, but may invoke a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Magic-File-Names.html#Magic-File-Names][file handler]] based on the
     value of the variable ~default-directory~, which specifies the current
     working directory of the subprocess.

     The arguments are handled in almost the same way as for ~call-process~,
     with the following differences:

     1. Some file handlers may not support all combinations and forms of the
        arguments INFILE, BUFFER, and DISPLAY.  For example, some file handlers
        might behave as if DISPLAY were ‘nil’, regardless of the value actually
        passed.  As another example, some file handlers might not support
        separating standard output and error output by way of the BUFFER
        argument.

     2. If a file handler is invoked, it determines the program to run based on
        the first argument PROGRAM.  For instance, suppose that a handler for
        remote files is invoked.  Then the path that is used for searching for
        the program might be different from ‘exec-path’.

     3. The second argument INFILE may invoke a file handler.  The file handler
        could be different from the handler chosen for the ‘process-file’
        function itself.  (For example, ‘default-directory’ could be on one
        remote host, and INFILE on a different remote host.  Or
        ‘default-directory’ could be non-special, whereas INFILE is on a remote
        host.)

     4. If BUFFER is a list of the form ‘(REAL-DESTINATION ERROR-DESTINATION)’,
        and ERROR-DESTINATION names a file, then the same remarks as for INFILE
        apply.

     5. The remaining arguments (ARGS) will be passed to the process verbatim.
        Emacs is not involved in processing file names that are present in
        ARGS.  To avoid confusion, it may be best to avoid absolute file names
        in ARGS, but rather to specify all file names as relative to
        ‘default-directory’.  The function ‘file-relative-name’ is useful for
        constructing such relative file names.  Alternatively, you can use
        ‘file-local-name’ (*note Magic File Names::) to obtain an absolute file
        name as seen from the remote host’s perspective.
#+end_defun
**** process-file-shell-command

#+findex:process-file-shell-command
This function is like ~call-process-shell-command~, but uses ~process-file~
internally.  Depending on ~default-directory~, COMMAND can be executed also on
remote hosts.

**** process-file-side-effects---a variable

#+attr_texinfo: :options process-file
#+begin_defvar
This variable indicates whether a call of ~process-file~ changes remote files.

By default, this variable is always set to ‘t’, meaning that a call of
~process-file~ could potentially change any file on a remote host.  When set to
‘nil’, a file handler could optimize its behavior with respect to remote file
attribute caching.  You should only ever change this variable with a
let-binding; never with ‘setq’.
#+end_defvar

*** Creating Asynchronous Subprocesses

#+cindex:asynchronous process
#+cindex:process, asynchronous
In this section, we describe how to create an “asynchronous process”.  After an
asynchronous process is created, it runs in parallel with Emacs, and Emacs can
communicate with it using the functions described in the following sections.

#+texinfo:@heading Controlling an Asynchronous Process

#+cindex:pty
#+cindex:pseudo-terminal
#+cindex:pipe
#+vindex:process-connection-type
An asynchronous process is controlled either via a “pty” (pseudo-terminal) or a
“pipe”.  The choice of pty or pipe is made when creating the process, by
default based on the value of the variable ‘process-connection-type’ (see
below).

#+texinfo:@subheading ptys

If available, ptys are usually preferable for processes visible to the user, as
in Shell mode, because they allow for job control (‘C-c’, ‘C-z’, etc.) between
the process and its children, and because interactive programs treat ptys as
terminal devices, whereas pipes don’t support these features.  The total number
of ptys is limited on many systems, and it is good not to waste them
unnecessarily.

#+texinfo:@subheading pipes

However, for subprocesses used by Lisp programs for internal purposes (i.e., no
user interaction with the subprocess is required), where significant amounts of
data need to be exchanged between the subprocess and the Lisp program, it is
often better to use a pipe, because pipes are more efficient.

**** make-process---a primitive

#+attr_texinfo: :options &rest args
#+begin_defun
This function is the basic low-level primitive for starting asynchronous
subprocesses.  It returns a process object representing the subprocess.

Compared to the more high-level ~start-process~, described below, it takes
keyword arguments, is more flexible, and allows to specify process filters and
sentinels in a single call.

- ARGS :: The arguments ARGS are a list of keyword/argument pairs.  Omitting a
  keyword is always equivalent to specifying it with value ‘nil’.  Here are the
  meaningful keywords:

  - :name NAME :: Use the string NAME as the process name; if a process with
    this name already exists, then NAME is modified (by appending ‘<1>’, etc.)
    to be unique.

  - :buffer BUFFER :: Use BUFFER as the process buffer.  If the value is ‘nil’,
    the subprocess is not associated with any buffer.

  - :command COMMAND :: Use COMMAND as the command line of the process.  The value
          should be a list starting with the program’s executable file
          name, followed by strings to give to the program as its
          arguments.  If the first element of the list is ‘nil’, Emacs
          opens a new pseudoterminal (pty) and associates its input and
          output with BUFFER, without actually running any program; the
          rest of the list elements are ignored in that case.

  - :coding CODING :: If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.  The coding system used for encoding the data written
          to the program is also used for encoding the command-line
          arguments (but not the program itself, whose file name is
          encoded as any other file name;

  - :connection-type TYPE :: Initialize the type of device used to communicate with the
          subprocess.  Possible values are ‘pty’ to use a pty, ‘pipe’ to
          use a pipe, or ‘nil’ to use the default derived from the value
          of the ‘process-connection-type’ variable.
          #+cindex:@{:stderr} parameter
          This parameter and the value of ‘process-connection-type’ are ignored
    if a non-‘nil’ value is specified for the ‘:stderr’ parameter; in that
    case, the type will always be ‘pipe’.

  - :noquery QUERY-FLAG :: Initialize the process query flag to QUERY-FLAG.

  - :stop STOPPED :: If STOPPED is non-‘nil’, start the process in the stopped
    state.

  - :filter FILTER :: Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be overridden
          later.

  - :sentinel SENTINEL :: Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          overridden later.
    #+cindex:@code{:stderr} keyword
  - :stderr STDERR :: Associate STDERR with the standard error of the process.  A
          non-‘nil’ value should be either a buffer or a pipe process
          created with ‘make-pipe-process’, described below.


#+findex:process-contact
The original argument list, modified with the actual connection information, is
available via the ~process-contact~ function.

#+vindex:default-directory
The current working directory of the subprocess is set to the current buffer’s
value of ‘default-directory’ if that is local (as determined by
‘unhandled-file-name-directory’), or "~" otherwise.  If you want to run a
process in a remote directory use ~start-file-process~.
#+end_defun

**** make-pipe-process

#+attr_texinfo: :options &rest args
#+begin_defun
This function creates a bidirectional pipe which can be attached to a child
process.  This is useful with the =:stderr= keyword of ~make-process~.  The
function returns a process object.

- ARGS :: The arguments ARGS are a list of keyword/argument pairs.  Omitting
     a keyword is always equivalent to specifying it with value ‘nil’.

     Here are the meaningful keywords:

  - :name NAME :: Use the string NAME as the process name.  As with
       ‘make-process’, it is modified if necessary to make it unique.

  - :buffer BUFFER :: Use BUFFER as the process buffer.

  - :coding CODING :: If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.

          If CODING is ‘nil’, the default rules for finding the coding
          system will apply.

  - :noquery QUERY-FLAG :: Initialize the process query flag to QUERY-FLAG.

  - :stop STOPPED :: If STOPPED is non-‘nil’, start the process in the stopped
          state.  In the stopped state, a pipe process does not accept
          incoming data, but you can send outgoing data.  The stopped
          state is set by ‘stop-process’ and cleared by
          ‘continue-process’

  - :filter FILTER :: Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be changed later.

  - :sentinel SENTINEL :: Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          changed later.


#+findex:process-contact
The original argument list, modified with the actual connection information, is
available via the ‘process-contact’ function.

#+end_defun

**** start-process

#+attr_texinfo: :options start-process name buffer-or-name program &rest args
#+begin_defun
This function is a higher-level wrapper around ‘make-process’, exposing an
interface that is similar to [[*call-process---a primitive][~call-process~]].  It creates a new asynchronous
subprocess and starts the specified PROGRAM running in it.  It returns a
process object that stands for the new subprocess in Lisp.

- NAME :: The argument NAME specifies the name
     for the process object; as with ‘make-process’, it is modified if
     necessary to make it unique.

- BUFFER-OR-NAME :: The buffer BUFFER-OR-NAME is the buffer to associate with
  the process.

- PROGRAM :: If PROGRAM is ‘nil’, Emacs opens a new pseudoterminal (pty) and
     associates its input and output with BUFFER-OR-NAME, without
     creating a subprocess.  In that case, the remaining arguments ARGS
     are ignored.

- ARGS :: The rest of ARGS are strings that specify command line arguments
     for the subprocess.
#+end_defun

**** start-file-process

#+attr_texinfo: :options start-file-process name buffer-or-name program &rest args
#+begin_defun
Like ‘start-process’, this function starts a new asynchronous subprocess
running PROGRAM in it, and returns its process object.

The difference from ‘start-process’ is that this function may invoke a file
handler based on the value of ‘default-directory’.  This handler ought to run
PROGRAM, perhaps on the local host, perhaps on a remote host that corresponds
to ‘default-directory’.  In the latter case, the local part of
‘default-directory’ becomes the working directory of the process.
#+end_defun

**** start-process-shell-command

#+attr_texinfo: :options start-process-shell-command name buffer-or-name command
#+begin_defun
This function is like ~start-process~, except that it uses a shell to execute
the specified COMMAND.

- COMMAND :: The argument COMMAND is a shell command string.


#+vindex:shell-file-name
The variable ~shell-file-name~ specifies which shell to use.

#+cindex:wildcards
#+findex:shell-quote-argument
The point of running a program through the shell, rather than directly with
~make-process~ or ~start-process~, is so that you can employ shell features
such as wildcards in the arguments.  It follows that if you include any
arbitrary user-specified arguments in the command, you should quote them with
[[*Specifying Shell Arguments][~shell-quote-argument~]] first, so that any special shell characters do _not_
have their special shell meanings.
#+end_defun

**** start-file-process-shell-command

#+attr_texinfo: :options start-file-process-shell-command name buffer-or-name command
#+begin_defun
This function is like ~start-process-shell-command~, but uses
~start-file-process~ internally.  Because of this, COMMAND can also be executed
on remote hosts, depending on ~default-directory~.
#+end_defun

**** process-connection-type---a variable

#+attr_texinfo: :options process-connection-type
#+begin_defvar
This variable controls the type of device used to communicate with asynchronous
subprocesses.  If it is non-‘nil’, then ptys are used, when available.
Otherwise, pipes are used.  The value of ‘process-connection-type’ takes effect
when ‘make-process’ or ‘start-process’ is called.  So you can specify how to
communicate with one subprocess by binding the variable around the call to
these functions.

#+cindex:@code{:stderr} parameter
Note that the value of this variable is ignored when ‘make-process’ is called
with a non-‘nil’ value of the ‘:stderr’ parameter; in that case, Emacs will
communicate with the process using pipes.  It is also ignored if ptys are
unavailable (MS-Windows).

#+findex:process-tty-name
To determine whether a given subprocess actually got a pipe or a pty, use the
function ~process-tty-name~.
#+end_defvar
** Time
*** Current Time
#+texinfo: @heading Functions on this Page
#+texinfo: @subheading @code{current-time-string}
#+texinfo: @subheading @code{current-time}
#+texinfo: @subheading @code{float-time}
#+texinfo: @subheading @code{time-to-seconds}

#+findex:current-time-string
#+attr_texinfo: :options current-time-string &optional TIME ZONE
#+begin_defun
 =(current-time-string) => "Fri Nov  1 15:59:49 2019"=

 Returns the current time[fn:3] as a human-readable string. The format does not
 vary for  the initial  part of  the string,  which contains  the day  of week,
 month, day of month,  and time of day in that order:  the number of characters
 used for these fields  is always the same. It is  typically more convenient to
 use  ~format-time-string~   than  to  extract   fields  from  the   output  of
 ~current-time-string~.

 The optional argument =ZONE= defaults to the current time zone rule.
#+end_defun

#+findex:current-time
#+attr_texinfo: :options current-time
#+begin_defun

 This function returns the current time as a Lisp timestamp in the form[fn:2]:
 - =(high low micro pico)=
#+end_defun

#+findex:float-time
#+findex:time-to-seconds
#+attr_texinfo: :options float-time &optional TIME
#+begin_defun
 This function returns  the current time as a floating-point  number of seconds
 since the epoch. Since  the result is floating point, it may  not be exact. Do
 not use this function if precise time stamps are required.

 ~time-to-seconds~ is an alias for this function.
#+end_defun

**** Lisp Timestamp

#+cindex:Lisp timestamp
#+cindex:timestamp, Lisp
#+cindex:absolute time
#+cindex:time, absolute
#+cindex:epoch
Many functions return /Lisp timestamp/ values  that count seconds, and that can
represent  absolute time  by counting  seconds  since the  epoch of  1970-01-01
00:00:00 UTC.

Traditionally Lisp timestamps  were integer pairs. Things have  changed and now
programs ordinarily should not depend on  the current default form. You can use
the ~time-convert~ function to convert it to the needed form.

#+texinfo: @heading Three Forms of Lisp Timestamp Values

Each of these represents a number of seconds.

 - integer :: simplest, but cannot represent subsecond timestamps

 - pair of   integers :: =(ticks .  hz)= This represents =ticks/hz=  seconds. A
   common value for =hz= is 1000000000, for a nanosecond-resolution clock.

 - list of 4 integers :: =(high low micro pico)=
   - This represents the number of seconds using the formula:
     - =high * 2**16 + low + micro * 10**-6 + pico * 10**-12=
   - =low= -- 0 \le low \lt 65536
   - =micro= -- 0 \le micro \lt 1000000
   - =pico= -- 0 \le pico \le 1000000 (multiple of 1000s)

#+texinfo: More General Time Value Formats

Function arguments accept a more general /time value/ format.

 - =NIL= representing the current time
 - Lisp timestamp
 - Truncated Lisp timestamp; missing values are zero;
   - =(high low micro)= or
   - =(high low)=
 - floating-point number representing seconds

#+texinfo: Conversion of Lisp Timestamp Values into Calendrical and Other Forms

Time values can be  converted to and from calendrical and  other forms. Some of
these conversions  rely on operating system  functions that limit the  range of
possible time values.

 - human-readable string -- ~format-time-string~
 - Lisp timestamp -- ~time-convert~
 - other forms -- ~decode-time~, ~float-time~

**** Time Zones
#+texinfo: @heading Default Time Zone
#+cindex:time zone, default
#+cindex:TZ environment variable
#+cindex:system wall clock time
The default time  zone is determined by the =TZ=  environment variable. If =TZ=
is  not in  the environment,  Emacs uses  system wall  clock time,  which is  a
platform-dependent default time zone.

#+cindex:Universal Time
You can tell Emacs to default to Universal Time with =(setenv "TZ" "UTC0")=.

#+texinfo: TZ Strings

#+cindex:tzdata database
The  set of  supported =TZ=  strings is  system-dependent. GNU  and many  other
systems  support the  =tzdata= database  ([[https://en.wikipedia.org/wiki/Tz_database][tzdata]]). GNU  and most  other systems
support  POSIX-style =TZ=  strings.  All systems  support  the string  ‘"UTC0"’
meaning Universal Time.

#+texinfo: Functions Using Time Zone

Functions that convert to and from local time accept an optional time zone rule
argument, which specifies  the conversion’s time zone and  daylight saving time
history.

 - =NIL= :: the conversion uses Emacs’s default time zone
 - =t= :: the conversion uses Universal Time
 - =wall= :: the conversion uses the system wall clock time
 - string :: the conversion uses the  time zone rule equivalent to setting =TZ=
   to that string
 - list =(offset abbr)= :: where =offset=  is an integer number of seconds east
   of Universal Time and  =abbr= is a string, the conversion  uses a fixed time
   zone with the given offset and abbreviation
 - integer :: An integer offset is treated as if it were =(offset abbr)=, where
   =abbr= is a numeric abbreviation on POSIX-compatible platforms

#+attr_texinfo: :options current-time-zone &optional TIME ZONE
#+begin_defun
 This function returns a list describing the time zone that the user is in.

 The value has the form =(offset abbr)=. Here =offset= is an integer giving the
 number of  seconds ahead  of Universal  Time (east  of Greenwich).  A negative
 value means west  of Greenwich. Both elements can change  when daylight saving
 time begins or ends;
#+end_defun

*** Time Conversion

#+cindex:calendrical information
#+cindex:Gregorial calendare
Functions  that  convert time  values  to  Lisp  timestamps or  to  calendrical
information.  Calendrical   conversion  functions  always  use   the  Gregorian
calendar, even  for dates  before the Gregorian  calendar was  introduced. Year
numbers count the number of years since the  year 1 BC, and do not skip zero as
traditional Gregorian years do; for example, the year number -37 represents the
Gregorian year 38 BC.

#+texinfo: @heading Time Conversion Functions

#+texinfo: @subheading @code{time-convert}---Time Value to Lisp Timestamp

#+findex:time-convert
#+attr_texinfo: :options time-convert TIME &optional FORM
#+begin_defun
 This function converts a time value into a Lisp timestamp.

 : (time-convert nil nil)
 is equivalent to
 : (current-time)
 but the latter is a bit faster.

 - FORM :: The optional form argument specifies the timestamp form to be
   returned.
   - =’integer= :: this function returns an integer count of seconds.
   - positive  integer ::  it specifies  a  clock frequency  and this  function
     returns an integer-pair timestamp =(ticks . form)=.
   - =t=   ::  this  function  treats it  as a  positive  integer suitable  for
     representing the  timestamp; for example,  it is treated as  1000000000 if
     time is =nil= and the platform timestamp has nanosecond resolution.
   - =’list= ::  this function returns an integer list =(high low micro pico)=.
   - =NIL= :: currently acts like =’list=[fn:4]

 - TIME ::
   - form  is =t=  ::  When form  is  =t=,  conversion is  always  exact so  no
     truncation occurs, and the returned clock  resolution is no less than that
     of time.

   - inexact :: if time cannot  be represented exactly, conversion truncates it
     toward minus infinity.

   - infinite or =NaN= :: this function signals an error

     By way of  contrast, ~float-time~ can convert any Lisp  time value without
     signaling an error, although the result might not be exact.
#+end_defun

#+texinfo: @subheading @code{decode-time}---Time Value to Calendrical Info

#+findex:decode-time
#+attr_texinfo: :options decode-time &optional TIME ZONE FORM
#+begin_defun
 This function converts a time value into calendrical information of the form:
 : (seconds minutes hour day month year dow dst utcoff)

 - TIME :: Defaults to the current time.

 - ZONE :: Defaults to the current time zone rule.

 - FORM :: Controls the form of the returned =seconds= element.

   The =seconds= element is a Lisp  timestamp that is nonnegative and less than
   61; it is less than 60 except during positive leap seconds

   If the optional  =form= argument is =t=, seconds uses  the same precision as
   time;

   If =form= is =’integer=, =seconds= is truncated to an integer.

   If =form= is omitted or =nil=, it currently defaults to integer[fn:5]

 - VALUE :: The return value is a list of nine elements:
   : (seconds minutes hour day month year dow dst utcoff)
   - seconds: past the minute
   - minutes: past the hour--- 0 \le minutes \le 59
   - hour: of day--- 0 \le hour \le 23
   - day: of month--- 1 \le day \le 31
   - month: of year--- 1 \le month \le 12
   - year: an integer \gt 1900
   - dow: an integer representing the day of  week--- 0 \le dow \le 6 (0 stands
     for Sunday)
   - dst: =t= if daylight savings time is in effect, =NIL= if not, -1 if
     unavailable
   - utcoff:  an integer  representing the  Universal Time  offset in  seconds,
     .i,e, number of seconds east of Greenwich

 - Accessors and  Setters :: To access (or alter) the elements in the =TIME=
   value, these accessors can be used.
   - ~decoded-time-second~
   - ~decoded-time-minute~
   - ~decoded-time-hour~
   - ~decoded-time-day~
   - ~decoded-time-month~
   - ~decoded-time-year~
   - ~decoded-time-weekday~
   - ~decoded-time-dst~
   - ~decoded-time-zone~
#+end_defun

#+texinfo: @subheading @code{decoded-time-add}

#+findex:decoded-time-add
#+attr_texinfo: :options decoded-time-add TIME DELTA
#+begin_defun
 This  function takes  a  /decoded time  structure/ and  adds  =DELTA= (also  a
 /decoded  time structure/)  to  it.

 - DELTA ::

   Elements in =DELTA= that  are =nil= are ignored. Fields are  added in a most
   to  least significant  order.  The  values in  =DELTA=  can  be negative  to
   subtract values instead.

   For instance, if you want “same time next month”, you could say:

    #+begin_src elisp
      (let ((time (decode-time nil nil t))
   	 (delta (make-decoded-time :month 2)))
         (encode-time (decoded-time-add time delta)))
    #+end_src

   If this  date doesn’t exist  (if you’re running  this on January  31st, for
   instance), then  the date will  be shifted back until  you get a  valid date
   (which will be February 28th or 29th, depending).

 - Return Value :: The return value is a /decoded time structure/.
#+end_defun

#+texinfo: @subheading @code{make-decoded-time}

#+findex:make-decoded-time
#+attr_texinfo: :options make-decoded-time &key SECOND MINUTE HOUR DAY MONTH YEAR DST ZONE
#+begin_defun
 Return  a decoded  time structure  with only  the given  keywords filled  out,
 leaving the rest  =nil=. To get a structure that  represents “two months”, you
 could say:

 : (make-decoded-time :month 2)
#+end_defun

#+texinfo: @subheading @code{encode-time}

#+findex:encode-time
#+attr_texinfo: :options encode-time &rest obsolescent-arguments
#+begin_defun
 This function converts =TIME= to a /Lisp timestamp/. It can act as the inverse
 of ~decode-time~. You can perform simple date arithmetic by using out-of-range
 values for  seconds, minutes, hour, day,  and month; for example,  day 0 means
 the day preceding the given month.

 - TIME ::  Ordinarily  the first argument is a list  that specifies a /decoded
   time/ in the style of ~decode-time~:
   : (second minute hour day month year ignored dst zone)

 - Obsolescent Arguments :: As an obsolescent calling convention, this function
   can be given six or more  arguments. The first six arguments second, minute,
   hour, day, month, and year specify most of the components of a decoded time.
   If there are more than six arguments the last argument is used as =ZONE= and
   any other extra arguments are ignored.
#+end_defun

*** Time Parsing
These functions convert time  values to text in a string,  and vice versa. Time
values include =nil=, numbers, and /Lisp timestamps/.

#+texinfo:@subheading @code{date-to-time}---Time String to Timestamp

#+findex:date-to-time
#+attr_texinfo: :options date-to-time STRING
#+begin_defun
 This function parses the time-string string and returns the corresponding Lisp
 timestamp.

 - STRING :: should represent a =date-time=, and  should be in one of the forms
   recognized by  ~parse-time-string~. This function assumes  Universal Time if
   string lacks explicit time zone information.
#+end_defun

#+texinfo:@subheading @code{parse-time-string}---Time String to Time List

#+attr_texinfo: :options parse-time-string STRING
#+begin_defun
 This function  parses the time-string  =STRING= into  a list of  the following
 form:
 : (sec min hour day mon year dow dst tz)
 The format of this list is the same as what ~decode-time~ accepts. Any element
 that cannot be determined from the input will be set to =nil=.

 - STRING ::  should  resemble an RFC 822  (or later) or ISO  8601 string, like
   “Fri, 25  Mar 2016 16:24:56  +0100” or “1998-09-12T12:21:54-0200”,  but this
   function will attempt to parse less well-formed time strings as well.
#+end_defun

#+texinfo:@subheading @code{ iso8601-parse}

#+findex:iso8601-parse
#+findex:iso8601-parse-duration
#+findex:iso8601-parse-interval
#+attr_texinfo: :options  iso8601-parse STRING
#+begin_defun
 For a  more strict  function (that  will error out  upon invalid  input), this
 function  can be  used instead.  It can  parse all  variants of  the ISO  8601
 standard, so in addition to the formats mentioned above, it also parses things
 like “1998W45-3” (week number) and “1998-245” (ordinal day number). It returns
 decoded time structures.

 - ~iso8601-parse-duration~ :: Parses a duration; returns a time structure.

 - ~iso8601-parse-interval~   ::  Parse an  interval;  returns  3 decoded  time
   structures: the start, the end, and the duration.
#+end_defun

#+texinfo: @subheading @code{format-time-string}

#+findex:format-time-string
#+attr_texinfo: :options format-time-string FORMAT-STRING &optional TIME ZONE
#+begin_defun
 This function  converts =TIME=  (or the  current time, if  time is  omitted or
 =nil=) to a string according to =FORMAT-STRING=.

 - FORMAT-STRING ::  may contain =%=-sequences which say to substitute parts of
   the time.

   One or more  flag characters can appear immediately after  the ‘%’.
   - ‘0’ pads with zeros,
   - ‘+’ pads with zeros  and also puts ‘+’  before nonnegative year numbers with  more than four  digits,
   - ‘_’  pads with blanks,
   - ‘-’ suppresses padding,
   - ‘^’ upper-cases letters, and
   - ‘#’ reverses the case of letters.

   You can also  specify the field width  and type of padding for  any of these
   ‘%’-sequences.

   This function uses the C library function ~strftime~.
#+end_defun

#+texinfo: @subheading @code{format-seconds}

#+attr_texinfo: :options format-seconds FORMAT-STRING SECONDS
#+begin_defun
 This function  converts its  argument SECONDS  into a  string of  years, days,
 hours, etc.,  according to  =FORMAT-STRING=. The argument  =FORMAT-STRING= may
 contain ‘%’-sequences which control the conversion.
#+end_defun
*** Time Calculations

#+cindex:calendrical computations
These functions perform  /calendrical computations/ using time  values. A value
of =nil=  for any of their  time-value arguments stands for  the current system
time, and a single number stands for the number of seconds since the epoch.

#+findex:time-less-p
#+texinfo: @subheading @code{time-less-p T1 T2}

This returns =t= if time value =T1= is less than time value =T2=. The result is
=nil= if either argument is a =NaN=.

#+findex:time-equal-p
#+texinfo: @subheading @code{time-equal-p T1 T2}

This returns =t= if =T1= and =T2= are equal time values. The result is =nil= if
either argument is a =NaN=.

#+findex:time-subtract
#+texinfo: @subheading @code{time-subtract T1 T2}

This returns the time difference =T1= \minus =T2= between two time values, as a
Lisp time value.  If you need the  difference in units of  elapsed seconds, you
can convert it with ~time-convert~ or ~float-time~.

#+findex:time-add
#+texinfo: @subheading @code{time-add T1 T2}

This returns  the sum of  two time values, using  the same conversion  rules as
~time-subtract~. One argument should represent  a time difference rather than a
point in time,  as a time value that  is often just a single  number of elapsed
seconds.

: (time-add time seconds)

#+findex:time-to-days
#+texinfo: @subheading @code{time-to-days TIME-VALUE}

This function returns  the number of days  between the beginning of  year 1 and
time-value, assuming the default time zone.

#+findex:time-to-day-in-year
#+texinfo: @subheading @code{time-to-day-in-year TIME-VALUE}

This  returns the  day number  within the  year corresponding  to =time-value=,
assuming the default time zone.

#+findex:date-leap-year-p
#+texinfo: @subheading @code{date-leap-year-p YEAR}

This function returns =t= if year is a leap year.

#+findex:date-days-in-month
#+texinfo: @subheading @code{date-days-in-month YEAR MONTH}

Return the number of days in month  in year. For instance, February 2020 has 29
days.

#+findex:date-ordinal-to-time
#+texinfo: @subheading @code{date-ordinal-to-time YEAR ORDINAL}

Return  the date  of  =ORDINAL= in  year  as a  /decoded  time structure/.  For
instance, the 120th day in 2004 is April 29th.

*** Timers
You can set up a *timer* to call a function at a specified future time or after
a certain  length of idleness.  A *timer* is a  special object that  stores the
information about the next invocation times and the function to invoke.

#+texinfo: @subheading When Timers Can Run

Emacs cannot run  timers at any arbitrary  point in a Lisp program;  it can run
them  only when  Emacs could  accept output  from a  subprocess: namely,  while
waiting or inside certain primitive functions such as ~sit-for~ or ~read-event~
which can wait. Therefore, a timer’s execution may be delayed if Emacs is busy.
However, the time of execution is very precise if Emacs is idle.

#+texinfo: @subheading Timers Inhibit Quitting

Emacs binds  ~inhibit-quit~ to =t=  before calling the timer  function, because
quitting out of many timer functions can leave things in an inconsistent state.
This is normally unproblematical because most timer functions don’t do a lot of
work.  If   a  timer  function   needs  to   allow  quitting,  it   should  use
~with-local-quit~.

#+texinfo: @subheading Timers Should Not Alter Buffer Contents

It is  usually a bad  idea for timer functions  to alter buffer  contents. When
they  do,  they usually  should  call  ~undo-boundary~  both before  and  after
changing  the buffer,  to  separate  the timer’s  changes  from user  commands’
changes and prevent a single undo entry from growing to be quite large.

#+texinfo: @subheading Timers Should Not Call Functions that Wait

Timer functions should  also avoid calling functions that cause  Emacs to wait,
such as ~sit-for~ (see Waiting). This  can lead to unpredictable effects, since
other  timers (or  even the  same  timer) can  run  while waiting.  If a  timer
function needs to perform an action after a certain time has elapsed, it can do
this by scheduling a new timer.

#+texinfo: @subheading Timers Should Avoid Changing Match Data

If a timer function  calls functions that can change the  match data, it should
save and restore the match data.

**** Timer Functions and Commands

#+texinfo: @subheading Function @code{timerp OBJECT}

#+findex:timerp
#+attr_texinfo: :options timerp OBJECT
#+begin_defun
 This predicate function returns non-nil if object is a timer.
#+end_defun

#+texinfo: @subheading Command @code{ run-at-time}

#+findex:run-at-time
#+attr_texinfo: :options  run-at-time TIME REPEAT FUNCTION &rest ARGS
#+begin_defun
 This sets up a timer that  calls the function =FUNCTION= with arguments =ARGS=
 at time =TIME=.

 - TIME :: may specify an absolute or a relative time.

   - Absolute times may  be specified using a string with  a limited variety of
     formats, and are taken to be times today, even if already in the past. The
     recognized forms are:

     - xxxx
     - x:xx
     - xx:xx
     - xxam
     - xxAM
     - xxpm
     - xxPM
     - xx:xxam
     - xx:xxAM
     - xx:xxpm
     - xx:xxPM

   - The result of ~encode-time~ can also  be used to specify an absolute value
     for time.

   - To specify a relative time as a string, use numbers followed by units.

     - =1 min=: denotes 1 minute from now.
     - =1 min 5 sec=: denotes 65 seconds from now.
     - =1 min 2  sec 3 hour 4 day  5 week 6 fortnight 7 month  8 year=: denotes
       exactly 103 months,  123 days, and 10862 seconds from  now. For relative
       time values,  Emacs considers a month  to be exactly thirty  days, and a
       year to be exactly 365.25 days.

     - If time is a number (integer or floating point), that specifies a
      relative time measured in seconds.

 - REPEAT :: If =REPEAT= is a number  (integer or floating point), the timer is
   scheduled to  run again every  =REPEAT= seconds  after time. If  =REPEAT= is
   =nil=, the timer runs only once.

   Any invocation  of a timer  can be late. Lateness  of one repetition  has no
   effect on the scheduled time of the  next repetition. If you want a timer to
   run again no less than =n= seconds  after the last invocation, don’t use the
   =REPEAT= argument. Instead, the  timer function should explicitly reschedule
   the timer.

   In  most   cases,  =REPEAT=  has  no   effect  on  when  first   call  takes
   place---=TIME= alone  specifies that. There  is one exception: if  =TIME= is
   =t=, then the timer  runs whenever the time is a  multiple of repeat seconds
   after the epoch. This is useful for functions like ~display-time~.

 - Return  Value  ::   The function ~run-at-time~ returns a  /timer value/ that
   identifies the particular scheduled future action. You can use this value to
   call ~cancel-timer~.
#+end_defun

#+texinfo: @subheading Command @code{run-with-timer}

#+findex:run-with-timer
#+attr_texinfo: :options run-with-timer SECS REPEAT FUNCTION &rest ARGS
#+begin_defun
 This  is exactly  the same  as ~run-at-time~  (so see  that definition  for an
 explanation of the  parameters; =SECS= is passed as =TIME=  to that function),
 but is meant to be used when the delay is specified in seconds.
#+end_defun

#+texinfo: @subheading User Option @code{timer-max-repeats}

#+vindex:timer-max-repeats
#+attr_texinfo: :options timer-max-repeats
#+begin_defvar
 This variable’s value specifies the maximum  number of times to repeat calling
 a  timer  function  in  a  row, when  many  previously  scheduled  calls  were
 unavoidably delayed.
#+end_defvar

#+texinfo: @subheading Macro @code{with-timeout}

#+findex:with-timeout
#+findex:y-or-no-p-with-timeout
#+attr_texinfo: :options with-timeout (SECONDS TIMEOUT-FORMS...) BODY
#+begin_defun
 This macro works by setting a timer  to run after =SECONDS= seconds. If =BODY=
 finishes before that  time, it cancels the timer. If  the timer actually runs,
 it terminates execution of =BODY=, then executes =TIMEOUT-FORMS=.

 Execute =BODY=, but give up after =SECONDS= seconds. If =BODY= finishes before
 the time is up, ~with-timeout~ returns the value of the last form in body. If,
 however,  the   execution  of  body  is   cut  short  by  the   timeout,  then
 ~with-timeout~ executes all  the =TIMEOUT-FORMS= and returns the  value of the
 last of them.

 Since timers  can run  within a  Lisp program  only when  the program  calls a
 primitive that can wait, ~with-timeout~  cannot stop executing =BODY= while it
 is in the midst of a computation---only when it calls one of those primitives.
 So use ~with-timeout~ only with a body that waits for input, not one that does
 a long computation.

 The function ~y-or-n-p-with-timeout~  provides a simple way to use  a timer to
 avoid waiting too long for an answer.
#+end_defun

#+texinfo: @subheading Function @code{cancel-timer}

#+findex:cancel-timer
#+attr_texinfo: :options cancel-timer TIMER
#+begin_defun
 This   cancels  the   requested  action   for   timer,  which   should  be   a
 timer---usually,    one    previously    returned    by    ~run-at-time~    or
 ~run-with-idle-timer~. This  cancels the effect of  that call to one  of these
 functions; the arrival  of the specified time will not  cause anything special
 to happen.
#+end_defun

#+texinfo: @subheading Command @code{list-timers}

#+attr_texinfo: :options list-timers &optional IGNORE-AUTO NONCONFIRM
#+begin_defun
 The ~list-timers~ command[fn:6] lists all the currently active timers.

 There’s   only  one   command   available  in   the   buffer  displayed:   =c=
 ~(timer-list-cancel)~ that will cancel the timer on the line under point.
#+end_defun

**** Idle Timers
An *idle timer* is a timer that runs when Emacs is idle for a certain length of
time, and work just like ordinary timers.

#+texinfo: @heading The Meaning of Idle

Emacs becomes /idle/ when it starts waiting for user input, and it remains idle
until the  user provides  some input.  If a timer  is set  for five  seconds of
idleness, it  runs approximately five  seconds after Emacs first  becomes idle.
Even if  repeat is  non-nil, this  timer will not  run again  as long  as Emacs
remains idle,  because the duration of  idleness will continue to  increase and
will not go down to five seconds again.

Emacs can do  various things while /idle/: garbage collect,  autosave or handle
data from a  subprocess. But these interludes during idleness  do not interfere
with idle timers, because  they do not reset the clock of  idleness to zero. An
idle timer set for 600 seconds will run when ten minutes have elapsed since the
last user  command was finished,  even if  subprocess output has  been accepted
thousands  of times  within those  ten  minutes, and  even if  there have  been
garbage collections and autosaves.

When the user supplies input, Emacs becomes non-idle while executing the input.
Then it becomes idle  again, and all the idle timers that are  set up to repeat
will subsequently run another time, one by one.

Do not  write an  idle timer function  containing a loop  which does  a certain
amount  of processing  each time  around, and  exits when  (input-pending-p) is
non-nil. This approach seems very natural but has two problems:

 - It blocks  out all process output  (since Emacs accepts process  output only
   while waiting).

 - It blocks out any idle timers that ought to run during that time.

Similarly, do not write an idle timer  function that sets up another idle timer
(including the same  idle timer) with secs  argument less than or  equal to the
current idleness time.  Such a timer will run almost  immediately, and continue
running again  and again, instead  of waiting for  the next time  Emacs becomes
idle. The  correct approach is to  reschedule with an appropriate  increment of
the current value of the idleness time, as described below.

#+texinfo: @heading Idle Timer Commands and Functions

#+texinfo: @subheading Command @code{run-with-idle-timer}

#+attr_texinfo: :options run-with-idle-timer SECS REPEAT FUNCTION &rest ARGS
#+begin_defun
 Set up a timer which runs the next time Emacs is idle for secs seconds.

 - SECS ::  The value  of secs may be a number or a  value of the type returned
   by ~current-idle-time~.

 - REPEAT ::  If  =REPEAT= is =nil=, the  timer runs just once,  the first time
   Emacs remains idle  for a long enough time. More  often REPEAT is non-=nil=,
   which means to run the timer each time Emacs remains idle for SECS seconds.

 - Return  Value  ::  returns a  timer  value  which  you  can use  in  calling
   ~cancel-timer~.
#+end_defun

#+texinfo: @subheading Function @code{current-idle-time}

#+attr_texinfo: :options current-idle-time
#+begin_defun
 If Emacs  is idle,  this function returns  the length of  time Emacs  has been
 idle, using the same format as ~current-time~.

 When  Emacs  is  not  idle,  ~current-idle-time~  returns  =nil=.  This  is  a
 convenient way to test whether Emacs is idle.

 The main  use of ~current-idle-time~ is  when an idle timer  function wants to
 “take a break” for a while. It can  set up another idle timer to call the same
 function again, after a few seconds more idleness.

 #+begin_src elisp
   (defvar my-resume-timer nil
     "Timer for `my-timer-function' to reschedule itself, or nil.")

   (defun my-timer-function ()
     ;; If the user types a command while my-resume-timer
     ;; is active, the next time this function is called from
     ;; its main idle timer, deactivate my-resume-timer.
     (when my-resume-timer
       (cancel-timer my-resume-timer))
     ...do the work for a while...
     (when taking-a-break
       (setq my-resume-timer
	     (run-with-idle-timer
	       ;; Compute an idle time break-length
	       ;; more than the current value.
	       (time-add (current-idle-time) break-length)
	       nil
	       'my-timer-function))))
 #+end_src
#+end_defun
* Programs
** Editing Programs
• *Defuns*---Find or move over top-level definitions (*note Defuns::).
• *Indent*---Apply the usual indentation conventions of the language (*note
  Program Indent::).
• *Parentheses*---Balance parentheses (*note Parentheses::).
• *Comments*---Insert, kill or align comments (*note Comments::).
• *Font Lock*---Highlight program syntax (*note Font Lock::).

*** Programming Major Modes
#+cindex:programming languages, list
- Lisp,
- Scheme,
- the Scheme-based DSSSL expression language,
- Ada,
- ASM,
- AWK,
- C,
- C++,
- Fortran,
- Icon,
- IDL (CORBA),
- IDLWAVE, Java,
- Javascript,
- M4,
- Makefiles,
- Metafont (TeX’s companion for font creation),
- Modula2,
- Object Pascal,
- Objective-C,
- Octave,
- Pascal,
- Perl, CPerl
- Pike,
- PostScript,
- Prolog,
- Python,
- Ruby,
- Simula,
- SQL,
- Tcl,
- Verilog, and
- VHDL.
- scripting languages of the common GNU and Unix shells, and
- MS-DOS/MS-Windows ‘BAT’ files,
- and for makefiles,
- DNS master files,
- and various sorts of configuration files.

#+texinfo:@heading Program Indent
#+cindex:indent
#+cindex:program indent
In most  programming languages, indentation  should vary  from line to  line to
illustrate  the  structure of  the  program.   Therefore, in  most  programming
language modes, typing ‘<TAB>’ updates the indentation of the current line.

#+texinfo:@heading Delete
#+cindex:delete
Furthermore, ‘<DEL>’ is usually bound to ‘backward-delete-char-untabify’, which
deletes  backward treating  each tab  as if  it were  the equivalent  number of
spaces,  so that  you can  delete one  column of  indentation without  worrying
whether the whitespace consists of spaces or tabs.

#+texinfo:@heading @command{prog-mode-hook}
#+cindex:@command{prog-mode-hook}
Entering a programming  language mode runs the custom  Lisp functions specified
in  the hook  variable ‘prog-mode-hook’,  followed  by those  specified in  the
mode’s own mode hook.

*** Defuns
In  Emacs, a  major  definition at  the  top level  in the  buffer,  such as  a
function, is called a  “defun”.  The name comes from Lisp, but  in Emacs we use
it for all languages.

**** Moving by Defuns
These  commands move  point  or set  up  the region  based  on top-level  major
definitions, also called “defuns”.

- ~beginning-of-defun~ :: =C-M-a=

  Move to beginning of current or preceding defun.

  With a negative argument −N moves forward  N times to the next beginning of a
  defun.

- ~end-of-defun~ :: =C-M-e=

  Move to end of current or following defun.

  With a negative argument moves back to an end of a defun.

- ~mark-defun~ :: =C-M-h=

  Put region around whole current or following defun.

  This is the easiest way to get ready to kill the defun in order to move it to
  a different place in the file.  If the defun is directly preceded by comments
  (with no intervening blank lines), they are marked, too.

**** Imenu
The Imenu  facility offers a  way to  find the major  definitions in a  file by
name.  It is  also useful in text  formatter major modes, where  it treats each
chapter, section, etc., as a definition.

- ~imenu~ :: =M-x imenu=

  If  you type  ‘M-x  imenu’, it  reads  the  name of  a  definition using  the
  minibuffer, then moves  point to that definition.  You can  use completion to
  specify the name; the command always displays the whole list of valid names.

- ~imenu-auto-rescan~ ::

  Rescanning  happens  automatically  if   you  set  ‘imenu-auto-rescan’  to  a
  non-‘nil’ value.

**** Which Function Mode
Which Function mode is a global  minor mode which displays the current function
name in the mode line, updating it as you move around in a buffer.

- ~which-function-mode~ :: =M-x which-function-mode=

  Which Function mode is  a global minor mode.  By default,  it takes effect in
  all major modes that  know how to support it (i.e., all  the major modes that
  support Imenu).

*** Indentation

*** Parentheses

*** Comments

*** Documentation Lookup

*** Hideshow Minor Mode

*** Completion of Symbol Names

*** Mixed Case Words

*** Semantic Package

*** Features

**** Words---Sentences---Paragraphs

**** Superword Mode

**** Electric Layout Mode

**** Selective Display

**** Prettify Symbols Mode

** Compiling and Testing Programs
** Maintaining Programs
* Debugging
:PROPERTIES:
:appendix: t
:END:

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Debugging.html#Debugging

- https://www.emacswiki.org/emacs/CategoryDebug

** Find Func

https://www.emacswiki.org/emacs/FindFunc

- find-func (=C-x F=) ::

     ~(find-function FUNCTION)~

     Finds the source file containing the definition of the function near point
     (selected by ‘function-called-at-point’) in a buffer and places point
     before the definition.  Set mark before moving, if the buffer already
     existed.

** Debugger Mode

- https://www.emacswiki.org/emacs/DebuggerMode


#+cindex:debugger mode
#+cindex:BacktraceBuffer
#+cindex:execution stack
/Debugger mode/ is the mode used in the BacktraceBuffer (buffer ‘*Backtrace*’).
It shows the “frames” of your execution stack.  A line starts with ‘*’ if
exiting that frame will call the debugger.

#+texinfo:@heading Debugger Keys

=C-h m= gives you information on the current mode.

#+attr_texinfo: :indic code
- b :: break point – place an asterisk (=*=) on a stack frame
- u :: remove break point
- c :: continue
- d :: single step
- j :: keep existing frames until you reach the current frame
- e :: eval another sexp that you input
- q :: quit


#+texinfo:@heading Entering debugger mode

- You can use ~M-x debug-on-entry~ to put breakpoints at the start of
  functions, and ~M-x cancel-debug-on-entry~ to remove them.

- You can put ~(debug)~ in EmacsLisp code at arbitrary points (and then eval
  that code) to put breakpoints at those places.

- You can set any of the following variables:
    #+attr_texinfo: :indic b
  - debug-on-quit ::

                     Debugger is entered when the user hits =C-g=.  This is
                     useful in debugging infinite loops and long delays.  You
                     can toggle this variable using ~M-x toggle-debug-on-quit~.

  - debug-on-error ::

                      Debugger is entered when an uncaught error happens.  This
                      is foiled by condition-case forms that catch errors.  You
                      can toggle this variable using =M-x
                      toggle-debug-on-error=.  Note that some errors are
                      ignored --- you may have to temporarily set
                      ~debug-ignored-errors~ to ‘nil’ in order to debug such
                      errors.

  - stack-trace-on-error ::

       An alternative to ~debug-on-error~.  It shows trace buffers instead of
       entering the debugger.  Example: ~(setq stack-trace-on-error
       '(buffer-read-only))~

** Edebug

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html]]

- https://www.emacswiki.org/emacs/SourceLevelDebugger


#+cindex:instrument
#+cindex:@command{edebug-defun} @code{C-u C-M-x}
#+findex:edebug-defun C-u C-M-x
#+findex:edebug-eval-top-level-form
#+findex:edebug-defun
#+vindex:edebug-all-defs
#+vindex:edebug-all-forms
~Edebug~ is a source level debugger for EmacsLisp.  It instruments code.  This
means that Emacs adds special instructions to the code when it is evaluated, to
invoke Edebug at the proper places.

- edebug-defun (=C-u C-M-x=) ::

     is the main entry point to Edebug.  Use it instead of =C-x C-e= or =C-M-x=
     to evaluate a =defun= and instrument it for debugging.  When you invoke
     command =C-u C-M-x= (~eval-defun~ with a prefix argument) on a function
     definition, it instruments the definition before evaluating it.


See the variables:
#+vindex:edebug-all-defs
#+vindex:edebug-all-forms
- ~edebug-all-defs~ and
- ~edebug-all-forms~


#+texinfo:@noindent to control how ~eval-defun~ operates.

See also the commands:
#+findex:eval-region
#+findex:eval-current-buffer
#+findex:eval-buffer:
- ~eval-region~
- ~eval-current-buffer~
- ~eval-buffer~
- ~edebug-eval-top-level-form~
- ~edebug-defun~ (an alias of ~edebug-eval-top-level-form~


~edebug-defun~ must be able to read your code.  It expects all function
definitions to start in column 0.  If they do not, hitting =C-u C-M-x= will
show you the wrong function name in the echo area.

#+texinfo:@heading Instrumented Source Code

#+cindex:execution mode, default
#+cindex:source code buffer
Once a function is instrumented, any call to the function activates Edebug.
The action that occurs depends on which /execution mode/ is active.  The
default execution mode is =step=, which stops execution.  You will be viewing a
read-only buffer of the source code that is being debugged (the /source code
buffer/).  An arrow in the left fringe indicates the line where the function is
executing.  The special commands of Edebug are available in the source code
buffer in addition to the commands of Emacs Lisp mode.

#+texinfo:@heading Stop Points

#+cindex:stop points
The places within a function where Edebug can stop execution are called “stop
points”.  These occur both before and after each subexpression that is a list,
and also after each variable reference.  When Edebug stops execution after an
expression, it displays the expression’s value in the echo area.

#+texinfo:@heading Commanly Used Edebug Commands

- SPC :: execute until the next stop point

- b :: set a breakpoint at a stop point

- g :: execute until a breakpoint is reached

- q :: exit Edebug

- ? :: display a l ist of all Edebug commands


#+texinfo:@heading Interrupt Edebug Execution

While executing or tracing, you can interrupt the execution by typing any
Edebug command.  Edebug stops the program at the next stop point and then
executes the command you typed.  For example, typing ‘t’ during execution
switches to trace mode at the next stop point.  You can use ‘S’ to stop
execution without doing anything else.

*** Features of Edebug
- Step through evaluation, stopping before and after each expression.

- Set conditional or unconditional breakpoints.

- Stop when a specified condition is true (the global break event).

- Trace slow or fast, stopping briefly at each stop point, or at each
  breakpoint.

- Display expression results and evaluate expressions as if outside of Edebug.

- Automatically re-evaluate a list of expressions and display their results
  each time Edebug updates the display.

- Output trace information on function calls and returns.

- Stop when an error occurs.

- Display a backtrace, omitting Edebug's own frames.

- Specify argument evaluation for macros and defining forms.

- Obtain rudimentary coverage testing and frequency counts.

*** Example of Edebug

Paste the following functions into the =*scratch*= buffer (starting at column
0).  Hit =C-M-x= with the cursor inside each of the function definitions.

#+name:foo-and-bar
#+begin_src elisp
  (defun foo ()
        (interactive)
        (bar))

  (defun bar ()
    (let ((a 5)
          (b 7))
      (message "%d" (+ a b))))
#+end_src

Use =M-x foo=.  This prints `12' in the echo area.

Now instrument ‘bar’ by moving the cursor into its code and hitting =C-u
C-M-x=.  The echo area shows =Edebug: bar=.

Use =M-x foo= again.  Emacs steps through the code of ‘bar’, showing you the
result of evaluating each sexp in the echo area.  Hit ‘SPC’ to step ahead or
‘e’ to evaluate another expression.  The arrow shows you which sexp will be
evaluated next:

#+begin_src elisp
  (defun bar ()
  =>(let ((a 5)
          (b 7))
      (message "%d" (+ a b))))
#+end_src

To quit the debugger, type ‘q’.

Edebug can enter any defun whose source can be found with [[*Find Func][FindFunc]] by hitting
‘i’ which steps into the next function to be evaluated.  This instruments the
function and will be debugged every time it is run.

You can disable edebug on a function by evaluating the function again using
=C-M-x= without a PrefixArgument.

You can see the code coverage of the defun at point with ~C-x X =~ or =M-x
edebug-display-freq-count=.

*** Instrumenting for Edebug

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Instrumenting.html#Instrumenting


#+findex:edebug-instrument-callee
#+findex:edebug-step-in
#+attr_texinfo: :indic command
- I (edebug-instrument-callee) ::

     instruments the definition of the function or macro called by the list form
     after point.

- i (edebug-step-in) ::

     steps into the call after instrumenting the function


#+texinfo:@heading User-Defined Macros

#+cindex:user-defined macro, instrument
Edebug knows how to instrument all the standard special forms, ‘interactive’
forms with an expression argument, anonymous lambda expressions, and other
defining forms.  However, Edebug cannot determine on its own what a
user-defined macro will do with the arguments of a macro call, so you must
provide that information using Edebug specifications.  [[info:elisp#Edebug%20and%20Macros][Edebug and Macros]].

#+texinfo:@heading Syntax Errors

#+cindex:invalid-read-syntax error
If Edebug detects a syntax error while instrumenting, it leaves point at the
erroneous code and signals an =invalid-read-syntax= error.  One potential
reason for such a failure to instrument is that some macro definitions are not
yet known to Emacs.  To work around this, load the file which defines the
function you are about to instrument.

#+texinfo:@heading Remove Instrumentation

#+cindex:instrumenation, remove
To remove instrumentation from a definition, simply re-evaluate its definition
in a way that does not instrument.  There are two ways of evaluating forms that
never instrument them: from a file with ~load~, and from the minibuffer with
~eval-expression~ (=M-:=).

*** Edebug Execution Modes

#+cindex:execution modes
Edebug supports several execution modes for running the program you are
debugging, called /execution modes/.  The current Edebug execution mode
determines how far Edebug continues execution before stopping and how much
Edebug displays the progress of the evaluation before it stops.  Normally, you
specify the Edebug execution mode by typing a command to continue the program
in a certain mode.  All except for =S= resume execution of the program.  In
general, the execution modes earlier in the above list run the program more
slowly or stop sooner than the modes later in the list.

| Command | Mode           | Function                  | Effect                                                                   |
|---------+----------------+---------------------------+--------------------------------------------------------------------------|
| S       | Stop           | edebug-stop               | don’t execute any more of the program, but wait for more Edebug commands |
| SPC     | Step           | edebug-step-mode          | stop at the next stop point encountered                                  |
| n       | Next           | edebug-next-mode          | stop at the next stop point encountered after an expression              |
| t       | Trace          | edebug-trace-mode         | pause (normally one second) at each Edebug stop point                    |
| T       | Rapid Trace    | edebug-Trace-fast-mode    | update the display at each stop point, but don’t actually pause          |
| g       | Go             | edebug-go-mode            | See Breakpoints                                                          |
| c       | Continue       | edebug-continue-mode      | pause one second at each breakpoint, and then continue                   |
| C       | Rapid Continue | edebug-Continue-fast-mode | move point to each breakpoint, but don’t pause                           |
| G       | Go non-stop    | edebug-Go-nonstop-mode    | ignore breakpoints. Stop program with =S=, or editing command            |
|---------+----------------+---------------------------+--------------------------------------------------------------------------|

**** Set Initial Execution Mode

#+cindex:execution mode, initial
#+vindex:edebug-initial-mode
#+findex:edebug-set-initial-mode C-x C-a C-m
- ~edebug-initial-mode~ ::

     Default execution mode is =step=

     When you enter a new Edebug level, Edebug will normally stop at the first
     instrumented function it encounters (=Step=).

- edebug-set-initial-mode (=C-x C-a C-m=) ::

     If you prefer to stop only at a break point, or not at all (for example,
     when gathering coverage data), change the value of ‘edebug-initial-mode’
     from its default ‘step’ to ‘go’, or ‘Go-nonstop’, or one of its other
     values (*note Edebug Options).

**** Waiting Between Execution Steps

#+attr_texinfo: :indic code
- edebug-sit-for-seconds ::

     This option specifies how many seconds to wait between execution steps in
     trace mode or continue mode.  The default is 1 second.

*** Edebug Jumping

#+cindex:jump
The commands described in this section execute until they reach a specified
location.  All except ‘i’ make a temporary breakpoint to establish the place to
stop, then switch to go mode.  Any other breakpoint reached before the intended
stop point will also stop execution.

| Command | Function            | Description                                                    |
|---------+---------------------+----------------------------------------------------------------|
| h       | edebug-goto-here    | Proceed to the stop point near where point is                  |
| [N] f   | edebug-forward-sexp | Run the program for one [N] expression(s)                      |
| o       | edebug-step-out     | Run the program until the end of the containing sexp           |
| i       | edebug-step-in      | Step into the function or macro called by the form after point |
|---------+---------------------+----------------------------------------------------------------|

*** Miscellaneous Edebug Commands

| Command | Function                 | Description                                                          |
|---------+--------------------------+----------------------------------------------------------------------|
| C-]     | abort-recursive-edit     | Abort one level back to the previous command level                   |
| Q       | edebug-top-level-nonstop | Like ‘q’, but don’t stop even for protected code                     |
| r       | edebug-previous-result   | Redisplay the most recently known expression result in the echo area |
| d       | edebug-backtrace         | Display a backtrace, excluding Edebug’s own functions for clarity    |
|---------+--------------------------+----------------------------------------------------------------------|

*** Edebug Breaks
There are three other ways (other than stop points) to stop Edebug execution
once it has started:
#+cindex:breaks
- breakpoints,
- the global break condition, and
- source breakpoints.

**** Breakpoints
While using Edebug, you can specify “breakpoints” in the program you are
testing: these are places where execution should stop.  You can set a
breakpoint at any stop point, as defined in *note Using Edebug.  Re-evaluating
or reinstrumenting a definition removes all of its previous breakpoints.
Edebug always stops or pauses at a breakpoint, except when the Edebug mode is
Go-nonstop.  In that mode, it ignores breakpoints entirely.

To find out where your breakpoints are, use the ‘B’ command, which moves point
to the next breakpoint following point, within the same function, or to the
first breakpoint if there are no following breakpoints.  This command does not
continue execution---it just moves point in the buffer.

| Command | Function                          | Description                                                                                                  |
|---------+-----------------------------------+--------------------------------------------------------------------------------------------------------------|
| b       | edebug-set-breakpoint             | Set a breakpoint at the stop point at or after point                                                         |
| u       | edebug-unset-breakpoint           | Unset the breakpoint (if any) at the stop point at or after point                                            |
| x COND  | edebug-set-conditional-breakpoint | Set a conditional breakpoint which stops the program only if evaluating COND produces a non-‘nil’ value      |
| B       | edebug-next-breakpoint            | Move point to the next breakpoint in the current definition                                                  |
|---------+-----------------------------------+--------------------------------------------------------------------------------------------------------------|

#+texinfo:@heading Conditional Breakpoints

#+cindex:conditional breakpoint
#+cindex:breakpoint, conditional
A “conditional breakpoint” tests a condition each time the program gets there.
Any errors that occur as a result of evaluating the condition are ignored, as
if the result were ‘nil’.

To set a conditional breakpoint, use ‘x’, and specify the condition expression
in the minibuffer.  Setting a conditional breakpoint at a stop point that has a
previously established conditional breakpoint puts the previous condition
expression in the minibuffer so you can edit it.

#+texinfo:@subheading Making a Breakpoint Temporary

#+cindex:temporary breakpoint
You can make a conditional or unconditional breakpoint “temporary” by using a
prefix argument with the command to set the breakpoint.  When a temporary
breakpoint stops the program, it is automatically unset.

**** Global Break Condition

#+cindex:global break condition
#+cindex:break condition, global
A “global break condition” stops execution when a specified condition is
satisfied, no matter where that may occur.  Edebug evaluates the global break
condition at every stop point; if it evaluates to a non-‘nil’ value, then
execution stops or pauses depending on the execution mode, as if a breakpoint
had been hit.  If evaluating the condition gets an error, execution does not
stop.

The global break condition is the simplest way to find where in your code some
event occurs, but it makes code run much more slowly.  So you should reset the
condition to ‘nil’ when not using it.

#+attr_texinfo: :indic code
- edebug-global-break-condition ::

     The variable in which the condition expression is stored.

- edebug-set-global-break-condition ::

     You can specify a new expression using the ‘X’ command from the source
     code buffer while Edebug is active, or using ‘C-x X X’ from any buffer at
     any time, as long as Edebug is loaded

**** Source Breakpoints

#+cindex:source breakpoint
#+cindex:breakpoint, source
All breakpoints in a definition are forgotten each time you reinstrument it.
If you wish to make a breakpoint that won’t be forgotten, you can write a
“source breakpoint”, which is simply a call to the function ‘edebug’ in your
source code.  You can, of course, make such a call conditional.  If no
instrumented code is being executed when ‘edebug’ is called, that function
calls ‘debug’.

*** Edebug Views

#+cindex:outside window configuration
The outside window configuration is the collection of windows and contents that
were in effect outside of Edebug.

| Command | Function                  | Description                                                                       |
|---------+---------------------------+-----------------------------------------------------------------------------------|
| v       | edebug-view-outside       | Switch to viewing the outside window configuration                                |
| C-x X w |                           | return to Edebug                                                                  |
| p       | edebug-bounce-point       | Temporarily display the outside current buffer with point at its outside position |
| w       | edebug-where              | Move point back to the current stop point in the source code buffer               |
| W       | edebug-toggle-sae-windows | Toggle whether Edebug saves and restores the outside window configuration         |
| C-u W   |                           | Toggle saving and restoring of the selected window only                           |
|---------+---------------------------+-----------------------------------------------------------------------------------|

*** Edebug Evaluation

While within Edebug, you can evaluate expressions as if Edebug were not
running.

| Command | Function               | Description                                                            |
|---------+------------------------+------------------------------------------------------------------------|
| e EXP   | edebug-eval-expression | Evaluate expression EXP in the context outside of Edebug               |
| M-: EXP | eval-expression        | Evaluate expression EXP in the context of Edebug itself                |
| C-x C-e | edebut-eval-last-sexp  | Evaluate the expression before point, in the context outside of Edebug |
|---------+------------------------+------------------------------------------------------------------------|

*** Edebug Evaluation List Buffer

#+cindex:evaluation list buffer
#+cindex:@code{*edebug*} buffer
You can use the “evaluation list buffer”, called ‘*edebug*’, to evaluate
expressions interactively.  You can also set up the “evaluation list” of
expressions to be evaluated automatically each time Edebug updates the display.

You can evaluate expressions in the evaluation list window with ‘C-j’ or ‘C-x
C-e’, just as you would in ‘*scratch*’; but they are evaluated in the context
outside of Edebug.

The expressions you enter interactively (and their results) are lost when you
continue execution; but you can set up an “evaluation list” consisting of
expressions to be evaluated each time execution stops.

In the ‘*edebug*’ buffer you can use the commands of Lisp Interaction mode
(*note Lisp Interaction) as well as these special commands:

| Command | Function                    | Description                                                                                      |
|---------+-----------------------------+--------------------------------------------------------------------------------------------------|
| E       | edebug-visit-eval-list      | Switch to the evaluation list buffer ‘*edebug*’                                                  |
| C-j     | edebug-eval-print-last-sexp | Evaluate the expression before point, in the outside context, and insert the value in the buffer |
| C-x C-e | edebug-eval-last-sexp       | Evaluate the expression before point, in the context outside of Edebug                           |
| C-c C-u | edebug-update-eval-list     | Build a new evaluation list from the contents of the buffer                                      |
| C-c C-d | edebug-delete-eval-item     | Delete the evaluation list group that point is in                                                |
| C-c C-w | edebug-where                | Switch back to the source code buffer at the current stop point                                  |
|---------+-----------------------------+--------------------------------------------------------------------------------------------------|

*** Insert a Direct Call to Edebug

#+begin_src elisp
  (defmacro stop-here (fn)
         "Call edebug here. FN is assumed to be a symbol of the function you are in."
         `(if (consp (get ,fn 'edebug))
             (edebug)))

  (defun clear-edebug (fn-sym)
    "Remove 'edebug property from FN-SYM, a function symbol."
    (put fn-sym 'edebug nil))
#+end_src

#+begin_src elisp
   ;; An example of use:
  (defun fact (n)
    (cond ((= n 0) )
          ((= n 1) 1)
          ((>  n 1) (progn (stop-here 'fact) (* n (fact (1- n)))))
          (t nil)))
#+end_src

If you eval the above and then ~edebug-defun~ while the point is on =fact=,
you’ll first stop at =fact= but then when you enter ‘g’ for ‘go’ it will next
stop after the ~(* n… )~ which is what I want.

And note you could also put a condition around `stop-here` for example:

: ((>  n 1) (progn (if (= n 3) (stop-here 'fact)) (* n (fact (1- n)))))

*** Trace Buffer

https://www.gnu.org/software/emacs/manual/html_node/elisp/Trace-Buffer.html#Trace-Buffer

#+cindex:trace buffer
#+cindex:execution trace
#+cindex:trace recording
#+cindex:@code{*edebug-trace*}
Edebug can record an execution trace, storing it in a buffer named
=*edebug-trace*=.  This is a log of function calls and returns, showing the
function names and their arguments and values.

#+vindex:edebug-trace
- ~edebug-trace~ :: To enable trace recording, set ~edebug-trace~ to a non-nil
                    value.


Making a trace buffer is not the same thing as using =trace execution mode=
(see Edebug Execution Modes).

#+texinfo:@heading Trace Recording

When trace recording is enabled, each function entry and exit adds lines to the
trace buffer.  A function entry record consists of =::::{=, followed by the
function name and argument values.  A function exit record consists of =::::}=,
followed by the function name and result of the function.  The number of =:='s
in an entry shows its recursion depth.

** Debug Messages
:PROPERTIES:
:header-args: :eval no
:END:

- https://www.emacswiki.org/emacs/DebugMessages


Sometimes you want to find out where a particular error, warning or just plain
annoying message in Messages is coming from.

This piece of advice allows you to see the function call sequence that resulted
in each message in the Messages buffer:

#+begin_src elisp
  (defadvice message (before who-said-that activate)
      "Find out who said that thing. and say so."
      (let ((trace nil) (n 1) (frame nil))
        (while (setq frame (backtrace-frame n))
          (setq n     (1+ n)
                trace (cons (cadr frame) trace)) )
        (ad-set-arg 0 (concat "<<%S>>:\n" (ad-get-arg 0)))
        (ad-set-args 1 (cons trace (ad-get-args 1))) ))
#+end_src

To deactivate this, call

#+begin_src elisp
  (ad-disable-advice 'message 'before 'who-said-that)
     (ad-update 'message)
#+end_src

To get timestamps:

#+begin_src elisp
  (defadvice message (before when-was-that activate)
      "Add timestamps to `message' output."
      (ad-set-arg 0 (concat (format-time-string "[%Y-%m-%d %T %Z] ")
                            (ad-get-arg 0)) ))
#+end_src

And to deactivate this, call:

#+begin_src elisp
  (ad-disable-advice 'message 'before 'when-was-that)
      (ad-update 'message)
#+end_src

** Emacs Lisp Regression Testing---ERT

#+cindex:ERT
#+cindex:testing, ERT
*** Defining Tests
ERT allows you  to define _tests_ in addition to  functions, macros, variables,
and the  other usual Lisp  constructs.  Tests are  simply Lisp code:  code that
invokes other code and checks whether it behaves as expected.
**** ert-deftest
#+attr_texinfo: :options ert-defest test-name () docstring body
#+begin_defun
Define a  test named TEST-NAME.   Test names are  in a namespace  separate from
functions and variables  but by convention should have a  prefix that indicates
which package they belong to.  The  parentheses are not used (no parameters are
allowed).

DOCSTRING is a string that explains the  test.  This string is displayed when a
test fails.

Place tests  in BODY, usually using  the macro ~should~, which  is basically an
assert with good error reporting.
#+end_defun
*** Running Tests
**** Running Tests Interactively
- =M-x ert :SELECTOR=  :: ERT will pup  up a new buffer, called the ERT results
  buffer, showing the results of the tests run.
***** ERT Selectors
- =nil= :: select no tests
- =t= :: run all tests
- =:new= :: select all tests not yet run
- =:failed= =:passed= :: select tests according to their most recent result
- =:expected=  =:unexpected= ::  select tests  according to  their most  recent
  result
- "regexp" :: a string reg exp that selects all tests with matching names
- a test (an object of ~ert=test~ data type) :: selects that test
- a symbol :: selects the test that the symbol names
- ~(member TESTS...)~  :: selects  the elements  of tests, a  list of  tests or
  symbols naming tests
- ~(eql TEST)~ :: selects TEST, a test or a symbol naming a test
- ~(and SELECTORS...)~ :: selects the tests that match all SELECTORS
- ~(or SELECTORS...)~ :: selects the tests that match any of the SELECTORS
- ~(not SELECTOR)~ :: selects all tests that do not match SELECTOR
- ~(tag TAG)~ :: selects all tests that have TAG on their tags list
- ~(satisfies  PREDICATE)~  :: selects  all  tests  that satisfy  PREDICATE,  a
  function that takes a test as argument and returns non-nill if it is selected

**** Running Tests in Batch Mode
** Elisp Tracing

- https://www.emacswiki.org/emacs/EmacsLispTracing


#+texinfo:@heading Commands
#+cindex:trace
#+cindex:tracing

#+attr_texinfo: :indic b
- M-x trace-function

- M-x trace-function-background

- M-x untrace-function

- M-x untrace-all

** Elisp Benchmarking

- https://www.emacswiki.org/emacs/EmacsLispBenchmark


#+cindex:benchmark
#+cindex:benchmarking
Emacs comes with ~GIT:emacs-lisp/benchmark.el~ by DaveLove that can display the
elapsed time of running an EmacsLisp expression.  It observes the timing from
running a form once or repeatedly.  Any time spent by Emacs on
=GarbageCollection= is also determined.  These features are available
interactively with ~M-x benchmark~ or programmatically with ~benchmark-run~.

** Elisp Profiler

- https://www.emacswiki.org/emacs/EmacsLispProfiler


#+cindex:profiler
#+cindex:@code{elp.el}
Emacs comes with ~GIT:emacs-lisp/elp.el~ by Barry Warsaw that can display the
elapsed time of running an EmacsLisp function.  It is possible to instrument
more than one function, so it displays the results as a table in a buffer
called =*Elp Profiling Results*=.  It tracks the total timing for each call of
an instrumented function and determines the average time for each call.

** Emacs Native Profiler

https://www.emacswiki.org/emacs/EmacsNativeProfiler
#+cindex:native profiler
#+cindex:profiler library

The =profiler= library provides CPU & memory profiling for all Emacs functions.

Unlike =EmacsLispProfiler= you do not have to specify which functions or
packages you wish to profile (however ELP remains complementary as it records
overall time taken, which includes time spent waiting for external processes to
return, which is something that the native profiler will not report on).

** Elisp Logging

- https://www.emacswiki.org/emacs/Log4E_Logging_For_Elisp

- https://github.com/aki2o/log4e


~log4e.el~ provides a logging framework for Elisp.
** GUD---Grand Unified Debugger Mode
#+cindex:GUD Grand Unified Debugger
#+cindex:Grand Unified Debugger (GUD)
- GUD Library manual entry---[[info:emacs#Debuggers][(emacs)Debuggers]]

The GUD (Grand Unified Debugger) library  provides an Emacs interface to a wide
variety of symbolic debuggers.   It can run the GNU Debugger  (GDB), as well as
DBX, SDB,  XDB, Guile REPL  debug commands,  Perl’s debugging mode,  the Python
debugger PDB, and the Java Debugger JDB.

*** Starting GUD
#+cindex:GUD, starting

Each of these commands  reads a command line to invoke  the debugger, using the
minibuffer.  The minibuffer’s initial  contents contain the standard executable
name and options for  the debugger, and sometimes also a guess  for the name of
the executable file  you want to debug.  Shell wildcards  and variables are not
allowed in  this command line.  Emacs  assumes that the first  command argument
which does not start with a ‘-’ is the executable file name.

- ~gdb~ :: =M-x gdb=

  Run  GDB  as  a subprocess,  and  interact  with  it  via an  IDE-like  Emacs
  interface.

- ~gud-gdb~ :: =M-x gud-gdb=

  Run GDB,  using a  GUD interaction  buffer for  input and  output to  the GDB
  subprocess

- ~perldb~ :: =M-x perldb=

  Run the Perl interpreter in debug mode.

- ~jdb~ :: =M-x jdb=

  Run the Java debugger.

- ~pdb~ :: =M-x pdb=

  Run the Python debugger.

- ~guiler~ :: =M-x guiler=

  Run Guile REPL for debugging Guile Scheme programs.

- ~dbx~ :: =M-x dbx=

  Run the DBX debugger.

- ~xdb~ :: =M-x xdb=

  Run the XDB debugger.

- ~sdb~ :: =M-x sdb=

  Run the SDB debugger.

*** GUD Operation
#+cindex:GUD interaction buffer
#+texinfo:@heading Interaction Buffer
The “GUD  interaction buffer”  is an Emacs  buffer which is  used to  send text
commands to  a debugger subprocess, and  record its output.  This  is the basic
interface for  interacting with  a debugger,  used by  ‘M-x gud-gdb’  and other
commands listed  in *note Starting GUD.

#+cindex:@command{gdb} start GDB
The  ‘M-x  gdb’ command  extends  this  interface with  additional  specialized
buffers for  controlling breakpoints,  stack frames, and  other aspects  of the
debugger state

#+texinfo:@heading Shell Mode
The  GUD interaction  buffer  uses a  variant  of *Shell  mode*,  so the  Emacs
commands defined  by Shell mode  are available.  *Completion* is  available for
most debugger commands,  and you can use the usual  Shell mode history commands
to repeat them.  *Note  Commands of GUD, for special commands  that can be used
in the GUD interaction buffer.

#+texinfo:@heading Source Files
As you  debug a program, Emacs  displays the relevant source  files by visiting
them in Emacs buffers, with an arrow  in the left fringe indicating the current
execution line.   (On a text terminal,  the arrow appears as  ‘=>’, overlaid on
the first two text  columns.)  Moving point in such a buffer  does not move the
arrow.  You  are free to  edit these source files,  but note that  inserting or
deleting lines will throw  off the arrow’s positioning, as Emacs  has no way to
figure out  which edited source  line corresponds to  the line reported  by the
debugger  subprocess.   To  update  this information,  you  typically  have  to
recompile and restart the program.

#+cindex:Tooltip mode
#+texinfo:@heading GUD Tooltip Mode
GUD Tooltip mode is  a global minor mode that adds tooltip  support to GUD.  To
toggle this mode, type ‘M-x gud-tooltip-mode’.   It is disabled by default.  If
enabled, you can move the mouse pointer over a variable, a function, or a macro
(collectively called “identifiers”) to show their values in tooltips .  If just
placing the  mouse pointer  over an  expression doesn’t show  the value  of the
expression you had in mind, you  can tell Emacs more explicitly what expression
to evaluate by  dragging the mouse over the expression,  then leaving the mouse
inside the marked area.

*** GUD Commands
#+cindex:GUD commands
GUD provides  commands for  setting and  clearing breakpoints,  selecting stack
frames, and stepping through the program.
* Email
** Leaving Gmail Behind
- https://nullprogram.com/blog/2013/09/03/

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Table Listings
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo: @listoffloats Table

* Concept Index
:PROPERTIES:
:INDEX:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:    vr
:unnumbered: t
:END:

* Program Index
:PROPERTIES:
:unnumbered: t
:index:    pg
:END:

* Footnotes

[fn:6] According to documentation, the command is disabled. 

[fn:5] This default may change in future Emacs releases, so callers requiring a particular form should specify form. 

[fn:4] this is planned to change in a future Emacs version, so callers requiring list timestamps should pass list explicitly. 

[fn:3]  The operating system limits the range of time and zone values. 

[fn:2] This is planned to change in a future Emacs version. 

[fn:1]For example, Mac OS is case-insensitive by default, but can be configured
to be case-sensitive.

* Build Tools
:PROPERTIES:
:appendix: t
:custom_id: build-tools
:org-template-version: 0.7.0
:END:
** Makefile					:dependencies:env_vars:perl:
:PROPERTIES:
:appendix: t
:dependency1: make
:dependency2.0: AWS User account at https://aws.amazon.com
:dependency2.1: AWS cli v2 in PATH https://docs.aws.amazon.com/cli/index.html > which aws
:dependency2.2: See how to install AWS CLI v2 at https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html
:dependency2.3: See how to update AWS CLI v2 at https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html#cliv2-mac-install-cmd-all-users
:dependency2.4: See how to configure AWS CLI v2 at https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html
:dependency2.5: AWS credentials: access key id and secret access key stored in ~/.aws/credentials
:dependency2.6: AWS configuration stored in ~/.aws/config
:dependency2.7: AWS S3 buckets set up for serving a static web page
:dependency3: GitHub Account with personal access token stored in GITHUB_TOKEN
:dependency4: texinfo @6.7 or greater installed
:dependency5: Emacs with Org-mode and Babel language 'shell' enabled: '(org-babel-load-languages '(... (shell . t)))'
:dependency6: Emacs with Org Texinfo exporter enabled 'ox-texinfo'
:env_var1: SYNC_ORG_TEMPLATE: holds the full path to this Template.org file
:env_var2: GITHUB_TOKEN: holds the GitHub personal access token
:env_var3: EMACS: reference to an Emacs executable
:env_var4: EMACS_TERMSERVER: reference to a started terminal emacsclient server named 'termserver'
:env_var5: EMACS_APP_CLIENT: reference to a started gui emacsclient server named 'guiserver'
:env_var6: COLORS environment variables that have been defined
:END:

#+pindex:Makefile
#+name:Makefile
#+header: :tangle Makefile
#+begin_src makefile

  ###############################################################################
  ### USER-DEPENDENT VARIABLES
  ### USE ENVIRONMENT VARIABLES WHENEVER POSSIBLE

  # NOTE: All  environment variables need  to be  exported PRIOR to  starting the
  # Emacs  server in  your  shell  startup files;  otherwise,  they  will not  be
  # available to Emacs.

  # When I  moved from using  Bash to Zsh, I  inadvertently changed the  order of
  # import, and started the Emacs server  before importing, and caused a horrible
  # bug which caused the program to work on one computer but fail on another.

  # The absolute path to this Template file
  TEMPLATE := $(SYNC_ORG_TEMPLATE)

  # Use emacsclient  to edit buffers  under the  hood; make sure  it is set  in a
  # shell startup file and the server has been started.  I have two emacs servers
  # running: in  the shell  and one as  a GUI.   In this program,  I use  the GUI
  # server to open an INFO file.
  EMACS		:= $(EMACS)
  TERMSERVER	:= $(EMACS_TERMSERVER) -s termserver
  GUISERVER	:= $(EMACS_APP_CLIENT) -s guiserver

  # User’s personal GitHub token for authentication to GitHub

  # DO NOT HARD-CODE THIS VALUE AND DO NOT SAVE IT IN GITHUB

  GITHUB_TOKEN	:= $(GITHUB_TOKEN)

  # The AWS Command Line Interface (AWS CLI)  is an open source tool that enables
  # you to interact with AWS services  using commands in your command-line shell.
  # It must be present on your  system.  Run the 'make' command 'install-aws-cli'
  # to install it  if you do not have  it.  Be sure to run  'aws configure' after
  # installing it.  This will place your AWS credentials into ~/.aws/credentials.

  # DO NOT HARD-CODE THESE VALUES OR SAVE THEM INTO GITHUB

  AWS		:= aws
  S3		:= $(AWS) s3
  CF		:= $(AWS) cloudfront

  ### END OF USER-DEPENDENT VARIABLES
  ###############################################################################
  ### MAKE-GENERATED VARIABLES

  ### TOOLS & RESOURCES

  # resources is a directory holding  static resources for the project; resources
  # is created as a subdirectory of every new project.

  # resource/tools  is  a  directory  holding tangled  scripts,  such  as  cmprpl
  # resources/images is a directory holding jpg and png image files
  # resources/source holds complete source files (not generated by this program)

  RESOURCES	:= resources
  TOOLS		:= $(RESOURCES)/tools
  IMAGES		:= $(RESOURCES)/images
  SOURCE		:= $(RESOURCES)/source
  CMPRPL		:= $(TOOLS)/cmprpl

  ### PROJ AND ORG
  # ORG is the name of this Org file with extension .org
  # PROJ is the project name---the Org file name without extension.

  # NOTE: there can  be only one Org  file in the project directory;  so far this
  # has not been a problem, but it might be.

  PWD  := $(shell pwd)
  ORG  := $(shell ls *.org)
  PROJ := $(basename $(ORG))

  # NOTE: S is needed only for the Template  file because of the way it is nested
  # one level deep  in the Templates GitHub  repo, which uses the  plural form of
  # Templates, whereas this  file uses the singular form, Template.   So when the
  # homepage link  is updated, the  curl command must be  told to use  the plural
  # form.  This is obviously a hack only for my own use and can be removed once I
  # clean up this anomaly.

  ifeq ($(PROJ),$(basename $(notdir $(TEMPLATE))))
  S := s
  endif

  # The AWS S3  bucket to use to store  the html source file; it is  found at the
  # key  #+bucket towards  the  beginning  of the  file  and  should include  the
  # appropriate suffix (.com, .net, .org, etc)

  BUCKET       := $(shell $(TERMSERVER) --eval \
		 '(with-current-buffer (find-file-noselect "$(ORG)") \
		    (save-excursion \
		      (goto-char (point-min)) \
		      (re-search-forward "^\#[+]bucket:\\(.*\\)$$" nil t) \
		      (match-string-no-properties 1)))')
  S3_BUCKET    := s3://$(BUCKET)

  # Buckets set up to serve static web sites from S3 can use either http or https
  # protocols; some http protocols will automatically redirect to https; however,
  # some only use http.  I would like to accomodate both, and  so this code finds
  # the url's  that are  in my  Cloudfront account,  which presumably  will serve
  # https.  If  the url  is not  here, then  this must  be set  up to  serve http
  # instead.

  HTTP_S := $(shell $(CF) list-distributions | perl -MJSON::PP -e \
	  '$$/=""; \
	   my @urls = (); \
	   my $$json=JSON::PP->new->decode(<STDIN>); \
	   for my $$item ( @{$$json->{"DistributionList"}{"Items"}} ) { \
		  push @urls, @{$$item->{"Aliases"}{"Items"}}; \
	   } \
	  my $$found = grep { /'$(BUCKET)'/ } @urls; \
	  print "http", ($$found ? "s" : "");')

  HTTPS_BUCKET := https://$(BUCKET)

  ### DIR, SRC
  # DIR is the .info name found at '#+texinfo_filename:<DIR>.info' (at the bottom
  # of this  file in  the export configuration  settings) without  its extension,
  # used as  the INFO filename  and the name of  the HTML export  directory; this
  # code uses the lowercased PROJ name  if there is no '#+texinfo_filename'.  SRC
  # is HTML directory based upon the DIR name

  #DIR := $(shell $(TERMSERVER) --eval \
  #	'(with-current-buffer (find-file-noselect "$(ORG)") \
  #		(save-excursion \
  #		(goto-char (point-min)) \
  #		(re-search-forward "^\#[+]\\(?:texinfo_filename\\|TEXINFO_FILENAME\\):\\(.*\\).info$$" nil t) \
  #		(match-string-no-properties 1)))')

  DIR := $(shell sed -E -n "/^\#\+texinfo_filename/s/^.*:(.*)\.info$$/\1/p" $(ORG))
  ifeq ($(DIR),$(EMPTY))
	  DIR := $(shell echo $(PROJ) | tr "[:upper:]" "[:lower:]")
  endif

  SRC := $(DIR)/

  ### VERS: v1.2.34/
  # VERS is the version number of this  Org document.  When sync is run after the
  # version number has been updated, then  VERS picks up the newly-changed value.
  # VERS used to be staticly imbedded when the Makefile was tangled, but it needs
  # to be dynamic for development.

  # QUERY: should this  number be formatted like  this, or should it  be just the
  # numbers?  The reason it includes them is the S3PROJ obtains the name from the
  # S3 bucket, and  it includes them.  But  it only includes them  because I have
  # made it  so.  Not  a good  reason just by  itself.  The  ending slash  is not
  # actually a part of the version, but  comes from the way the 'aws2 ls' command
  # returns its values.  So VERS should probably not include  the trailing slash,
  # although it doesn’t hurt anything.

  VERS := v$(shell $(TERMSERVER) --eval \
	  '(with-current-buffer (find-file-noselect "$(ORG)") \
		  (save-excursion \
		    (goto-char (point-min)) \
		    (re-search-forward "^\#[+]\\(?:macro\\|MACRO\\):version Version \\(\\(?:[[:digit:]]+[.]?\\)\\{3\\}\\)") \
		    (match-string-no-properties 1)))')/

  ### AWS
  # PROJ_LIST contains the list of projects  currently uploaded to the S3 bucket;
  # each item contains the name of the project and its current version.

  # Created function using elisp instead of the shell.  This variable contains an
  # elisp list  of strings  of the  form '("proj1-v1.2.3/"  "proj2-v4.5.6/" ...)'
  # However, when it prints to the shell, the quotes are lost.  Need to make sure
  # elisp's variable  'exec-path contains the  proper $PATH instead of  adding to
  # 'exec-path.

  PROJ_LIST := $(shell $(TERMSERVER) --eval \
	  "(progn \
		  (require (quote seq)) (add-to-list (quote exec-path) (quote \"/usr/local/bin\")) \
		  (seq-map (lambda (s) (replace-regexp-in-string \"^\s+PRE \" \"\" s)) \
			  (seq-filter (lambda (s) (string-match-p (regexp-quote \" PRE \") s)) \
			  (process-lines \"$(AWS)\" \"s3\" \"ls\" \"$(S3_BUCKET)\"))))")

  ### S3PROJ
  # The name of the current project as obtained from S3: 'proj-v1.2.34/' If there
  # is no current project in the S3 bucket,  then assign a value equal to the Org
  # project and version  instead.  It is set  to the project if found,  and NO if
  # not found, then updated in the ifeq block below.

  S3PROJ := $(shell $(TERMSERVER) --eval \
		  '(let ((proj (seq-find (lambda (s) (string-match-p "$(DIR)" s)) (quote $(PROJ_LIST))))) \
		     (or proj (quote NO)))')

  ### PROJINS3
  # is used  by make sync;  this allows the index.html  file to be  generated the
  # first time  the project is synced.   It is set to  NO if this project  is not
  # currently in an S3 bucket, and it is set to YES if it is.

  PROJINS3 :=

  ### S3VERS
  # The version of this project currently  installed in the S3 bucket: 'v1.2.34/'
  # If there is no current version in the S3 bucket, then assign the version from
  # this Org file instead.

  S3VERS   :=

  # Update S3PROJ, S3VERS, and PROJINS3
  ifeq ($(S3PROJ), NO)
	  S3PROJ := $(DIR)-$(VERS)
	  S3VERS := $(VERS)
	  PROJINS3 := NO
  else
	  S3VERS := $(subst $(DIR)-,,$(S3PROJ))
	  PROJINS3 := YES
  endif

  ### GITHUB
  # USER is the current user's GitHub login name.

  # The user name used to be statically embedded into the Makefile during tangle,
  # but in  an effort to make  the Makefile dynamically indepedent,  dynamic code
  # has replaced the  static code.  The code  that placed the static  name in the
  # Makefile  was a  'node' script  that  ran in  a separate  Org process  during
  # tangle. An unfortunate  fact of 'make' is that 'make'  strips the quote marks
  # from  the string  obtained  from the  'curl' command  when  the 'make  shell'
  # command  returns  the string.   This  makes  the  string malformed  JSON  and
  # unparsable  by most  JSON  parsers, including  'node’.  However, perl’s  core
  # module JSON::PP  (but not  JSON::XS) has facilities  to parse  very malformed
  # JSON strings.  Therefore,  this dynamic code uses 'perl' and  the core module
  # JSON::PP  to parse  the 'curl'  string into  a 'perl'  JSON object  which can
  # return  the login  name. This  code should  work with  any version  of 'perl'
  # without having to install any modules.

  USER	:= $(shell \
	    curl -sH "Authorization: token $(GITHUB_TOKEN)" https://api.github.com/user \
	    | \
	    perl -MJSON::PP -e \
		'$$/ = ""; \
		 my $$json = JSON::PP->new->loose->allow_barekey->decode(<STDIN>); \
		 print $$json->{login};' \
	    )
  SAVE		:= resources

  ### TEXINFO
  TEXI		:= $(PROJ).texi
  INFO		:= $(DIR).info
  INFOTN		:= $(shell $(TERMSERVER) --eval "(file-truename \"$(INFO)\")")
  PDF		:= $(PROJ).pdf
  INDEX		:= index.html
  HTML		:= $(DIR)/$(INDEX)
  DIR_OLD		:= $(DIR)-old

  ### AWS S3
  DST_OLD		:= $(S3_BUCKET)/$(S3PROJ)
  DST_NEW		:= $(S3_BUCKET)/$(DIR)-$(VERS)
  EXCL_INCL	:= --exclude "*" --include "*.html"
  INCL_IMAGES	:= --exclude "*" --include "*.jpg" --include "*.png"
  INCL_SOURCE	:= --exclude "*" --include "*.html"
  GRANTS		:= --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  S3SYNC		:= $(S3) sync --delete $(EXCL_INCL) $(SRC) $(DST_OLD) $(GRANTS)
  S3MOVE		:= $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(GRANTS)
  S3COPY		:= $(S3) cp $(INDEX) $(S3_BUCKET) $(GRANTS)
  S3REMOVE	:= $(S3) rm $(S3_BUCKET)/$(S3PROJ) --recursive
  S3IMAGESYNC	:= $(S3) sync $(INCL_IMAGES) $(IMAGES) $(S3_BUCKET)/$(IMAGES) $(GRANTS)
  S3SOURCESYNC	:= $(S3) sync $(INCL_SOURCE) $(SOURCE) $(S3_BUCKET)/$(SOURCE) $(GRANTS)

  ###############################################################################

  default: check texi info html pdf

  PHONY: default all check values boot \
	    texi info html pdf \
	    open-org open-texi open-html open-pdf \
	    clean dist-clean wiped-clean \
	    help sync update delete-proj \
	    install-aws-cli \
	    index-html upload-index-html

  values: check
	    @printf "$${BLUE}Values...$${CLEAR}\n"
	    @echo TEMPLATE:	$(TEMPLATE)
	    @echo TERMSERVER:	$(TERMSERVER)
	    @echo GUISERVER:	$(GUISERVER)
	    @echo USER:		$(USER)
	    @echo PWD:		$(PWD)
	    @echo ORG:		$(ORG)
	    @echo TEXI:		$(TEXI)
	    @echo INFO:		$(INFO)
	    @ECHO INFOTN:		$(INFOTN)
	    @echo BUCKET:		$(BUCKET)
	    @echo PROJ:		$(PROJ) $S
	    @echo S3_BUCKET:	$(S3_BUCKET)
	    @echo HTTP_S:		$(HTTP_S)
	    @echo HTTPS_BUCKET:	$(HTTPS_BUCKET)
	    @echo VERS:		$(VERS)
	    @echo S3PROJ:		$(S3PROJ)
	    @echo S3VERS:		$(S3VERS)
	    @echo DIR:		$(DIR)
	    @echo DIR_OLD:	$(DIR_OLD)
	    @echo SRC:		$(SRC)
	    @echo DST_OLD:	$(DST_OLD)
	    @echo DST_NEW:	$(DST_NEW)
	    @echo PROJ_LIST:	"$(PROJ_LIST)"
	    @echo PROJINS3:	$(PROJINS3)

  check:
	    @printf "$${BLUE}Checking dependencies...$${CLEAR}\n"

	    @[[ -z $(BUCKET) ]] && \
	       { printf "$${RED}$(BUCKET) $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	       printf "$${CYAN}BUCKET: $${GREEN}$(BUCKET)$${CLEAR}\n";

	    @[[ -z $${GITHUB_TOKEN} ]] && \
	       { printf "$${RED}GITHUB_TOKEN $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	       printf "$${CYAN}GITHUB_TOKEN: $${GREEN}SET$${CLEAR}\n";

	    @[[ (-d ~/.aws) && (-f ~/.aws/credentials) && (-f ~/.aws/config) ]] && \
	       printf "$${CYAN}AWS credentials and config: $${GREEN}SET$${CLEAR}\n" || \
	       { printf "$${RED}~/.aws 'credentials' and 'config' must be set.$${CLEAR}\n"; exit 1; }

	    @[[ "$(shell $(TERMSERVER) --eval \
		  '(or (featurep (quote texinfo)) \
		       (member (quote texinfo) org-export-backends))')" = "t" ]] && \
		  printf "$${CYAN}Texinfo backend: $${GREEN}INSTALLED.$${CLEAR}\n" || \
		  { printf "$${YELLOW}Texinfo backend:$${CLEAR} $${RED}NOT INSTALLED; it must be installed.$${CLEAR}\n"; exit 1; }

	    @[[ $(shell $(TERMSERVER) --eval '(symbol-value org-confirm-babel-evaluate)') == "t" ]] && \
		  { printf "$${YELLOW}org-confirm-babel-evaluate:$${CLEAR} $${RED}T; set to NIL.$${CLEAR}\n"; exit 1; } || \
		  printf "$${CYAN}org-confirm-babel-evaluate: $${GREEN}OFF.$${CLEAR}\n\n"

  open-org: $(ORG)
	    @$(TERMSERVER) -n $(ORG)
  $(ORG):
	    @echo 'THERE IS NO $(ORG) FILE!!!'
	    exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	   @echo Making TEXI...
	   @$(TERMSERVER) -u --eval \
		  "(with-current-buffer (find-file-noselect \"$(ORG)\" t) \
			  (save-excursion \
			  (org-texinfo-export-to-texinfo)))"
	   @echo Done making TEXI.
  open-texi: texi
	   @$(TERMSERVER) -n $(TEXI)

  info: $(INFO)
  $(INFO): $(TEXI)
	   @echo Making INFO...
	   @makeinfo -o $(INFO) $(TEXI)
	   @$(TERMSERVER) -u -eval \
		  "(when (get-buffer \"$(INFO)\") \
			  (with-current-buffer (get-buffer \"$(INFO)\") \
				  (revert-buffer t t t)))"
	   @echo Done making INFO.

  open-info: info
	   @$(GUISERVER) -u -eval \
		  "(if (get-buffer \"*info*\") \
			  (with-current-buffer (get-buffer \"*info*\") \
				(when (not (string= \"(symbol-value (quote Info-current-file))\" \"$(INFOTN)\")) \
					(info \"$(INFOTN)\")) \
				(revert-buffer t t t)) \
		      (info \"$(INFOTN)\"))"

  html: $(HTML)
  $(HTML): $(TEXI)
	   @echo Making HTML INFO..
	   @makeinfo --html -o $(DIR) $(TEXI)
	   @echo Done making HTML.
	   $(CMPRPL) $(DIR) $(DIR_OLD)
  open-html: html
	   @open $(HTML)

  # If pdftexi2dvi produces an error, it may still produce a viable PDF;
  # therefore, use --tidy.  If it produces an error, try to link the PDF;
  # if it does not produce an error, the PDF will be added to the top dir
  # and there will be no attempt to link.
  pdf:	$(PDF)
  $(PDF): $(TEXI)
	  @echo Making PDF INFO...
	  @-pdftexi2dvi --quiet --build=tidy $(TEXI) || ln -s $(PROJ).t2d/pdf/build/$(PDF) $(PDF)
	  @echo Done making PDF.
  open-pdf:pdf
	   @open $(PDF)

  tangle: $(ORG)
	      @$(TERMSERVER) -u --eval "(org-babel-tangle)"
	      @echo Done tangling

  sync:   $(HTML)
	  @echo Syncing version $(VERS) onto $(S3VERS)...
	  $(S3SYNC)
	  $(S3IMAGESYNC)
	  $(S3SOURCESYNC)
	  @echo Done syncing.
	  [[ $(VERS) != $(S3VERS) ]] && { echo Moving...; $(S3MOVE); echo Done moving.;  make homepage; } || :
	  [[ $(PROJINS3) = "NO" ]] && make homepage || :

  # This is a target-specific variable for updating the “description”
  # key on the GitHub repo page with the current version number.  It
  # first makes a curl call to the GitHub project repo, finds the
  # “description” line, pulls out the description only (leaving the old
  # version) and then prints the value with the current version number.
  # This value is used by the “homepage:” target in the PATCH call.
  # This method is arguably harder to code but faster to run than using
  # Perl with the JSON::PP module.

  homepage: description = $(shell \
	  curl -s \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S | \
		  (perl -ne 'if (/^\s*\"description\":\s*\"(.*): v(?:(?:[[:digit:]]+[.]?){3})/) {print $$1}'))

  ### NOTE the use of the S variable at the end of PROJ; this is to handle
  # the singular case of the GitHub repo using the plural form, Templates
  # whereas the the Template.org file uses the singular form.
  homepage: $(ORG) upload-index-html
	    @echo Updating homepage...
	    @echo DESCRIPTION: $(description)
	    @echo VERS: $(VERS)
	    @curl -i \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  -H "Content-Type: application/json" \
		  -X PATCH \
		  -d "{\"homepage\":\"$(HTTPS_BUCKET)/$(DIR)-$(VERS)\",\
		       \"description\":\"$(description): $(VERS)\"}" \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S
	    @echo Done updating homepage.

  delete-proj:
	  @echo Deleting project $(PROJ)...
	  @curl -i \
		  -H "Authorization: token $(GITHUB_TOKEN)" \
		  -H "Accept: application/vnd.github.v3+json" \
		  -X DELETE \
		  https://api.github.com/repos/$(USER)/$(PROJ)$S
	  @$(S3REMOVE)
	  @make dist-clean
	  @make upload-index-html
	  @$(TERMSERVER) -u --eval "(kill-buffer \"$(ORG)\")"
	  @rm -rf "../$(PROJ)"
	  @echo Done deleting project.

  index-html: $(INDEX)
  $(INDEX): $(ORG)
	  @echo making index.html...
	  $(TERMSERVER) --eval \
	  "(with-current-buffer (find-file-noselect \"$(ORG)\") \
		  (save-excursion \
		    (org-link-search \"#project-index-title\") \
		    (org-export-to-file (quote html) \"index.html\" nil t)))"
	  @echo Done making index.html.

  upload-index-html: $(INDEX)
	   @echo Uploading index.html...
	   $(S3COPY)
	   @echo Done uploading index.html

  install-aws-cli:
	    curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg" && \
	    sudo installer -pkg AWSCLIV2.pkg -target / && \
	    which aws && aws --version
	    rm -rf AWSCLIV2.pkg

  clean:
	  @echo Cleaning...
	    -@rm *~ 2>/dev/null
	    -@for file in *.??*; \
	    do \
		    ext=$${file#$(PROJ).}; \
		    [[ ! $${ext} =~ org|texi|info|pdf|html ]] && rm -rv $${file}; \
	    done

  dist-clean: clean
	  @echo Dist Cleaning...
	    @${TERMSERVER} -u --eval \
	      "(kill-buffer \"$(ORG)\")"
	    -@rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)
	    -@for dir in *; \
		do \
		    [ -d $$dir -a $$dir != "$(DIR_OLD)" -a $$dir != $(SAVE) ] && \
		    rm -vr $$dir; \
		done

  wipe-clean: dist-clean
	  @echo Wipe Clean...
	    -@rm -rf Makefile Readme.md $(DIR_OLD)
	    @git checkout Makefile README.md

  git-ready: dist-clean
	    git checkout Makefile
	    git checkout README.md
	    git status

  help:
	    @echo '"make boot" tangles all of the files in Template'
	    @echo '"make default" makes the .texi file, the .info file, \
	    the html files, and the .pdf file.'
	    @echo

	    @echo '"make check" checks for prerequistes'
	    @echo '"make values" runs check and prints variable values'
	    @echo

	    @echo '"make texi" makes the .texi file'
	    @echo '"make info" makes the .info file'
	    @echo '"make html" makes the html distribution in a subdirectory'
	    @echo '"make pdf" makes the .pdf file'
	    @echo

	    @echo '"make open-org" opens the ORG program using emacsclient for editing'
	    @echo '"make open-texi" opens the .texi file using emacsclient for review'
	    @echo '"make open-html" opens the distribution index.html file \
	    in the default web browser'
	    @echo '"make open-pdf" opens the .pdf file'
	    @echo

	    @echo '"make sync" syncs the html files in the AWS S3 bucket BUCKET; \
	    you must have your AWS S3 bucket name in the env var AWS_S3_BUCKET; \
	    You must have your AWS credentials installed in ~/.aws/credentials'
	    @echo

	    @echo '"make install-aws-cli" installs the "aws cli v2" command-line tools'
	    @echo 'You also need to run "aws configure" and supply your Access Key and Secret Access Key'
	    @echo

	    @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	    @echo '"make dist-clean" cleans, removes the html distribution, \
	    and removes the build directory'
	    @echo '"make wipe-clean" wipes clean the directory, including old directories'
	    @echo

	    @echo '"make delete-proj" deletes the project from the file system, GitHub and AWS'

#+end_src

*** TODO Next
1. The CloudFront configuration needs to be updated recognize the new version
   directory that is created as part of the ~sync~ operation.

2. Update the GitHub HOME website link for each new sync operation.

3. Store on GitHub a version of each other format upon a sync operation (i.e.,
   the INFO and PDF versions)

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation. This is
to  make  sure  the  ~cmprpl~  source code  exists  in  the  ~resources/tools/~
directory before running  the Makefile target =html=. It also  makes sure there
is a Makefile on an initial export. The following code is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The  AWS ~sync~  command  relies  upon time  stamps  to  determine whether  two
programs are identical or not, as  well as content.  If two otherwise identical
files have  different time stamps,  ~sync~ will  assume they are  different and
will  process the  newer.   However, the  ~texinfo~  ~makeinfo --html~  command
produces all  new files even  if some files  (or most files)  remain unchanged.
This  means that  all files  will be  uploaded to  the AWS  S3 bucket  on every
iteration, even though the majority of the files are actually unchanged.

The ~cmprpl~  source code attempts to  resolve the issue of  identical exported
code having different  time stamps, thus defeating the benefit  provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: =$DIR_NEW=.  If
it doesn’t, then it is in an improper state and the program stops with an error
message.

The  program then  checks  if  an old  directory  exists,  =$DIR_OLD=.  If  one
doesn’t,  then one  is  created by  copying the  current  new directory.   This
provides a baseline  for comparisons going forward.  The program  exits at that
point. It is very important that  the =$DIR_OLD= directory not be deleted going
forward.

Given  that =$DIR_OLD=  exists, the  program then  loops through  all files  in
=$DIR_NEW= and  compares them  to the  files in =$DIR_OLD=.   If the  files are
identical, the =$DIR_OLD= file replaces the =$DIR_NEW= file while retaining the
old time stamp (using the ~-p~ option of ~cp~. If a file is different, then the
=$DIR_NEW= file  replaces the =$DIR_OLD=  file, thus giving it  updated content
and  an updated  time stamp.   If the  file does  not exist  in the  =$DIR_OLD=
directory, then it is added.

The  program then  loops through  all of  the files  in the  old directory  and
deletes  any that  do not  exist in  the new  directory.  Now  both directories
should be in sync.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle resources/tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  DIR_NEW=$1
  DIR_OLD=$2

  [[ -d $DIR_NEW ]] || { echo "ERROR: $DIR_NEW does not exist"; exit 1; }
  [[ -d $DIR_OLD ]] || { echo "CREATING: $DIR_OLD does not exist"; cp -a $DIR_NEW $DIR_OLD; exit 0; }

  for newfile in $DIR_NEW/*
  do
      oldfile=$DIR_OLD/$(basename $newfile)
      if [[ -e $oldfile ]]
      then
	 if cmp -s $newfile $oldfile
	 then
	     printf "${GREEN}copying OLD to NEW${CLEAR}: "
	     cp -vp $oldfile $newfile
	 else
	     printf "${PURPLE}copying NEW to OLD${CLEAR}: "
	     cp -vp $newfile $oldfile
	 fi
      else
	  printf "${BLUE}creating NEW in OLD${CLEAR}: "
	  cp -vp $newfile $oldfile
      fi
  done

  for oldfile in $DIR_OLD/*
  do
      newfile=$DIR_NEW/$(basename $oldfile)
      if [[ ! -e $newfile ]]
      then
	  printf "${RED}removing OLD${CLEAR}: "
	  rm -v $oldfile
      fi
  done
#+end_src


** Update Utility Commands
*** Get Parsed Org Tree
This function looks for an Org file in the present working directory, and if it
finds one returns  a parsed tree using  ~org-element-parse-buffer~.  It returns
=nil= if there is no Org file or if the found file is not in ~org-mode~.

#+name:get-parsed-org-tree
#+header: :results silent
#+begin_src emacs-lisp
(defun get-parsed-org-tree (&optional org-dir)
  "This function takes an optional directory name, changes to
that directory if given, otherwise uses the pwd, and finds an Org
file and returns its parsed tree, or nil if none found."
  (when org-dir
      (cd (file-name-as-directory org-dir)))
  (let ((buf (car-safe (find-file-noselect "*.org" nil nil t))))
    (if buf
	(with-current-buffer buf (org-element-parse-buffer))
      nil)))
#+end_src

*** Check for CID
This code  checks whether an  Org file contains  a =custom_id= of  a particular
value.  It accepts  a ~cid-value~ and an optional directory.   If the directory
is not given, then it defaults to the current directory.  If throws an error if
the directory does not exist.  It returns =nil= if the given directory does not
contain an Org file.   It returns =t= if the Org file  contains a node property
of   =custom_id=  and   value  ~cid-value~,   or   =nil=  if   not.   It   uses
~get-parsed-org-tree~.

#+name:org-tree-cid-p
#+header: :results silent
#+begin_src emacs-lisp
(defun org-tree-cid-p (cid-value &optional org-dir)
  "Check whether an org file contains a custom_id of CID"
  (let ((tree (get-parsed-org-tree org-dir)))
    (car (org-element-map tree 'property-drawer
	   (lambda (pd) (org-element-map (org-element-contents pd) 'node-property
			  (lambda (np)
			    (and
			     (string= "custom_id" (org-element-property :key np))
			     (string= cid-value (org-element-property :value np))))))
	   nil t))))
#+end_src

#+name:run-org-tree-cid-p
#+header: :var cid="build-tools"
#+header: :var dir="/usr/local/dev/programming/MasteringEmacs"
#+header: :var gpot=get-parsed-org-tree()
#+header: :var otcp=org-tree-cid-p()
#+header: :results value
#+header: :eval never-export
#+begin_src emacs-lisp
(org-tree-cid-p cid dir)
#+end_src

#+call: run-org-tree-cid-p(dir="/usr/local/dev/programming/MasteringEmacs")

*** Keywords and Values
This function takes  an Org file name and optionally  a directory (otherwise it
uses the default  directory) and returns the  value of a keyword.   It does not
use a parse tree, but rather loops through the file line-by-line until it finds
the keyword and then returns its value.

#+name:get-keyword-value
#+begin_src emacs-lisp
  (defun get-keyword-value (keyword-to-get org-file-name &optional dir)
    "Returns the value of a keyword in an Org buffer identified by ORG-FILE-NAME.
  Uses the current directory unless an optional DIR is supplied.
  Returns NIL if none is found.  Rather than parsing the whole Org
  buffer into a tree, this function simply starts at the beginning
  of the file and loops line by line through the file, returning
  when the key has been found or it reaches the end of the file."
    (with-current-buffer
	(find-file-noselect
	 (concat
	  (if dir (file-name-as-directory dir) default-directory)
	  org-file-name))
      (save-excursion
	(goto-char (point-min))
	(let ((done nil)
	      (ans nil))
	  (while (not done)
	    (let* ((el (org-element-at-point))
		   (ty (org-element-type el))
		   (key (org-element-property :key el))
		   (val (org-element-property :value el)))
	      (when (and
		     (string-equal ty "keyword")
		     (string-equal key keyword-to-get))
		(setq ans val done t))
	      (forward-line)
	      (when (eobp)
		(setq done t))))
	  ans))))
#+end_src

#+name:get-title-for-org-buffer
#+begin_src emacs-lisp
(defun get-title-for-org-buffer (org-file-name &optional dir)
"A wrapper around `get-keyword-value' to find a TITLE in an Org buffer."
  (get-keyword-value "TITLE" org-file-name dir))
#+end_src

** Bucket Index HTML
The bucket should contain a master ~index.html~  file that links to each of the
individual project  ~index.html~ files.  The  master ~index.html~ file  will be
placed at the root of  the bucket, ~https://<bucket-name>.com/~, and the bucket
must be set up to serve this ~index.html~ when the user hits the root.

*** Get Bucket Name
 This  code searches  for  the keyword-value  pair =bucket:<BUCKET-NAME>=  that
 should be  located towards the  beginning of the  file, and returns  the value
 =BUCKET-NAME= or nil if not found.

#+name: get-bucket-name
#+header: :results value
#+begin_src emacs-lisp
   (save-excursion
     (goto-char (point-min))
     (re-search-forward "^#\\+bucket:\\s*?\\(.*\\)$" nil t)
     (match-string-no-properties 1))
#+end_src

For some reason, ~get-bucket-name~ does not  work when called from the headline
[[#project-index-links][=Links for  bucket=]] below  when creating  =index.html=, even  if it  returns as
~(prin1 ...)~ and is  set up to ~:return output~; the  call receives =nil=. The
following code from ~bucket-name~, however, works. I don't know why.

#+name: bucket-name
#+header: :results output
#+header: :var bucket-name=get-bucket-name()
#+begin_src emacs-lisp
(prin1 bucket-name)
#+end_src

*** Bucket HTTPS URL
This  code calls  ~get-bucket-name~ and  returns the  value returned  as a  URL
string or nil.

#+name: bucket-https-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "https://" b)
#+end_src

*** S3 Bucket URL
This code calls ~get-bucket-name~ and returns the AWS S3 bucket url.

#+name: s3-bucket-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "s3://" b)
#+end_src

*** Bucket Projects List
This code uses the ~s3-bucket-url~ result to obtain the list of projects in the
bucket.  It does  this by calling the  AWS S3 high-level command  ~ls~ and then
removing the  =PRE= string in  each result.  The result  that is returned  is a
single  string that  can be  separated into  individual links  by breaking  the
string on spaces.

#+name: bucket-projects-list
#+header: :results output
#+header: :var bucket=s3-bucket-url()
#+begin_src sh
/usr/local/bin/aws s3 ls ${bucket} | sed -ne 's/^.*PRE //p'
#+end_src

*** Bucket Project Links
This code  uses the result  from ~bucket-projects-list~ to create  an unordered
list of  links written to  bucket projects, written  in Org-mode syntax.  It is
executed by a =#+call:= in [[*Bucket Index][*Bucket  Index]] during an HTML export of that subtree
to a file called =index.html=.

#+name: bucket-project-links
#+header: :var b-url=bucket-https-url()
#+header: :var projects=bucket-projects-list()
#+header: :results output raw
#+begin_src emacs-lisp
(seq-do (lambda (u) (princ (format "- [[%s/%sindex.html][~%s~]]
" b-url u u))) (split-string projects))
#+end_src

*** Bucket Index
    :PROPERTIES:
    :custom_id: project-index-title
    :export_file_name: index.html
    :export_subtitle: {{{version}}} created {{{upload-date}}}
    :END:
#+html_doctype: html5
#+options: toc:nil html5-fancy:t

#+html: <hr>

**** Links for bucket call_bucket-name()
     :PROPERTIES:
     :unnumbered: t
     :custom_id: project-index-links
     :END:

#+call: bucket-project-links()
** Project Readme
This adds the README.md template to a project. It should be customized uniquely
for the project.

#+name:project-readme
#+header: :tangle README.md
#+begin_src markdown
# TITLE
## Subtitle
## Author
## Date
## Version
# ABSTRACT
This is the Org Template file.	It is the parent of all other Org Info blogs,
and provides the source code for processing them in various different ways.
# INTRODUCTION
# CHAPTER
## Section
### Subsection
#+end_src

** Boot Template
:PROPERTIES:
:dependency1: EMACS_TERMSERVER :=: emacsclient --socket-name=termserver running
:dependency2: SYNC_ORG_TEMPLATE :=: $DEV/Templates/Org/Template.org (this file)
:END:
Although running the command ~org-babel-tangle~ (=C-c C-v t=) from within Emacs
will install  everything, it would  be nice to have  a simple Makefile  that is
downloaded with this  file that could be  invoked to do the  same thing without
starting Emacs and Org-mode and keying in the ~org-babel-tangle~ command.  This
little Makefile should be stored on  GitHub along with the ~Template.org~ file.
When  the source  is extracted  to a  directory, then  running this  Makefile's
default rule  as simply  ~make~ will create  the resource  directories 'tools',
'images', and 'source', and then preprocesses =Dev=, and then extracts the full
Makefile.  Because this file is tangled along with the full Makefile, it simply
gets tacked  onto the  end of the  big Makefile as  an additional  rule.

The Makefile can also run 'git' to update the repository, including pushing the
changes to  Github.  This  should be  called after  initially installing  a new
repository.

Running `make all' does both.

It is assumed that an Emacs server is running, and that the =$EMACS_TERMSERVER=
environment variable is set to use ~emacsclient --socket-name=termserver~.

#+name:boot-template
#+header: :tangle Makefile
#+begin_src makefile
  TERMSERVER := $(EMACS_TERMSERVER) --socket-name=termserver --suppress-output
  boot:
	  @$(TERMSERVER) \
	    --eval \
		  "(let ((rsrcdir \"resources\") \
			 (subdirs (list \"tools\" \"images\" \"source\"))) \
		     (mkdir rsrcdir t) \
		     (dolist (subdir subdirs) (mkdir (concat rsrcdir \"/\" subdir) t)))" \
	     --eval \
		  "(with-current-buffer \
		     (car (find-file-noselect \"./*.org\" nil nil t)) \
			(save-excursion \
			   (goto-char (point-min)) \
			   (let ((re-search-str \"\\(?::tangle\\|load-file \\(?:[\\]*\\)?[\\\"]\\)\s*\\(.*?/\\[dD\\]ev\\)/\") \
				  (dev (getenv \"DEV\"))) \
			      (while \
				 (re-search-forward re-search-str nil t) \
				 (replace-match dev t nil nil 1))) \
			    (save-buffer) \
			    (org-babel-tangle)))"
  git:
	  git add . && git commit -m "After running boot-template Makefile" && git push origin master
  all: boot git
#+end_src

** Preprocess Env Vars
The environment variable DEV can be  in different locations and will be spelled
differently based  on how the  local machine is set  up.  For instance,  on one
system,  it will  be at  ~$HOME/Dev~  while in  another  system it  will be  at
~/usr/local/dev~.  However, the =:tangle= keyword  does not expand variables in
the form ~${DEV}~,  but rather requires absolute  paths, like ~/usr/local/dev~.
Therefore, this program works like a preprocessor for environment variables set
up  as part  of  =:tangle= lines,  changing them  to  their system  environment
variable values prior to tangling.  It lives in the ~resources/tools~
directory.

- *NOTE:  [2021-09-15 Wed  23:30]* The  assumption  that the  emacs program  is
  located   at  ~/opt/local/bin/~   is   incorrect.   Perhaps   it  should   be
  ~#!/usb/bin/env emacs~ instead.

#+name:preprocess.el
#+header: :mkdirp t
#+header: :tangle resources/tools/preprocess.el
#+header: :shebang "#!/usr/bin/env emacs -Q --script"
#+begin_src emacs-lisp
  (with-current-buffer (car (find-file-noselect "./*.org" nil nil t))
    (save-excursion
    (goto-char (point-min))
    (let ((re-search-str "\\(?::tangle\\|load-file \\(?:[\\]*\\)?[\"]\\)\s*\\(.*?/[dD]ev\\)/")
          (dev (getenv "DEV")))
      (while
              (re-search-forward re-search-str nil t)
              (replace-match dev t nil nil 1)))
    (save-buffer)
    (require 'org)
    (org-babel-tangle)))
#+end_src

** Samples
#+begin_comment
(cd "~/Dev/Emacs/MasteringEmacs/")
"/Users/pine/Dev/Emacs/MasteringEmacs/"

(defun add-bucket (org bucket)
  "Add a bucket keyword BUCKET to the org file ORG."
  (interactive "fFile: \nsBUCKET: ")
  (with-current-buffer (find-file-noselect org)
    (let* ((tree (org-element-parse-buffer))
	   (ins (car (org-element-map tree (quote section)
		 (lambda (s)
		   (org-element-map s (quote keyword)
		     (lambda (kw) (when (equal "MACRO" (org-element-property :key kw)) (1- (org-element-property :end kw))))
		     nil nil :keyword))
		 nil t nil nil))))
      (goto-char ins)
      (insert (format "#+bucket:%s\n" bucket))
      ())))

(add-bucket "MasteringEmacs.org" "pinecone-forest")
nil

(defun hl-region (raw-hl)
  "Obtain the begin and end positions for a headline."
  (with-current-buffer (find-file-noselect (getenv "SYNC_ORG_TEMPLATE"))
    (let* ((tree (get-parsed-tree))
	   (hl (car-safe (org-element-map tree 'headline
			   (lambda (hl) (when
					    (string= raw-hl
						     (org-element-property :raw-value hl))
					  (org-element-context)))
			   nil nil t))))
      (cons
       (org-element-property :begin hl)
       (org-element-property :end hl))
      )))

(hl-region "Build Tools")

(4888 . 29646)

(defun get-hl-with-prop (org-dir hl-prop)
  "Given a directory containing an Org template file and a custom_id property name, return the headline containing that custom_id, or nil if none."
  (progn
    (cd org-dir)
    (let ((org-buf (car-safe (find-file-noselect "*.org" nil nil t))))
      (if org-buf
	  (with-current-buffer org-buf
	    (let ((tree (org-element-parse-buffer)))
	      (org-element-map tree 'headline
		(lambda (hl)
		  (let ((cid (org-element-property :CUSTOM_ID hl)))
		    (when (string= hl-prop cid)
		      (and
		       (message (format "Found the headline %s containing property %s." (org-element-property :raw-value hl) hl-prop))
		       hl))))
		nil t)))
	(and
	 (message (format "The directory %s does not contain an Org file." org-dir))
	 nil)))))

(get-hl-with-prop "~/Dev/Templates/Org" "build-tools")

(headline (:raw-value "Build Tools" :begin 4888 :end 29646 :pre-blank 0 :contents-begin 4902 :contents-end 29645 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 1 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 4888 :FROM-FILE "Template" :CUSTOM_ID "build-tools" :APPENDIX "t" :title "Build Tools"))









;;; Add a keyword named 'bucket' just after the version macro.
;;; This function should be run from within the directory containing the Org file.
(defun add-bucket (org-file s3-bucket)
  "Add the name of the associated AWS S3 bucket to an Org templated file."
  (with-current-buffer (find-file-noselect org-file)
    (goto-char (point-min))
    (let* ((tree (org-element-parse-buffer))
	   ;; find the beginning position of the first headline to act as a limit
	   (hl1 (org-element-map tree (quote headline) (lambda (hl) (org-element-property :begin hl)) nil t)))
      ;; Check for the presence of a bucket keyword before the first headline
      (unless (re-search-forward "^#\\+bucket:" hl1 t)
	;; If no bucket keyword is found, search for a keyword MACRO with the value 'version'
	(org-element-map tree (quote keyword)
	  (lambda (kw) (when (and (string= "MACRO" (org-element-property :key kw))
				  (string-match-p "version" (org-element-property :value kw)))
			 ;; return the end position of the MACRO; subtract an empty line if there is one
			 (goto-char (- (org-element-property :end kw) (org-element-property :post-blank kw)))
			 (insert "#+bucket:" s3-bucket)
			 (newline)
			 (basic-save-buffer)
			 (message (format "Added bucket %s" s3-bucket))))
	  nil t)))))

(add-bucket "MasteringEmacs.org" "pinecone-forest.com")
nil

"Added bucket pinecone-forest.com"









(keyword (:key "MACRO" :value "version Version 0.0.108" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...))
("TITLE" "SUBTITLE" "AUTHOR" "DATE" "MACRO" "TEXINFO" "TEXINFO" "CINDEX" "CINDEX" "CINDEX" "CINDEX" "CINDEX" ...)







((keyword (:key "MACRO" :value "version Version 0.0.107" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...)))
#+end_comment

* Macro Definitions
#+macro: heading @@texinfo:@heading @@$1
#+macro: subheading @@texinfo:@subheading @@$1
#+macro: dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+macro: noindent @@texinfo:@noindent @@
#+macro: option @@texinfo:@option{@@$1@@texinfo:}@@

* Export Setup                                                     :noexport:
#+texinfo_filename:mastering_emacs.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Emacs
#+texinfo_dir_title:Mastering
#+texinfo_dir_desc:notes about mastering Emacs
#+texinfo_printed_title:Mastering Emacs

* Options
#+options: H:4 toc:nil

* Local Variables                                                  :noexport:
# Local variables:
# fill-column: 79
# eval: (electric-quote-local-mode)
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
