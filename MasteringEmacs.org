# -*- mode: org; -*-

#+title:Mastering Emacs---Notes and Outline
#+subtitle:{{{version}}} {{{date}}}
#+author:Pinecone062
#+date:2020-02-14 08:04
#+macro:version Version 0.0.78

/{{{title}}}/ {{{version}}} compiled {{{date}}}

#+texinfo:@insertcopying

#+begin_smallquotation
Emacs outshines all other editing software in approximately the same
way that the noonday sun does the stars. It is not just bigger and
brighter; it simply makes everything else vanish.
#+texinfo:@author Neal Stephenson, "In the Beginning was the Command Line"
#+end_smallquotation

- [[https://www.gnu.org/software/emacs/][Gnu Emacs Home]]

- [[http://git.savannah.gnu.org/cgit/emacs.git][Emacs Source Repository]]

- [[https://www.masteringemacs.org/][Mastering Emacs]]

- [[https://www.gnu.org/software/emacs/manual/][Emacs Online Reference Manual]]

- [[https://www.gnu.org/software/emacs/manual/elisp.html][Emacs Online Lisp Reference Manual]]



* Overview
** In The Beginning
   + [[http://project.cyberpunk.ru/lib/in_the_beginning_was_the_command_line/][In the Beginning was the Command Line]]
   + Emacs began in 1976 https://www.gnu.org/software/emacs/manual/html_node/efaq/Origin-of-the-term-Emacs.html#Origin-of-the-term-Emacs
     
   + Came from an editor called Teco
** Some Implementations
:CP:
#+CINDEX: xemacs
#+CINDEX: sxemacs
:END:
   + XEmacs fork
     - [[http://www.xemacs.org]]
     - [[https://www.jwz.org/doc/lemacs.html]]
   + SXEmacs fork of XEmacs
     - [[http://www.sxemacs.org]]
   + and Gnu Emacs
     - [[https://www.gnu.org/software/emacs/]]
** Starter Packages
:CP:
#+CINDEX: starter packages
#+CINDEX: packages, starter
:END:
*** Emacs Wiki Starter Kits List

+ https://www.emacswiki.org/emacs/StarterKits
+ http://wikemacs.org/wiki/Starter_Kits

*** Phil Hagelberg “Technomancy”’s emacs-starter-kit and better-defaults

“Because the Emacs defaults are not so great sometimes.”

+ https://github.com/technomancy/emacs-starter-kit

+ https://github.com/technomancy/better-defaults

*** Eric Schulte’s Emacs Starter Kit

+ https://eschulte.github.io/emacs-starter-kit/
+ http://eschulte.github.io/emacs24-starter-kit/

*** Steve Purcell’s .emacs.d
:CP:
#+CINDEX:Steve Purcell @code{.emacs.d}
#+CINDEX:Purcell, Steve
:END:

[[https://www.youtube.com/watch?v=Gq0hG_om9xY][Steve Purcell interview by Sacha Chua]]

Steve Purcell's ~emacs~ config file is not meant to be a ``starter'' file, but
is famous in the community.  Purcell does not maintain it as a starter file,
but only for his own purposes.  He knows that it is forked and circulated, and
so allows it to be used for educational purposes I suppose.  He is a (the?)
maintainer of MELPA, and has written and reviewed a lot of elisp code.

“An Emacs configuration bundle with batteries included”

+ [[https://github.com/purcell/emacs.d]]

*** Bozhidar Batzov’s Prelude
:CP:
#+CINDEX: Batzov Prelude
#+CINDEX: Prelude from Batzov
:END:
    + [[https://github.com/bbatsov/prelude]]

*** Awesome Emacs
:CP:
#+CINDEX: Awesome Emacs
:END:
    + [[https://github.com/emacs-tw/awesome-emacs]]

*** Xah Emacs List of Starter Kits

+ http://ergoemacs.org/misc/list_of_emacs_starter_kits.html

*** An Emacs Starter Kit for the Social Sciences

- https://kieranhealy.org/resources/emacs-starter-kit/

*** Emacs Starter Kits

- https://riptutorial.com/emacs/topic/1960/starter-kits

** Lisp
*** eLisp Introduction
    + [[https://www.gnu.org/software/emacs/manual/eintr.html]]
:CP:
#+CINDEX: elisp
:END:
** Emacs as OS
*** C Core
When you run Emacs you are in fact  launching a tiny C core responsible for the
low-level interactions with your operating system’s ABI.  That includes mundane
things like  file-system and network  access; drawing  things to the  screen or
printing control codes to the terminal.
*** Elisp Interpreter
:CP:
#+CINDEX: elisp interpreter
#+CINDEX: ui thread
#+CINDEX: uptime
#+CINDEX: @code{M-x emacs-uptime}
:END:
The cornerstone of Emacs though is the elisp interpreter — without it, there is
no Emacs; speed  and asynchrony are the two main  issues.  The interpreter runs
in a single thread  and intensive tasks will lock the UI  thread. But there are
workarounds.

When  you write  elisp you  are not  just  writing snippets  of code  run in  a
sandbox,  isolated from  everything  — you  are altering  a  living system;  an
operating system running on an operating  system.  Every variable you alter and
every function  you call is  carried out by the  very same interpreter  you use
when you edit text.

Emacs  is  a hacker’s  dream  because  it is  one  giant,  mutable state.   Its
simplicity is  both a blessing and  a curse. You can  re-define live functions;
change variables left and right; and you  can query the system for its state at
any time — state that changes with every key stroke as Emacs responds to events
from your keyboard to your network  stack. Emacs is self-documenting because it
is the document. There  are no other editors that can do  that. No editor comes
close.

And yet Emacs never  crashes — not really, anyway. Emacs  has an uptime counter
to prove  that it doesn’t  (~M-x emacs-uptime~)  — multi-month uptimes  are not
uncommon.

So when you ask Emacs a question – as I will show you how to do later – you are
asking your Emacs  what its state is.  Because of this, Emacs  has an excellent
elisp debugger and un-limited access to  every facet of Emacs’s own interpreter
and state — so  it has excellent code completion too. Any  time you encounter a
lisp expression  you can tell  Emacs to evaluate it,  and it will:  from adding
numbers to setting variables to downloading packages.
*** Concepts
**** Buffer
:CP:
#+CINDEX: buffer
:END:
In Emacs, all files are buffers, but not all buffers are files.

Emacs uses these buffers for more than  just editing text. It can also act like
an I/O device  and talk to another process,  such as a shell like  bash or even
Python.

Almost all of Emacs’s own commands act  on buffers.  So when you tell Emacs to,
for example, search & replace it will actually search and replace on a buffer –
maybe the active  buffer you’re writing in, or perhaps  a temporary duplicate –
and not an internal data structure like you might think.

In Emacs, the buffer is the /data structure/.

This is an extremely powerful concept because the very same commands you use to
move  around  and edit  in  Emacs  are almost  always  the  same ones  you  use
behind-the-scenes in elisp. So once you memorize Emacs’s own user commands, you
can use them in a simple function call to mimic what you’d do by hand.
**** Windows and Frames
:CP:
#+CINDEX: windows
#+CINDEX: frames
:END:
The /frame/ is the window and the /window/  is the frame.  That is, a frame has
at least one  window, but can have  multiple windows, and each  window can have
one /buffer/.  That is, a /buffer/ must  be viewed in a /window/, which must be
in a /frame/.  A /frame/ is made up of /window/ panes.

You are  free to create as  many frames as you  like, and to tile  up the frame
into as many windows  as you like.  This allows you to  see multiple buffers on
the screen at one time.
**** Modeline Echo Area Minibuffer
:CP:
#+CINDEX: modeline
#+CINDEX: minibuffer
#+CINDEX: echo area
:END:
Emacs uses the /modeline/ to communicate facts about Emacs and the buffer you
are in.  This is equivalent to a /status bar/.  Many different kinds of
information can be displayed in the modeline.

The /minibuffer/ is below the modeline.  This is where errors and general
information is displayed.  It is nearly identical to a normal buffer; the
one-line minibuffer will expand to multiple lines if necessary.  It is how you
communicate with Emacs.

The /echo area/ and the /minibuffer/ share the same spot on the screen.
**** Point and Mark
:CP:
#+CINDEX: point
#+CINDEX: mark
#+CINDEX: region
#+CINDEX: transient mark mode
:END:
/Point/ is  your current cursor position  in a buffer.  Each  buffer tracks its
own point separately,  so each buffer has a different  position for point.  The
``current buffer'' is  that buffer which currently ``has the  point.''  This is
the buffer that you can write and move  around in.  Only one buffer can ever be
the ``current buffer'' at any one time.

The point  is one part of  a duo called /point  and mark/.  The point  and mark
represent the boundaries of a /region/, which is a contiguous block of text.
Emacs can show you the region.  This is called /transient mark mode/.
**** Killing Yanking and CUA
/Killing/ is cutting, /yanking/ is pasting, and copying is known as /saving to
the kill ring/.
**** Init Files
     + ~.emacs.d~
     + ~init.el~
     + ~.emacs~
**** Modes
Major modes in Emacs control how  buffers behave.  Each buffer will always have
a major  mode.  You are  free to change  a buffer’s major  mode at any  time by
typing the command for another one.  Each buffer can have just one major mode.

Minor modes, by contrast, are typically optional add-ons that you enable for
some (or all) of your buffers.

The major mode is  always displayed in the modeline. Some  minor modes are also
displayed in the modeline,  but usually only the ones that  alter the buffer or
how you interact with it in some way.

* Introduction
From the blog /Mastering Emacs/.  Check out the [[https://www.masteringemacs.org/all-articles][index of articles]].
See also the [[https://www.masteringemacs.org/reading-guide][Reading Guide]].

* First Steps
** Installing
*** Version
#+CINDEX: version
To check Emacs' version, type: ~emacs --version~

As of 2015 the upcoming version is GNU Emacs 25. If your version of Emacs is
version 23.x or older --- upgrade.

#+BEGIN_EXAMPLE
$ /usr/bin/emacs --version
GNU Emacs 22.1.1
Copyright (C) 2007 Free Software Foundation, Inc.
GNU Emacs comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies of Emacs
under the terms of the GNU General Public License.
For more information about these matters, see the file named COPYING.
#+END_EXAMPLE

*** Emacs on Mac OS
:CI:
#+CINDEX: Mac OS, installing
:END:
Mac OSX, in particular, seems to attract  a great deal of conflicting advice on
how  to best  run Emacs;  the best  advice  I can  offer is  to try  out a  few
different approaches and find one that fits you.

:CI:
#+CINDEX: Mac OS, unofficial builds
:END:
 + Unofficial build  --- One approach (though  there are several) is  to use an
   unofficial build of Emacs.

**** Emacs For Mac OSX
#+CINDEX: Emacs For Mac OSX
#+CINDEX: Mac OSX, flavors
[[http://emacsformacosx.com/][Emacs For Mac OSX]]

   - Pure Emacs! No extras! No nonsense!
   - About These Emacs Builds
     * I build three different release flavors of Emacs:
       1. Official releases --- These should be more stable but are not released
            very often.
       2. Pretests --- These are much more  stable and are meant for vetting the
                      code for last minute bugs before a final release.
       3. Nightlies ---  These are bleeding edge builds and  may have bugs. They
                       are built directly from the [[http://git.savannah.gnu.org/cgit/emacs.git/][public Git repository]]. I try
                       to build these nightly.
     * The scripts I run basically just  configure and build right from the GNU
       source --- I  don't add any patches or any  extraneous lisp packages.  I
       do include  the old  Carbon icon  on the  disk image  because I  like it
       better than the new Cocoa icon but it is not enabled by default.
     * Emacs is built on  various versions of Mac OS X: 10.6,  10.7 and 10.9 as
       of this writing. The 10.6 builds  also build 32-bit and PowerPC binaries
       (only Emacs 24 builds PowerPC ---  Emacs dropped support for it in Emacs
       25).  The  later OSes  only build  64-bit builds.  All the  binaries are
       combined  into a  single executable  and a  small Ruby  launcher chooses
       which binary to run based on the machine's OS and architecture.
     * Why not just use  a fat binary? Because fat binaries can  only hold 1 of
       each architecture and Emacs has multiple x86_64 architectures binaries.
     * Why are there multiple x86_64 binaries? Because the Emacs source does OS
       feature detection at compile time instead  of at run-time. So if I build
       Emacs on  10.9 then it  will contain hard-coded  calls to 10.9  APIs and
       will not run on 10.6. If I compile  it on 10.6, then it will also run on
       10.9, but it won't take advantage of any of the features in 10.9.
     * Because  of  the unstable  nature  of  nighly  builds, and  (sadly)  the
       relative fragility  of OS X  running on VMs,  there may be  days missing
       here and there.
     * *Note:* Recent Emacs builds (since 2009-12-09) have 64 bit Intel support
       in the Universal Binary. Yay!
     * *Also  Note:* Recent  Emacs builds  (since 2012-12-16)  have been  built
       against Mac OS 10.7 (Lion) and have  Lion full screen support if you are
       running on Lion  or Mountain Lion. They also have  better retina display
       support and are code signed. Also Yay!
     * *Also  Also  Note:*  Recent  Emacs  builds  (since  2016-08-15)  include
       ~gnutls~ (except on Mac OS 10.6 ---  Homebrew doesn't work on 10.6 and I
       don't want to spend a lot of  time compiling ~gnutls~ on a platform that
       is  barely  used).    You  can  now  use  https  urls   in  the  package
       configuration. Yay!
     * *Also Also  Also Note:*  Recent Emacs builds  (since 2018-04-10)  do not
       include  ~gnutls~  on  10.8  and lower.   Unfortunately  the  method  of
       downloading  ~gnutls~ (Homebrew)  stopped  working  because the  servers
       stopped  supporting old  SSL versions  and  10.8's SSL  libs aren't  new
       enough.  The  Emacs 26.0.91-1  pretest  is  the  last version  that  has
       ~gnutls~ on Mac OS 10.8.

#+CINDEX: Mac OSX, build scripts
   - The Build Scripts
     * Get them here: https://github.com/caldwell/build-emacs
     * I rewrote the build scripts in 2014 to make them more modular so I could
       easily control them with Jenkins. I  also moved them from shell to Ruby,
       which cleaned things up tremendously. They still aren't documented super
       well, but they should be easier to read, at least.

#+CINDEX: Mac OSX, tips and tricks
#+CINDEX: Mac OSX, @code{Emacs.app}
    - Tips  and  Tricks  --  Here  are  some tips  and  tricks  on  setting  up
      ~Emacs.app~ on  Mac OS X.  These  are based on my  personal experience of
      using ~Emacs.app~ for the past 10 years  or so; there may be better ways,
      but these work for me.

@@texinfo:@heading Running @code{Emacs.app} from the command line with @command{emacs}@@

Call this script @@texinfo:@command{emacs}@@ and put it somewhere in your
@@texinfo:@env{PATH}@@ (@@texinfo:@code{~/bin}@@ or
@@texinfo:@code{/usr/local/bin}@@):

#+BEGIN_EXAMPLE
#!/bin/sh
/Applications/Emacs.app/Contents/MacOS/Emacs "$@"
#+END_EXAMPLE

@@texinfo: @heading Using @command{emacsclient}@@

 1. Make sure the latest @@texinfo:@code{emacsclient}@@ binary is in your path:

#+BEGIN_EXAMPLE
ln -s /Applications/Emacs.app/Contents/MacOS/bin/emacsclient /usr/local/bin
# or ~/bin if you prefer
#+END_EXAMPLE

 2. Call this script @@texinfo:@command{ec}@@ and  put it somewhere in your @@texinfo:@env{PATH}@@
    (@@texinfo:@code{~/bin}@@ or @@texinfo:@code{/usr/local/bin}@@):

#+BEGIN_EXAMPLE
#!/bin/sh
which osascript > /dev/null 2>&1 && osascript -e 'tell application "Emacs" to activate'
emacsclient -c "$@"
#+END_EXAMPLE

 3.  Add   @@texinfo:@command{alias  emacs=ec}@@   or  @@texinfo:@command{alias
    emacsclient=ec}@@   to  your   @@texinfo:@code{.bashrc}@@.   Or   just  use
    @@texinfo:@command{ec}@@ directly.

@@texinfo:@heading Using Emacs as the @command{mergetool} for @command{git}@@

 1. Add add this snippet to your @@texinfo:@code{.gitconfig}@@:

#+BEGIN_EXAMPLE
[merge]
        tool = ediff
[mergetool "ediff"]
        cmd = emacs --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
#+END_EXAMPLE

 2. If you want to use @@texinfo:@command{emacsclient}@@, add this snippet
    instead:

#+BEGIN_EXAMPLE
[merge]
  tool = ediff
[mergetool "ediff"]
  cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
#+END_EXAMPLE

@@texinfo:@heading Changing the Modifier Keys@@

@@texinfo:@subheading Easy@@
The easiest way is to use the Customize interface: ~M-x customize-group RET ns RET~.

@@texinfo:@subheading Hard@@
If you don't like Customize and want to do it manually, the following variables
control the modifier keys:

 - ns-alternate-modifier
 - ns-command-modifier
 - ns-control-modifier
 - ns-function-modifier
 - ns-option-modifier (just a different name for ns-alternate-modifier)
 - ns-right-alternate-modifier
 - ns-right-command-modifier
 - ns-right-control-modifier
 - ns-right-option-modifier

Each variable can be set to ~'control~, ~'meta~, ~'alt~, ~'super~, or ~'hyper~.

In addition ~ns-alternative-modifier~ (and  ~ns-option-modifier~) can be set to
~'none~, which  lets it get interpreted  by the OS so  it can be used  to input
special characters.

The ~ns-right-*~  variables are set to  ~'left~ by default which  makes them the
same as their ~left~ counterpart.

@@texinfo:@heading Verifying the Binary Integrity@@

This  site serves  the binaries  via SSL  and while  the binaries  are not  GPG
signed, the application is code signed. You can verify the signature like this:
 : codesign -dvv /Applications/Emacs.app

Or, if you haven't installed emacs yet, but have mounted the disk image:
 : codesign -dvv /Volumes/Emacs/Emacs.app

Look for the following in the output:

#+BEGIN_EXAMPLE
Authority=Developer ID Application: Galvanix
Authority=Developer ID Certification Authority
Authority=Apple Root CA
#+END_EXAMPLE

~Galvanix~  is my  consulting partnership  and is  what I  registered my  Apple
developer account under. If you see that, the binary is intact.

**** Build Emacs from Source on OSX
#+begin_src sh
git clone git://git.savannah.gnu.org/emacs.git
cd emacs
./autogen.sh
./configure --with-ns
make install
cd nextstep
open Emacs.app 
#+end_src

**** Emacs-Mac by Mitsuharu Yamamoto
- https://bitbucket.org/mituharu/emacs-mac/overview
- https://github.com/railwaycat/homebrew-emacsmacport

**** Emacs Plus
- https://github.com/railwaycat/homebrew-emacsmacport

**** Emacs For Mac OS Wiki
:CI:
#+CINDEX: wiki, mac os
:END:
[[https://www.emacswiki.org/emacs/EmacsForMacOS][EmacsForMacOS Wiki]]

***** Distributions

****** Vanilla
These builds are based on the development version of GNU Emacs and do not
contain any additional packages or patches.  Popular Mac keyboard shortcuts are
available though (e.g. ~Command-O~ for opening a file); these are mapped to the
~Super~ modifier (i.e., the Apple/Command key functions as ~Super~).

#+CINDEX: EmacsForMacOS
[[http://emacsformacosx.com/][EmacsForMacOS]]

****** Extras

******* Mitsuhara Yamamoto's Mac Port
#+CINDEX: Mac Port
[[https://bitbucket.org/mituharu/emacs-mac/][Mac Port]]

 Based on the latest stable release of GNU Emacs (26.1 as of 2018-06-14) and
 claims to incorporate most of the features of Carbon Emacs and the
 Carbon+AppKit port from Emacs 22.3. It has improved ~C-g~ support, an emulation
 of ‘select’ that doesn’t require periodic polling, full screen support,
 subpixel font rendering, and smooth (pixel) scrolling.  See the [[https://bitbucket.org/mituharu/emacs-mac/][readme]] for more
 details. Available via Homebrew and MacPorts (as emacs-mac-app), as discussed
 below, or prebuilt binaries.

******* Aquamacs
#+CINDEX: Aquamacs
- [[http://aquamacs.org/][Aquamacs]]

- [[https://github.com/davidswelt/aquamacs-emacs/][Github Aquamacs-Emacs]]

Is a convenient distribution based on GNU Emacs 25.1.

Aquamacs comes preconfigured with a large number of packages and differs from
other Emacsen in that it feels more like a Mac OS X application.

OS X standard keyboard shortcuts are supported, files open in separate windows
or tabs, nice fonts are available, and it has a convenient drag&drop
installer.

Hundreds of file types are supported (C, Java, HTML, Python, Ruby, AppleScript,
XML, R (Splus), LaTeX (AUCTeX) etc.).

All these extra modes come included and readily configured – no InitFile
hacking.

Spell checking is easy to install (e.g., CocoAspell) and asian input methods
are also supplied, and options to deal with the missing Meta key on Mac
keyboards.

Aquamacs is based on Cocoa, the modern user interface framework in OS X.

It is a ready-to-use Universal App for PPC and Intel Macs that works well on
all recent Mac OS X versions.  Recommended for Mac users who want an Emacs that
is tailored to the Mac.

Experimental versions based on GNU Emacs 25 are also available.

******* Emacs Modified for macOS
- [[https://vigou3.gitlab.io/emacs-modified-macos/][Emacs Modified for macOS]]

*Emacs Modified for macOS* is a distribution of GNU Emacs 26.1 (released May
28, 2018) bundled with a few select packages for R developers and LaTeX users.
The distribution is based on the latest stable release of GNU Emacs compiled by
David Caldwell and distributed on Emacs for Mac OS X.

******** Philosophy
This distribution of Emacs is based on the NeXTstep port part of the official
sources of GNU Emacs. Other than the additions mentioned above and the minor
configurations found in the site-start.el file, this is a stock distribution of
Emacs. Users of Emacs on other platforms will appreciate the similar look and
feel of the application.

******** vs. Aquamacs
#+CINDEX: Aquamacs
Those looking for a more Mac-like version of Emacs may consider Aquamacs. I
used Aquamacs myself for two years, but I got tired of disabling the newer
“features” in each release of the application. For me Aquamacs insists too much
on opening new frames and on playing with fonts. Moreover, ESS is not kept up
to date on a regular basis.

****** Building From Source
- To download emacs using git, use this command:
  : git clone git://git.savannah.gnu.org/emacs.git
- Tarball Available from the [[http://savannah.gnu.org/projects/emacs/][GNU Savannah emacs]] page.  Click on “Download Area”
  under “Quick Overview”.

******* Building
- There are many options for building emacs (such as whether to build for the
  X11 GUI or the Cocoa GUI), which are discussed in the INSTALL file.
- There is also a script (~emacs/mac/make-package~) to create a Mac OS X
  package for use by the installer.
- The “normal” way to build Emacs under Mac OS X is:
#+BEGIN_EXAMPLE
./configure --with-ns
 make install
#+END_EXAMPLE
- When the build is complete, you should see ~Emacs.app~ in
  ~./nextstep/Emacs.app~.  Simply copy it to your applications folder and open
  it to run.
- For more detailed instructions, see the ~nextstep/INSTALL~ file.
- Additionally, you may benefit from reading the build script here: http://github.com/ieure/emacs-nightly.

**** iTerm Wiki for Emacs
:CI:
#+CINDEX: iTerm
:END:
[[https://www.emacswiki.org/emacs/iTerm2#toc11][iTerm Wiki for Emacs --- Super and Hyper Keys]]

***** Why getting Super and Hyper working in a terminal is not straightforward
The reason for this has to do a lot with DEC terminal history and the keys that
were available  in some of the  earliest possible terminals.  The  DEC terminal
became the default basis of emulation for most software.

Contrast  this with  the [[https://en.wikipedia.org/wiki/Space-cadet_keyboard][Space-cadet]]  keyboard  that influenced  the design  of
Emacs, made  for MIT Lisp  machines.  It  included several modifier  keys which
allowed multiple  character sets  as well  as a large  macro space  for binding
commands to key combinations.   Two modifier keys to the left  of the space bar
on the Space-cadet keyboard include the *Super* and *Hyper* keys.

While insanely  useful for the  experienced user,  fewer people worked  on Lisp
machines  compared  to  the  widespread  availability  of  VT-series  character
terminals. All  command line and  serial-terminal interaction you’ll  ever find
supports VT-100.

In GUI mode most emacsen will bind the Windows or Option key to *Super*U. Or if
you’re a Mac  user, you might have swapped  *Alt* and *⌘* so the  *Meta* key is
closest to the spacebar and easier to reach.

When  you press  a key  on your  keyboard your  terminal emulator  will send  a
character  or  an escape  sequence  down  the  connection.   For DEC  or  xterm
terminals, some keys may not send signals.  iTerm2 can make use of any key that
OSX will respond to and you can  customize it to run commands locally, remotely
or send signals down the terminal connection to the remote machine.

***** Testing escape codes
First,  connect  your  remote  machine  and  issue  the  cat  command  with  no
parameters. Depending on  your OS, termcap on the remote  and the codepage your
keyboard is set  to, you’ll see either  a character or an  escape sequence when
you type something.

Let’s see how the Latin letter ~O~ works when pressed with modifier keys.
 + When I press ~o~, I get an ~o~.
 + But when I press ~ALT+o~, I get ~^[o~
 + When I press ~CTRL+ALT+o~, I get ~^[^O~
 + And when I press ~SHIFT+ALT+o~, I get ~^[O~

These combos are being  read by the remote machine and being  fed to ~STDIN~ to
~cat~ (and ~cat~ is reading them back  as output).  They’re also the most basic
escape sequences, as ~^~ is the code for ~COMMAND~, and ~^[~ is for ~ALT/META~,
known  as the  escape sequence  ~^[~ .   For terminals  and IBM  PCs, the  ~^[~
signifies some sort  of terminal code, signifying a keypress  or some action to
be taken  on the terminal  or the  remote.  If your  keyboard has a  D-pad, try
hitting  ~<up> <down>  <right>~ and  ~<left>~.  Usually  these will  be ~^[[A~,
~^[[B~, ~^[[C~ and ~^[[D~, respectively.

You can press ~C-c~ to get out of ~cat~

Now let’s  try sending a  more complicated escape  sequence using some  keys on
your keyboard and fool Emacs on the  remote into thinking you pressed a *Hyper*
key combo.
 + Go into your iTerm2 settings for your connection profile.
 + In the Keys panel, let’s set a key combo for ~Ctrl+⌘+Option+A~, which is the
   three leftmost keys next to the space bar plus the letter ~A~.
 + I’m pretty confident your remote termcap probably does not have an entry for
   ~^[[1;P9~, so let’s start off with that code.
 + Your setting should look like this:
   + Keyboard Shortcut :: ~^+Option+Control+a~
   + Action :: Send Escape Sequence
   + Escape :: ~[1;P9~
 + Let’s get Emacs to listen for this key.  Evaluate the following Lisp code in
   an Emacs session (I  took the liberty of adding escapes for  the rest of the
   keys):
 + Now we can bind Hyper to something.  Let’s try this:
   + ~(global-set-key (kbd "H-a") 'dired)~
 + Now when  you press ~Ctrl+⌘+Option+A~, ~dired~ should pop  up.  Proceed with
   adding the rest  of the keys and  escape codes in your  iTerm2 setup.  Also,
   you can use the ~cat~ command to  check your work and ensure that the proper
   escape sequences are reaching the remote machine.
 + You can also  make combinations with ~Control~ and ~META~  such as ~C-c H-o~
   with this technique.  For ~C-c H-o~ you would hit ~C-c~ and then release the
   keys, then ~Ctrl+⌘+Option+o~ for the ~H-o~ part.
 +  Now  you can  make  loads  more keybindings  for  all  your favorite  Emacs
   commands.

** Starting
** Interface
** Keys
*** Control
*** Extended
*** Universal
*** Remembering Keys
** Configuring
*** Customizing
*** Evaluating Lisp
*** Package Manager
*** Color Themes
*** Mastering Key Bindings in Emacs
- https://www.masteringemacs.org/article/mastering-key-bindings-emacs


There’s a reason why the Emacs manual has dedicated 30-odd pages to describing,
in great detail, all the subtleties and nuances of how to bind keys.  I’ve
written a guide that covers what you need to know to bind keys to even complex
commands, and a set of templates you can use in your own code.

**** Keymaps
#+cindex:keymap
A {{{dfn(keymap)}}} is an internal data structure used by Emacs to store keys
and their associated actions.  Keymaps are rarely modified directly, but
through a set of commands that manipulate the data structure for you.

Every buffer and most major and minor modes have a keymap, and that keymap
defines what the keys do when key sequences are sent to that buffer.  Keys can
be divided into three categories:

#+cindex:prefix key
#+cindex:key, prefix
#+cindex:complete key
#+cindex:key, complete
- undefined :: self-explanatory
- prefix key :: are parts of a complete key, and each constituent part of a
                prefix key is made up of its own keymap
- complete key :: a command that, when input, executes its associated command


#+cindex:keys, show all
To enumerate all the active minor and major mode key bindings in a buffer,
type:

- =C-h m=


If you know part of a key sequence, type out that part, then type the following
to get a list of all keys that belong to that sequence.

- =C-h=

**** Key Bind Commands
There are several ways you can define (or undefine) keys.

- ~(define-key KEYMAP KEY DEF)~ ::

     #+cindex:@code{define-key}
     #+cindex:keyboard map
     #+cindex:keymap, keyboard
     Defines a key against a keyboard map.  Use this if you want to change a
     keymap that isn’t the current buffer map.

- ~(local-set-key KEY COMMAND)~ ::

     #+cindex:@code{local-set-key}
     #+cindex:local keymap
     #+cindex:keymap, local
     Binds a key to the local keymap used by the active buffer, unlike
     ~define-key~ which takes an explicit keymap to bind a key against.

- ~(global-set-key KEY COMMAND)~ ::

     #+cindex:@code{global-set-key}
     #+cindex:global keymap
     #+cindex:keymap, global
     Binds a key to the global keymap, making it available in all buffers (with
     a caveat---see below.)

- ~(global-unset-key KEY)~ ::

     #+cindex:@code{global-unset-key}
     #+cindex:global keymap
     #+cindex:keymap, global
     Removes KEY from the global keymap

- ~(local-unset-key KEY)~ ::

     #+cindex:@code{local-unset-key}
     #+cindex:local keymap
     #+cindex:keymap, local
     Removes KEY from the active, local keymap.

**** Representing Keys in Code
{{{heading(@@texinfo:@code{@@kbd@@texinfo:}@@)}}}

#+cindex:key as string, vector
#+cindex:vector key
#+cindex:@code{kbd} macro
In order to actually bind a key you must first tell Emacs what key you intend
to use.  Unfortunately there’s more than one way of representing keys in Emacs:
as a /string/, or as a /vector/.  There is a macro built in to Emacs called
{{{dfn(kbd)}}}, which translates a human-readable key into a format Emacs can
understand.

{{{heading(Function and Navigation Keys)}}}

One important point to note is that you must surround /function/ and
/navigation/ keys with =<= and =>=.  Those keys include F-keys, arrow keys and
home row keys, like so: =<home>=, =<f8>= and =<down>=.  But if you want to
represent the key =C-c p= then write ~(kbd "C-c p")~.

**** Remapping Commands
{{{heading(@@texinfo:@code{@@remap@@texinfo:}@@---Replace)}}}

#+cindex:@code{remap} event
#+cindex:@code{define-key} command
You can tell Emacs that you want to /replace/ all keys pointing to a certain
command with one of your own choosing by using the ~remap~ event; this should
be done instead of passing a key to the key bind function you are using.  This
is arguably the best way of replacing existing commands with your own as Emacs
will automagically handle the key reassignment in the background.

: (define-key (current-global-map) [remap kill-line] 'my-homemade-kill-line)

Here I globally remap all key binds that point to ~kill-line~ to
~my-homemade-kill-line~.

#+cindex:transient mark mode
For some more hands-on examples read my article [[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode][Fixing the Mark Commands in Transient Mark Mode]].

**** Reserved Keys
You can pick any keyboard combination you desire---even if that key bind is
already taken, so be careful.  But Emacs has set aside certain keys for use by
users.  Generally, all keys prefixed with =C-c ?= (where =?= is a single
character) are reserved for you, and you alone.  In practice most third-party
packages don’t give a hoot and will gladly stuff their own key binds in there.

The other set of reserved keys are the F-keys from =F5= and onwards.

{{{heading(Hyper and Super Prefix Keys)}}}

#+cindex:hyper key
#+cindex:super key
The other two prefix keys reserved to you are =hyper= and =super=.  They are
remnants from ancient keyboards used in the 80s, but live on today in Emacs.
Most PC-compatible keyboards won’t have a =super= or =hyper= key so some people
rebind the Windows key and the Application Context key to be =hyper= and
=super= instead.

#+caption:Symbolics's lisp machine keyboard PN 365407 Rev C. (Photo by Joey Devilla.)
#+name:fig-lisp-machine-super-hyper-keys
[[file:resources/images/lisp-machine-keyboard-2-left.jpg]]

[fn::From http://ergoemacs.org/emacs/emacs_hyper_super_keys.html]

- See [[http://ergoemacs.org/emacs/emacs_hyper_super_keys.html][Emacs: How to Bind Super Hyper Keys]].

- See [[http://irreal.org/blog/?p=1450][A Hyper Key for the Mac]]


If you want to use =hyper= then use the prefix key =H-= (e.g., =H-q=) and if
you want =super= use the prefix key =s-= (lower case).


{{{heading(On Mac OS X)}}}

#+caption:set keys for Apple keyboard, for emacs in OS X
#+name:set-keys-mac-os-x
#+begin_src emacs-lisp
;; set keys for Apple keyboard, for emacs in OS X
(setq mac-command-modifier 'meta) ; make cmd key do Meta
(setq mac-option-modifier 'super) ; make opt key do Super
(setq mac-control-modifier 'control) ; make Control key do Control
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper
#+end_src
*** Configuring the Emacs Frame Height
- See [[http://irreal.org/blog/?p=1331][More on Setting the Emacs Frame Height]]
*** Configuring File Name Completion
If you have changed your system's case-sensitivity setting[fn:1], have a look
at file name completion, [[ignore-case-variables][ignore case sensitivity]]:

** Help
*** Info
*** Apropos
*** Describe

* Directories---Files---Buffers
** Directories and File Names

#+texinfo:@heading Directory Variables

- [[*default-directory---a variable][~default-directory~]] --- a variable representing the current buffer's default
  directory


#+texinfo:@heading File Name Components

- [[*file-name-directory][~file-name-directory~]] --- the directory name of a file name (path) (ends with
  a trailing slash =/=)

- [[*file-name-as-directory][~file-name-as-directory~]] --- the directory name of a file name, or path (with
  a slash)

- [[*file-name-nondirectory][~file-name-nondirectory~]] --- the filename of a path (everything after last
  slash)

- [[*file-name-extension][~file-name-extension~]] --- the filename's extension

- [[*file-name-sans-extension][~file-name-sans-extension~]] --- the filename without its extension

- [[*directory-name-p][~directory-name-p~]] --- true for a directory name

- [[*directory-file-name][~directory-file-name~]] --- a directory file name (dirname) (file name without
  a trailing slash)


#+texinfo:@heading Absolute and Relative File Names

- [[*file-name-absolute-p][~file-name-absolute-p~]] --- true if the file name is absolute

- [[*file-relative-name][~file-relative-name~]] --- a relative file name in relation to a directory


#+texinfo:@heading Expanding and Abbreviating File Names

- [[*expand-file-name][~expand-file-name~]] --- expands to absolute an abbreviated file name

- [[*substitute-in-file-name][~substitute-in-file-name~]] --- expands environment variables in a file name
  (path)

- [[*abbreviate-file-name][~abbreviate-file-name~]] --- abbreviates an absolute file or directory name


#+texinfo:@heading Quoting File Names

- [[*file-name-quote][~file-name-quote~]] --- adds quote prefix to a file name

- [[*file-name-unquote][~file-name-unquote~]] --- removes quote prefix from a file name

- [[*file-name-quoted-p][~file-name-quoted-p~]] --- tests whether a file name is quoted


#+texinfo: @heading Magic File Names

- magic file names :: TODO

*** File Name Components

The operating system groups files into directories.  To specify exactly and
precisely (absolutely) a file[fn::some would call this a /path/], you must
specify the *directory* and the file's *file name* within that directory.

Therefore, Emacs considers a file name[fn:path:path] as having two main parts:

#+cindex:directory name
- the /directory name/ part; see [[*file-name-directory][~file-name-directory~]] and [[*file-name-as-directory][~file-name-as-directory~]]

- the nondirectory part (or /file name/ within the directory).  This is also
  sometimes referred to as a /relative file name/, since it is *relative* to
  the directory part.  The file name often has a /base name/ and an optional
  /extension/.

  - see [[*file-name-nondirectory][~file-name-nondirectory~]]

  - see [[*file-name-extension][~file-name-extension~]] and [[*file-name-sans-extension][~file-name-sans-extension~]]

  - see [[*file-name-base][~file-name~base~]]


Either part may be empty.  Concatenating these two parts reproduces the
original file name[fn:path].  On most systems, the directory part is everything
up to and including the last slash; the nondirectory part is the rest.

#+texinfo:@heading Absolute File Names

An /absolute file name/ specifies all the directory names starting from the
root of the tree.  An absolute file name starts with a ‘/’.

- see [[*file-name-absolute-p][~file-name-absolute-p~]]

#+texinfo:@heading Relative File Names

A /relative file name/ specifies the position of the file in the tree relative
to a default directory.  A relative file name does NOT start with a ‘/’.  It
can use abbreviations such as =.=, =..=, and =~=.

- see [[*file-relative-name][~file-relative-name~]]

#+texinfo:@heading Expanding File Names

Expanding a file name means converting a relative file name to an absolute one.
Since this is done relative to a default directory, you must specify the
default directory as well as the file name to be expanded.  It also involves
expanding abbreviations (e.g., =~=).

- see [[*expand-file-name][~expand-file-name~]]

- see [[*substitute-in-file-name][~substitute-in-file-name~]]

- see [[*abbreviate-file-name][~abbreviate-file-name~]]


#+texinfo:@heading Quoting File Name

Sometimes, it is not desired to expand file names.  In such cases, the file
name can be quoted to suppress the expansion, and to handle the file name
literally.  Quoting happens by prefixing the file name with ‘/:’.

- see [[*file-name-quote][~file-name-quote~]]

- see [[*file-name-unquote][~file-name-unquote~]]

- see [[*file-name-quoted-p][~file-name-quoted-p~]]

*** Directory Names and Directory File Names

#+texinfo:@heading Directory Name

#+cindex:directory name
A /directory name/ <<directory-name>> is a string that must name a directory if
it names any file at all.

- see [[*file-name-directory][~file-name-directory~]]

- see [[*file-name-as-directory][~file-name-as-directory~]]


#+texinfo:@heading Directory File Name

#+cindex:directory
#+cindex:directory file name
A /directory/ is actually a kind of file, and it has a file name (called the
/directory file name/ <<directory-file-name>>, which is related to the
/directory name/ but is typically not identical, e.g., it will not have a
trailing slash.

- See [[*directory-file-name][~directory-file-name~]]

#+texinfo:@heading The Difference

These two names for the same entity are related by a syntactic transformation:

- On GNU and other POSIX-like systems, to obtain a directory name, append a ‘/’
  to a directory file name that does not already end in ‘/’.

  : directory name = directory file name + /


The difference between a [[directory-name][directory name]] and a [[directory-file-name][directory file name]] is subtle but
crucial:

- When an Emacs variable or function argument is described as being a
  /directory name/, a /directory file name/ is not acceptable.

- When [[*file-name-directory][~file-name-directory~]] returns a string, that is always a /directory
  name/.

*** Directory and File Variables and Functions
**** default-directory---a variable

#+attr_texinfo: :options default-directory
#+begin_defvar
Name of default directory of current buffer.  It should be a [[directory-name][directory name]] (as
opposed to a [[directory-file-name][directory file name]]).  On GNU and Unix systems, [[directory-name][directory names]]
end in a slash ‘/’.
#+end_defvar

**** file-name-directory

#+attr_texinfo: :options file-name-directory filename
#+begin_defun
This function returns the /directory component/ of a file name.  Given a Unix
syntax file name, it returns a string ending in slash (=/=).

- FILENAME :: a file name (path)

- RETURN VALUE :: the directory component ([[directory-name][directory name]]) from FILENAME
  (path);

  nil if FILENAME does not include a directory.
#+end_defun

**** file-name-nondirectory

This function takes a full file name (path) and returns everything after the
last slash, or the full name if it contains no slash.  If the file name ends in
a slash, then this function will return the empty string.

#+attr_texinfo: :options file-name-nondirectory filename
#+begin_defun
- FILENAME :: a full file name (path)

- RETURN VALUE :: file name without its directory.
#+end_defun
**** file-name-extension

#+attr_texinfo: :options file-name-extension filename &optional period
#+begin_defun
- FILENAME :: a file name

- PERIOD :: if non-nil, include the period in the returned value; if file name
  has no extension, return the empty string rather than nil.

- RETURN VALUE :: the FILENAME's extension, i.e., the part that begins with the
  last ‘.’, or nil for extensionless file name, or the empty string if the file
  name ends with a period.
#+end_defun
**** file-name-sans-extension

#+attr_texinfo: :options file-name-sans-extension filename
#+begin_defun
- FILENAME :: a file name to work upon

- RETURN VALUE :: a file name without an extension; this includes the directory
  portion of the FILENAME, if any.
#+end_defun
**** file-name-base

#+attr_texinfo: :options file-name-base &optional filename
#+begin_defun
- FILENAME :: a file name to work upon; the default is [[*buffer-file-name][~buffer-file-name~]]

- RETURN VALUE :: the base name of the file name, i.e., no directory and no
  extension
#+end_defun
**** directory-file-name

This function returns a string representing /dirname/ in a form that the
operating system will interpret as the name of a file (a directory file name).
In general, it will return a name without a trailing slash.

This operation exists because a directory is also a file, but its name as a
directory is different from its name as a file.

#+attr_texinfo: :options directory-file-name directory
#+begin_defun
- DIRECTORY :: a directory to process; obtain its file name; in Unix-syntax,
  this function just removes the final slash.

- RETURN VALUE :: the file name of the directory named DIRECTORY (its directory
  file name).
#+end_defun
**** file-name-as-directory

This operation exists because a directory is also a file, but its name as a
directory is different from its name as a file.  The result can be used as the
value of ~default-directory~ or passed as second argument to
~expand-file-name~.

#+attr_texinfo: :options file-name-as-directory file
#+begin_defun
- FILE :: a file

- RETURN VALUE :: Return a string representing the file name FILE interpreted
  as a directory.  For a Unix-syntax file name, just appends a slash unless a
  trailing slash is already present.
#+end_defun
**** directory-name-p

#+attr_texinfo: :options directory-name-p name
#+begin_defun
- NAME :: potential file name to test

- RETURN VALUE :: non-nil if NAME ends with a directory separator character.
#+end_defun
**** file-name-absolute-p

This function tests whether a file name is absolute.  Given a possibly relative
file name, you can expand any leading ‘~’ and convert the result to an absolute
name using [[*expand-file-name][~expand-file-name~]].

#+attr_texinfo: :options file-name-absolute-p filename
#+begin_defun
- FILENAME :: the file name to test

- RETURN VALUE :: returns t if FILENAME is an absolute file name or begins with
  =~=; returns nil if not.
#+end_defun
**** file-relative-name

Convert an absolute file name to a relative file name in relation to a
directory.

#+attr_texinfo: :options file-relative-name filename &optional directory
#+begin_defun
- FILENAME :: a file name upon which to operate to convert it to be relative to
  DIRECTORY, which defaults to [[*default-directory---a variable][~default-directory~]].

- DIRECTORY :: a directory to act as a reference for this function;

- RETURN VALUE :: a relative file name which is equivalent to FILENAME in
  combination with DIRECTORY.
#+end_defun

**** file-name-quote

This macro adds the quotation prefix ‘/:’ to the file name.

#+attr_texinfo: :options file-name-quote name
#+begin_defun
- NAME :: a file name upon which to operate;

- RETURN VALUE :: the file name to which has been added the quotation prefix:
  ‘/:’;

  - local file name :: prefixes name with ‘/:’.

  - remote file name :: the local part of name (see Magic File Names) is
    quoted;

  - quote name :: If name is already a quoted file name, name is returned
    unchanged.
#+end_defun
**** file-name-unquote

This macro removes the quotation prefix ‘/:’ from the file name, if any.

#+attr_texinfo: :options file-name-unquote name
#+begin_defun
- NAME :: a file name upon which to operate

- RETURN VALUE :: the NAME without a quote prefix.  If name is a remote file
  name, the local part of name is unquoted.
#+end_defun
**** file-name-quoted-p

This macro returns non-nil, when name is quoted with the prefix ‘/:’.

#+attr_texinfo: :options file-name-quoted-p name
#+begin_defun
- NAME :: a file name to test

= RETURN VALUE :: returns non-nil, when name is quoted with the prefix ‘/:’; if
  name is a remote file name, the local part of name is checked.
#+end_defun

**** expand-file-name

Convert a relative file name to an absolute one and canonacilize it.  However,
use =(directory-file-name (file-name-directory dirname))= to traverse a
filesystem tree, not =(expand-file-name ".." dirname)=.

#+attr_texinfo: :options expand-file-name name &optional default-directory
#+begin_defun
- NAME :: a file name (a string that is a valid file name) upon which to
  operate: convert the file name to absolute and canonicalize it.  =~/= expands
  to the home directory.  =~USER= expands to USER's home directory.

- DEFAULT-DIRECTORY :: a directory used to start with if NAME is relative (does
  not start with slash or tilde);  this can be either a directory name or a
  directory file name; if nil or missing, the current buffer's value of
  ~default-directory~ is used.

- RETURN VALUE :: an absolute, canonacalized file name.
#+end_defun
**** substitute-in-file-name

This function replaces environment variable references in filename with the
environment variable values.

Sometimes, it is not desired to expand file names. In such cases, the file name
can be quoted to suppress the expansion, and to handle the file name
literally. Quoting happens by prefixing the file name with ‘/:’.

#+attr_texinfo: :options substitute-in-file-name filename
#+begin_defun
- FILENAME :: a file name upon which to operate; in FILENAME, substitute
  environment variables

- RETURN VALUE :: an absolute file name
#+end_defun
**** abbreviate-file-name

Converts a directory name to its abbreviation.  You can use this function for
directory names and for file names, because it recognizes abbreviations even as
part of the name.

#+attr_texinfo: :options abbreviate-file-name filename
#+begin_defun
- FILENAME :: an absolute file name upon which to operate;

- RETURN VALUE :: a shortened version of FILENAME, using
  ~directory-abbrev-alist~.  Also substitute =~= for the user's home directory
  and remove automounter prefixes.

  When this function is first called, it caches the user’s home directory as a
  regexp in ~abbreviated-home-dir~, and reuses it afterwards.
#+end_defun

** Files

#+texinfo:@heading Visiting Files

- [[*find-file][~find-file~]] ::

- [[find-file-literally][~find-file-literally~]] ::

- [[*find-file-noselect][~find-file-noselect~]] ::

- [[*find-file-other-window][~find-file-other-window~]] ::

- [[*find-file-read-only][~find-file-read-only~]] ::

- [[*find-file-wildcards --- User Option][~find-file-wildcards~]] --- user option ::

- [[*find-file-hook --- User Option][~find-file-hook~]] --- user option ::

- [[*find-file-not-found-functions --- Variable][~find-file-not-found-functions~]] --- variable ::

- [[*find-file-literally --- Variable][~find-file-literally~]] --- variable :: 


#+texinfo:@heading Saving Files

- [[*save-buffer][~save-buffer~]] ::

- [[*save-some-buffers][~save-some-buffers~]] ::

- [[*write-file][~write-file~]] ::

- [[*set-visited-file-name][~set-visited-file-name~]] ::

- [[*not-modified][~not-modified~]] :: 


#+texinfo:@heading Hooks Related to Saving

- [[*write-file-functions---a hook][~write-file-functions~]] ::

- [[*write-contents-functions---a hook][~write-contents-functions~]] ::

- [[*before-save-hook][~before-save-hook~]] ::

- [[*after-save-hook][~after-save-hook~]] :: 


#+texinfo:@heading Writing Buffers to Files

- [[*append-to-file][~append-to-file~]] ::

- [[*write-region][~write-region~]] ::

- [[*with-temp-file][~with-temp-file~]] ::


#+texinfo:@heading Errors

- handle errors :: 

  - ~system-messages-locale~ (a variable) ::

  - ~locale-coding-system~ (a variable) :: 


#+texinfo:@heading Creating Temporary Files

- [[*make-temp-file][~make-temp-file~]] :: create a unique temporary file

- [[*temporary-file-directory---a user option][~temporary-file-directory~]]---a user option :: default directory for storing
  temporary files

- [[*small-temporary-file-directory---a user option][~small-temporary-file-directory~]]---a user option :: a default directory for
  storing small temporary files

*** Visiting or Finding Files

#+cindex:visit a file
/Visiting/ a file means reading a *file* (information recorded in a computer)
into a *buffer* (information inside of Emacs that can be viewed and edited).
Once this is done, we say that the buffer is “visiting” that file, and call the
file “the visited file” of the buffer.  The buffer contains information copied
from the file.  If that information is changed, it must be *saved* (copied back
into the file) to make the changes permanent; otherwise the new information
will be lost.

Function names that visit files for historical reasons start with ~find-~
rather than ~visit-~.

In a Lisp program, if you want to look at the contents of a file but not alter
it, the fastest way is to use [[*Insert File Contents][~insert-file-contents~]] in a temporary buffer.
Visiting the file is not necessary and takes longer.

**** find-file

#+attr_texinfo: :options find-file filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, using an existing
buffer if there is one, and otherwise creating a new buffer and reading the
file into it.  It also returns that buffer.  This function is equivalent to:

 : (switch-to-buffer (find-file-noselect filename nil nil wildcards))

See [[switch-to-buffer][~switch-to-buffer~]].

- WILDCARDS :: if non-nil, expand wildcard characters in FILENAME and visit all
  of the matching files.  It is *always* true interactively.
#+end_defun

**** find-file-literally

#+attr_texinfo: :options find-file-literally filename
#+begin_defun
This command visits FILENAME, like ‘find-file’ does, but it does not perform
any format conversions (*note Format Conversion::), character code conversions
(*note Coding Systems::), or end-of-line conversions (*note End of line
conversion: Coding System Basics.).  The buffer visiting the file is made
unibyte, and its major mode is Fundamental mode, regardless of the file name.
File local variable specifications in the file (*note File Local Variables::)
are ignored, and automatic decompression and adding a newline at the end of the
file due to ‘require-final-newline’ (*note require-final-newline: Saving
Buffers.) are also disabled.

If you want to be sure of accessing a file’s contents literally, you should
create a temporary buffer and then read the file contents into it using
~insert-file-contents-literally~ (*note Reading from Files::).
#+end_defun

**** find-file-noselect

#+attr_texinfo: :options find-file-noselect filename &optional nowarn rawfile wildcards
#+begin_defun
This function returns a buffer visiting the file FILENAME.  It does *not* make
the buffer /current/ or /display/ it in a window.

The function returns an existing buffer if there is one; otherwise it creates a
new buffer and reads the file into it.

When this function uses an existing buffer, it first verifies that the file has
not changed since it was last visited or saved in that buffer.  If the file has
changed, this function asks the user whether to reread the changed file.  If
the user says ‘yes’, any edits previously made in the buffer are lost.

This function normally calls ~after-find-file~ after reading the file.  This
function sets the buffer major mode, parses local variables, warns the user if
there exists an auto-save file more recent than the file just visited, and
finishes by running the functions in ‘find-file-hook’.

- WILDCARDS :: if non-nil, expand wildcard characters in FILENAME and visit all
  of the matching files.

- NOWARN :: if non-nil, do not issue warnings.

- RAWFILE :: if non-nil, do not call ~after-find-file~, and
  ~find-file-not-found-functions~ are not run in case of failure, and
  suppresses coding system conversion and format conversion.

- RETURN VALUE :: usually returns the buffer that is visiting the file
  FILENAME.  If WILDCARDS are used, it returns a list of buffers that are
  visiting various files.
#+end_defun

**** find-file-other-window

#+attr_texinfo: :options find-file-other-window filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, but does so in a
window other than the selected window.  It may use another existing window or
split a window;
#+end_defun

**** find-file-read-only

#+attr_texinfo: :options find-file-read-only filename &optional wildcards
#+begin_defun
This command selects a buffer visiting the file FILENAME, like ‘find-file’, but
it marks the buffer as read-only.
#+end_defun

**** find-file-wildcards --- User Option

#+attr_texinfo: :options find-file-wildcards
#+begin_defvar
If this option is set to =nil=, then the various ~find-file~ functions ignore
their WILDCARDS argument and never treat wildcard characters specially.  The
default value is =t=.
#+end_defvar

**** find-file-hook --- User Option

#+attr_texinfo: :options find-file-hook
#+begin_defvar
The value of this variable is a list of functions to be called after a file is
visited.  The buffer visiting the file is current when the hook functions are
run.

#+cindex:hook
This is a normal hook.
#+end_defvar

**** find-file-not-found-functions --- Variable

#+attr_texinfo: :options find-file-not-found-functions
#+begin_defvar
The value of this variable is a list of functions to be called when ‘find-file’
or ‘find-file-noselect’ is passed a nonexistent file name.
‘find-file-noselect’ calls these functions as soon as it detects a nonexistent
file.  It calls them in the order of the list, until one of them returns
non-‘nil’.

#+cindex:hook, not normal
This is not a normal hook because the values of the functions are used, and in
many cases only some of the functions are called.
#+end_defvar

**** find-file-literally --- Variable

#+attr_texinfo: :options find-file-literally
#+begin_defun
If non-nil, makes ~save-buffer~ behave as if the buffer were visiting its file
literally, without conversions of any kind.

The command ~find-file-literally~ sets this variable’s local value, but other
equivalent functions and commands can do that as well.

This variable is permanent local, so it is unaffected by changes of major
modes.

#+end_defun

*** File Names
**** Minibuffer for File Names

#+texinfo:@heading Minibuffer

#+cindex:minibuffer
#+cindex:completion
#+cindex:history
While in the minibuffer, you can use the usual /completion/ and /history/
commands.  Minibuffer history commands offer some special features for reading
file names.

#+findex:find-file
#+cindex:visit file
#+cindex:minibuffer
- ~find-file~ (=C-x C-f=) :: use the /minibuffer/ to read a file name argument.
  Emacs obeys this command by /visiting/ the file: it creates a buffer, copies
  the contents of the file into the buffer, and then displays the buffer for
  editing.  If the file does not exist, this command creates an empty buffer;
  Emacs creates the file the first time you save this buffer.

- ~save-buffer~ (=C-x C-s=) :: you can save the new text in the file by typing
  =C-x C-s= (~save-buffer~).  This copies the altered buffer contents back into
  the file

#+texinfo:@subheading Completion

<<ignore-case-variables>>
#+vindex:read-file-name-completion-ignore-case
- ~read-file-name-completion-ignore-case~ :: when non-nil, ignore case when
  completing file names.
#+vindex:read-buffer-completion-ignore-case
- ~read-buffer-completion-ignore-case~ :: when non-nil, ignore case when
  completing buffer names.
  #+vindex:completion-ignored-extensions
- ~completion-ignored-extensions~ :: When completing file names, Emacs usually
  omits certain alternatives that are considered unlikely to be chosen, as
  determined by this list variable.

  It's value is:

  src_elisp[:eval yes :results output :exports results]{(princ completion-ignored-extensions)}
  #+vindex:completion-cycle-threshold
- ~completion-cycle-threshold~ :: If non-nil, completion commands can cycle
  through completion alternatives. If t, cycling is always used. 

#+texinfo:@subheading Permissive Completion with Confirmation

#+texinfo: @subheading Minibuffer History

#+cindex:minibuffer history
Every argument that you enter with the minibuffer is saved in a minibuffer
history list so you can easily use it again later.  Emacs keeps separate
history lists for several different kinds of arguments.  For example, there is
a list for file names, used by all the commands that read file names.  Other
history lists include buffer names, command names (used by M-x), and command
arguments (used by commands like ~query-replace~).  Use the following arguments
to quickly fetch an earlier argument into the minibuffer:

- ~previous-history-element~ (=M-p=)

- ~next-history-element~ (=M-n=)

- ~previous-line-or-history-element~ (=<UP>=)

- ~next-line-or-history-element~ (=<DOWN>=)

- ~previous-matching-history-element~ (=M-r regexp=)

- ~next-matching-history-element~ (=M-s regexp=)

- ~repeat-complex-command~ (=C-x <ESC> <ESC>=) : Re-execute a recent minibuffer
  command from the command history.  With no argument, it repeats the last such
  command. A numeric argument specifies which command to repeat; 1 means the
  last one, 2 the previous, and so on.  You can use the usual minibuffer
  history commands to move through the history list.

- ~list-command-history~ (=M-x list-command-history=) : open a new window with
  the list of commands
  #+vindex:command-history
- ~command-history~ : The list of previous minibuffer-using commands is stored
  as a Lisp list in this variable.  Lisp programs can re-execute a command by
  calling eval with the command-history element.

**** Default Directory

#+cindex:default directory
#+vindex:default-directory
- ~default-directory~ :: Each buffer has a default directory, stored in the
  buffer-local variable ~default-directory~.  Emacs always assumes that any
  relative file name is relative to the default directory,

  When you visit a file, Emacs sets ~default-directory~ in the visiting buffer
  to the directory of its file.

  #+findex:pwd
- ~pwd~ :: Show the current default directory.

  #+findex:cd
- ~cd DIR~ :: Make DIR become the current buffer’s default directory.

**** Quoting File Names
You can quote an absolute file name to prevent special characters and syntax in
it from having their special effects.  The way to do this is to add =/:= at the
beginning.
: /:/foo:/bar

**** Completion
After you type part of the argument, Emacs can fill in the rest, or some of it,
based on what was typed so far.  Certain keys (usually =<TAB>=, =<RET>=, and
=<SPC>=) are rebound in the minibuffer to special completion commands.  You can
usually type =?= to see a list of completion alternatives.

*** Saving Files

#+cindex:hooks
#+cindex:format conversion
Saving a buffer runs several hooks.  It also performs format conversion.  These
hooks are only run by ~save-buffer~; they are not run by other primitives and
functions that write buffer text to files.  Auto-saving does not run these
hooks.

**** save-buffer

#+attr_texinfo: :options save-buffer &optional arg
#+begin_defun
Save current buffer in visited file if modified.

- arg :: how to deal with backup files
#+end_defun

**** save-some-buffers

#+attr_texinfo: :options save-some-buffers &optional ARG PRED
#+begin_defun
Save some modified file-visiting buffers.  Asks user about each one.  You can
answer ‘y’ to save, ‘n’ not to save, ‘C-r’ to look at the buffer in question
with ~view-buffer~ before deciding or ‘d’ to view the differences using
~diff-buffer-with-file~.

This command first saves any buffers where ~buffer-save-without-query~ is
non-nil, without asking.

- ARG :: Optional argument ARG (interactively, prefix argument) non-nil means
  save all with no questions.

- PRED :: Optional second argument PRED determines which buffers are
  considered:

  - If PRED is nil, all the file-visiting buffers are considered.

  - If PRED is t, then certain non-file buffers will also be considered.

  - If PRED is a zero-argument function, it indicates for each buffer whether
    to consider it or not when called with that buffer current.

  - PRED defaults to the value of ‘save-some-buffers-default-predicate’.


See ~save-some-buffers-action-alist~ if you want to change the additional
actions you can take on files.
#+end_defun

**** write-file

#+attr_texinfo: :options write-file FILENAME &optional CONFIRM
#+begin_defun
Write current buffer into file FILENAME.  This makes the buffer visit that
file, and marks it as not modified.

If optional second arg CONFIRM is non-nil, this function asks for confirmation
before overwriting an existing file.
#+end_defun

**** set-visited-file-name

#+attr_texinfo: :options set-visited-file-name FILENAME &optional NO-QUERY ALONG-WITH-FILE
#+begin_defun
Change name of file visited in current buffer to FILENAME.  This also renames
the buffer to correspond to the new file.  The next time the buffer is saved it
will go in the newly specified file.

FILENAME nil or an empty string means mark buffer as not visiting any file.

The optional second argument NO-QUERY, if non-nil, inhibits asking for
confirmation in the case where another buffer is already visiting FILENAME.

The optional third argument ALONG-WITH-FILE, if non-nil, means that the old
visited file has been renamed to the new name FILENAME.
#+end_defun
**** not-modified

If you have changed a buffer but do not wish to save the changes, you should
take some action to prevent it.  Otherwise, each time you use =C-x s= or =C-x
C-c=, you are liable to save this buffer by mistake.  One thing you can do is
type =M-~= (not-modified), which clears out the indication that the buffer is
modified.  If you do this, none of the save commands will believe that the
buffer needs to be saved. (‘~’ is often used as a mathematical symbol for
“not”; thus =M-~= is “not”, metafied.)

#+attr_texinfo: :options not-modified &optional ARG
#+begin_defun
This function is for interactive use only; in Lisp code use
~set-buffer-modified-p~ instead.

Mark current buffer as unmodified, not needing to be saved.

With prefix ARG, mark buffer as modified, so C-x C-s will save.
#+end_defun
**** write-file-functions---a hook

#+attr_texinfo: :options write-file-functions
#+begin_defvar
This variable a list of functions to be called before writing out a buffer to
its visited file.  If one of them returns non-‘nil’, the file is considered
already written and the rest of the functions are not called, nor is the usual
code for writing the file executed.  In addition, if a function in
~write-file-functions~ returns non-‘nil’, it is responsible for making a backup
file, using the following code:

: (or buffer-backed-up (backup-buffer))

Even though this is not a normal hook, you can use ‘add-hook’ and ‘remove-hook’
to manipulate the list.
#+end_defvar

**** write-contents-functions---a hook

#+attr_texinfo: :options write-contents-functions
#+begin_defvar
This works just like ‘write-file-functions’, but it is intended for hooks that
pertain to the buffer’s contents, not to the particular visited file or its
location, and can be used to create arbitrary save processes for buffers that
aren’t visiting files at all.  Such hooks are usually set up by major modes, as
buffer-local bindings for this variable.

If any of the functions in this hook returns non-‘nil’, the file is considered
already written and the rest are not called and neither are the functions in
~write-file-functions~.
#+end_defvar

**** before-save-hook

#+attr_texinfo: :options before-save-hook
#+begin_defvar
This normal hook runs before a buffer is saved in its visited file, regardless
of whether that is done normally or by one of the hooks described above.
#+end_defvar
**** after-save-hook

#+attr_texinfo: :options after-save-hook
#+begin_defvar
This normal hook runs after a buffer has been saved in its visited file.
#+end_defvar

*** Backing Up Files

**** ~make-backup-files~---a variable

Emacs can be configured to make backup files on save in several different
ways, using the variable ~make-backup-files~, which by default is t.

- ~make-backup-files~ ::

  - non-nil means make a backup of a file the first time it is saved.  This can
    be done:

    - by renaming the file; the existing file is renamed so that it is a backup
      file; the buffer is then written into a new file with the original file
      name.

    - by copying the file; the existing file is copied into a backup file; then
      the buffer is written into the file, overwriting it with new content.

    - the choice of renaming or copying is controlled by the variables:

      - ~backup-by-copying~ :: non-nil means using copying

      - ~backup-by-copying-when-linked~ :: non-nil means using copying for
        files with multiple names.  The alternate names will refer to the
        latest version as edited.  ~backup-by-copying~ must be nil.

      - ~backup-by-copying-when-mismatch~ :: Non-nil means create backups by
        copying if this preserves owner or group.

      - ~backup-by-copying-when-priviledged-mismatch~ :: Non-nil means create
        backups by copying to preserve a privileged owner.

      - ~backup-inhibited~ :: If non-nil, backups will be inhibited.

**** Making Interactive Backups

By default, Emacs will only make a backup of a file the first time it is
saved.  You can explicitly control further backups as follows:

- =C-u C-x C-s= :: the version thus saved will be made into a backup file if
  you save the buffer again.

- =C-u C-u C-x C-s= :: saves the buffer, but first makes the previous file
  contents into a new backup file. 

- =C-u C-u C-u C-x C-s= :: does both things: it makes a backup from the
  previous contents, and arranges to make another from the newly saved contents
  if you save again.

**** Making Backups into Specific Directories

- ~backup-directory-alist~---a variable ::

  Use this variable to specify that files matching certain patterns should be
  backed up in specific directories.  A typical use is to add an element =("."
  . dir)= to make all backups in the directory with absolute name ~dir~.
  Alternatively, adding, =("." . ".~")= would make backups in the invisible
  subdirectory =.~= of the original file’s directory.

**** Single or Numbered Backups

When Emacs makes a backup file, its name is normally constructed by appending
‘~’ to the file name being edited.

Emacs can also make numbered backup files. Numbered backup file names contain
‘.~’, the number, and another ‘~’ after the original file name.

- ~version-control~ --- a variable :: determines whether to make single backup
  files or mul- tiple numbered backup files.  The usual way to set this
  variable is globally, through your init file or the customization buffer.
  But you can set version-control locally in an individual buffer to control
  the making of backups for that buffer’s file.

  - nil :: make single backups, unless files already have numbered backups.

  - t :: make numbered backups.

  - never :: never make numbered backups; always make single backups.

- ~make-backup-file-name-function~ :: tell Emacs what function to use to make
  backup names.

**** Automatic Backup Deletion

To prevent excessive consumption of disk space, Emacs can delete numbered
backup versions automatically.  Generally Emacs keeps the first few backups and
the latest few backups, deleting any in between.  This happens every time a new
backup is made.

- ~kept-old-versions~---a variable ::

  the number of oldest (lowest-numbered) backups to keep (default 2)

- ~kept-new-version~---a variable ::

  the number of newest (highest-numbered) ones to keep (default 2)

- ~delete-old-versions~ :: if t, Emacs deletes the excess backup files
  silently.  If nil, the default, Emacs asks you whether it should delete the
  excess backup versions.  If any other value, Emacs never automatically
  deletes backups.

- Dired =.= command :: can be used to delete old versions.
*** Writing to Files
You can write the contents of a buffer, or part of a buffer, directly to a file
on disk using the functions:

- ~append-to-file~

- ~write-region~


But don’t use these functions to write to files that are being visited.

**** append-to-file

#+attr_texinfo: :options append-to-file start end filename
#+begin_defun
This function appends the contents of the region delimited by START and END in
the current buffer to the end of file FILENAME.  If that file does not exist,
it is created.

When called from Lisp, this function is completely equivalent to:

: (write-region start end filename t)

- RETURN VALUE :: nil
#+end_defun

**** write-region

#+attr_texinfo: :options write-region start end filename &optional append visit lockname mustbenew
#+begin_defun
This function writes the region delimited by START and END in the current
buffer into the file specified by FILENAME.

If START is ‘nil’, then the command writes the entire buffer contents (_not_
just the accessible portion) to the file and ignores END.

If START is a string, then ‘write-region’ writes or appends that string, rather
than text from the buffer.  END is ignored in this case.

If APPEND is non-‘nil’, then the specified text is appended to the existing
file contents (if any).  If APPEND is a number, ‘write-region’ seeks to that
byte offset from the start of the file and writes the data from there.
#+end_defun

**** with-temp-file

#+attr_texinfo: :options with-temp-file file body
#+begin_defun
The ‘with-temp-file’ macro evaluates the BODY forms with a temporary buffer as
the current buffer; then, at the end, it writes the buffer contents into file
FILE.  It kills the temporary buffer when finished, restoring the buffer that
was current before the ‘with-temp-file’ form.  Then it returns the value of the
last form in BODY.

See also [[*with-temp-buffer][~with-temp-buffer~]].
#+end_defun

**** make-temp-file

Some programs need to write temporary files.  Here is the usual way to
construct a name for such a file.  The job of ~make-temp-file~ is to prevent
two different users or two different jobs from trying to use the exact same
file name.

#+attr_texinfo: :options make-temp-file prefix &optional dir-flag suffix text
#+begin_defun
This function creates a temporary file and returns its name by adding to PREFIX
some random characters that are different in each Emacs job.

- PREFIX :: a user-provided string that should be unique to this program; this
  helps Emacs generate a unique file name despite numerous programs in
  different jobs running simultaneously and using this macro.

- DIR-FLAG :: if non-nil, create a new, empty directory instead of a file.

- SUFFIX :: if non-nil, it is added to the end of the file name.

- TEXT :: if a string, insert it into the new file before returning; DIR-FLAG
  should be nil;

  if nil, leave the file empty.

- RETURN VALUE :: the newly-created file name pointing to a new-created file
  that is empty unless TEXT contains a string, in which case the file contains
  TEXT.
#+end_defun

If you want to write a temporary file which is likely to be small, you should
compute the directory like this:

#+caption:Creating a Small Temporary File
#+name:create-small-temp-file
#+begin_src elisp :eval never
  (make-temp-file
   (expand-file-name prefix
                     (or small-temporary-file-directory
                         temporary-file-directory)))
#+end_src

**** temporary-file-directory---a user option

The default directory for temporary files is controlled by the variable
~temporary-file-directory~.  This variable gives the user a uniform way to
specify the directory for all temporary files.  It will have a default value
consistent with the operating system so it does not need to be explicitly
created.

#+attr_texinfo: :options temporary-file-directory
#+begin_defvar
This variable specifies the directory name for creating temporary files.  Its
value should be a [[directory-name][directory name]], but a program should be able to handle a
[[directory-file-name][directory file name]] instead.

The default value is determined in a reasonable way for your operating system;
it is based on the =TMPDIR=, =TMP= and =TEMP= environment variables, with a
fall-back to a system-dependent name if none of these variables is defined.  At
the time of writing this, this variable’s default value is:
: /var/folders/x_/v2pfz45s7h3245q6wlvvvnyh0000gn/T/

The variable’s value can be customized from within Emacs.

The directory ~/var/folders/~ is owned by =root=, but the folders ~x/~ and
above are owned by the User.  ~x/~ was apparently created at the time the User
account was created, and the folders inside it were created in the recent past.

This variable works well as the optional default directory for
[[*expand-file-name][~expand-file-name~]].
#+end_defvar

**** small-temporary-file-directory---a user option

#+attr_texinfo: :options small-temporary-file-directory
#+begin_defvar
The directory for writing small temporary files.  If non-nil, use this
directory instead of [[*temporary-file-directory---a user option][~temporary-file-directory~]] when creating small temporary
files.  This is for systems that have fast storage with limited space, such as
a RAM disk.

It’s default value is nil.  It’s value can be customized.
#+end_defvar

** Buffers

#+texinfo:@heading Working with Buffers

- [[list-buffers][~list-buffers~]] invoke Buffer Menu

- [[ibuffer][=ibuffer=]] invoke Ibuffer-mode

- [[Icomplete][=Icomplete=]] global minor mode


#+texinfo:@heading Buffer Names

- [[*buffer-name][~buffer-name~]] return the name of the buffer

- [[*rename-buffer][~rename-buffer~]] rename a buffer


#+texinfo:@heading Interactive Buffer Commands using Windows

- [[switch-to-buffer][~switch-to-buffer~]] display a buffer in a window

- [[switch-to-buffer-other-window][~switch-to-buffer-other-window~]]

- [[switch-to-buffer-other-frame][~switch-to-buffer-other-frame~]]

- [[previous-buffer][~previous-buffer~]]

- [[next-buffer][~next-buffer~]]


#+texinfo:@heading Moving Around Within a Buffer

- [[goto-line][~goto-line~]]

- [[forward-line][~forward-line~]]


#+texinfo:@heading The Current Buffer for Editing

- [[*current-buffer][~current-buffer~]] return the current buffer

- [[*set-buffer][~set-buffer~]] make buffer current for editing

- [[*save-current-buffer][~save-current-buffer~]] save the current buffer before editing

- [[*with-current-buffer][~with-current-buffer~]] make buffer current temporarily for editing

- [[*with-temp-buffer][~with-temp-buffer~]] create a temporary buffer for editing


#+texinfo:@heading Working with Buffer Names

- [[*get-buffer][~get-buffer~]] return a buffer given a name

- [[*generate-new-buffer-name][~generate-new-buffer-name~]] just return a unique buffer name

- [[*buffer-file-name][~buffer-file-name~]] return the visited file's name

- [[*get-file-buffer][~get-file-buffer~]] return the buffer visiting the file name (exact) or nil

- [[*find-buffer-visiting][~find-buffer-visiting~]] return a buffer visiting the file name (not exact)

- [[set-visited-file-name][~set-visited-file-name~]] change the name of the visited file


#+texinfo:@heading Working with Buffer Contents

- [[*buffer-string][~buffer-string~]] return a buffer as a string


#+texinfo:@heading Creating and Killing Buffers

- [[*get-buffer-create][~get-buffer-create~]] creates or returns an existing buffer

- [[*generate-new-buffer][~generate-new-buffer~]] generate a new buffer with a unique name

- [[*create-file-buffer][~create-file-buffer~]] create a buffer and visit a file

- [[*kill-buffer][~kill-buffer~]] kill a buffer

#+cindex:buffer
A /buffer/ is a Lisp object containing text to be edited.  Buffers in Emacs
editing are objects that have distinct names and hold text that can be edited.
Each time you visit a file, a buffer is used to hold the file’s text.  Each
buffer has a unique name, which can be of any length.  Most buffers are made by
visiting files, and their names are derived from the files’ names; however, you
can also create an empty buffer with any name you want.

Buffers appear to Lisp programs as a special data type.  You can think of the
contents of a buffer as a string that you can extend; insertions and deletions
may occur in any part of the buffer.

#+texinfo:@heading Files and Windows

Buffers are used to hold the contents of files that are being visited; there
may also be buffers that are not visiting files.  Each time you invoke Dired, a
buffer is used to hold the directory listing.  If you send a message with ‘C-x
m’, a buffer is used to hold the text of the message.  When you ask for a
command’s documentation, that appears in a buffer named ‘*Help*’.  Each buffer,
including the current buffer, may or may not be displayed in any windows.  When
a buffer is displayed in a window, its name is shown in the mode line.

#+texinfo:@heading Current Buffer

#+cindex:current buffer
Only one buffer is selected and designated the [[*Current Buffer][current buffer]] at any time.
When a command operates on "the buffer", this really means that it operates on
the current buffer.  When there is only one Emacs window, the buffer displayed
in that window is current.  When there are multiple windows, the buffer
displayed in the “selected window” is current.

#+texinfo:@heading Properties

A buffer’s “contents” consist of a series of characters, each of which
optionally carries a set of text properties that can specify more information
about that character.

#+texinfo:@heading Buffer-Local Variables

#+cindex:buffer-local variables
Buffer-specific information that is directly accessible is stored in
/buffer-local variable/ bindings, which are variable values that are effective
only in a particular buffer.  This feature allows each buffer to override the
values of certain variables.  Most major modes override variables.

Aside from its textual contents, each buffer records several pieces of
information, such as what file it is visiting (if any), whether it is modified,
and what major mode and minor modes are in effect.  These are stored in
“buffer-local variables”---variables that can have a different value in each
buffer.

#+attr_texinfo: :options bufferp @var{object}
#+begin_defun
Return t if OBJECT is an editor buffer.
#+end_defun

*** Interactive Commands for Creating and Selecting Buffers

#+findex:list-buffers
- ~list-buffers &optional ARG~ (=C-x C-b=) ::
  <<list-buffers>>
  Invoke the Buffer Menu.  Display a list of existing buffers.  With prefix
  argument ARG, show only buffers that are visiting files.
  #+findex:buffer-menu
- ~buffer-menu &optional ARG~ ::
- ~buffer-menu-other-window~ ::
  Switch to the Buffer Menu.

  |            C            |       R       |           M           | Buffer | Size | Mode       | File         |
  |           <c>           |      <c>      |          <c>          |        |      |            |              |
  |-------------------------+---------------+-----------------------+--------+------+------------+--------------|
  | ~.~ the current buffer  | ~%~ read-only |     ~*~ modified      | name   | size | major mode | visited file |
  | ~>~ marked for display  |               | ~S~ marked for saving |        |      |            |              |
  | ~D~ marked for deletion |               |                       |        |      |            |              |


- ~buffer-menu-mode~ is the major mode for Buffer Menu buffers.

  - q --- leave Buffer Menu
  - RET --- select new current buffer this window
  - o --- select new current buffer other window
  - V --- select new current buffer in View mode
  - M-x Buffer-menu-view-other-window
  - C-o --- display buffer in another window
  - m --- make for display
  - v --- select this buffer and show marked buffers in other windows
  - 1 --- select this buffer in full-frame window
  - 2 --- select this buffer in half-window and other buffer in half window
  - M-s a C-s --- Incremental search in marked buffers
  - M-s a C-M-s --- Isearch for regext in marked buffers
  - t --- visit-tags-table this buffer
  - ~ --- clear modified flog on buffer
  - s --- mark for saving
  - C-k --- mark for deletion
  - C-d --- makr for deletion and move up
  - x --- delete or save marked buffers
  - u --- remove marks (ARG and move up)
  - M-DEL --- remove a mark from all lines
  - U --- remove all marks from all lines
  - DEL --- back up a line and remove marks
  - % --- toggle read-only status
  - g --- update
  - T --- toggle displaying only file buffers
  - b --- bury buffer

#+cindex:Icomplete global minor mode
- =Icomplete= <<Icomplete>>global minor mode (=M-x icomplete-mode=) :: provides
  a convenient way to quickly select an element among the possible completions
  in a minibuffer.  When enabled, typing in the minibuffer continuously
  displays a list of possible completions that match the string you have typed.
  At any time, you can type ‘C-j’ to select the first completion in the list.
  There are two ways to make an item first:

  1. You can type more of the completion name and thus narrow down the list;

  2. You can use ‘C-.’ and ‘C-,’ to rotate the list until the desired buffer is
     first.

  ‘M-<TAB>’ will select the first completion in the list, like ‘C-j’ but
  without exiting the minibuffer, so you can edit it further.  This is
  typically used when entering a file name, where ‘M-<TAB>’ can be used a few
  times to descend in the hierarchy of directories.

  - ~icomplete-mode~ variable :: nil to deselect; t to select.


#+cindex:Ibuffer-mode
- ~ibuffer~ :: <<ibuffer>>Begin using Ibuffer to edit a list of buffers.  Make
  a list of buffers and operate on them in Dired-like fashion.  Type ‘h’ after
  entering ibuffer for more information.
  #+findex:switch-to-buffer
- ~switch-to-buffer BUFFER-OR-NAME~ (=C-x b BUFFER=) ::
  <<switch-to-buffer>>

  If called interactively, read the buffer name using ‘read-buffer’.  The
  variable ~confirm-nonexistent-file-or-buffer~ determines whether to request
  confirmation before creating a new buffer.  If BUFFER-OR-NAME is a string
  that does not identify an existing buffer, create a buffer with that name.
  If BUFFER-OR-NAME is =nil=, switch to the buffer returned by ~other-buffer~
  (Return most recently selected buffer other than BUFFER).

  *WARNING*: This is NOT the way to work on another buffer temporarily within a
  Lisp program!  Use [[*set-buffer][~set-buffer~]] instead.  That avoids messing with the
  window-buffer correspondences.

- ~switch-to-buffer-other-window~ (=C-x 4 b BUFFER=) ::
  <<switch-to-buffer-other-window>>

- ~switch-to-buffer-other-frame~ (=C-x 5 b BUFFER=) ::
  <<switch-to-buffer-other-frame>>

- ~previous-buffer~ (=C-x <LEFT>=) ::
  <<previous-buffer>>

- ~next-buffer~ (=C-x <RIGHT>=) ::
  <<next-buffer>>

- ~goto-line LINE &optional BUFFER~ (=M-g g=) ::
  <<goto-line>>

  This function is for interactive use only (because it sets mark); in Lisp
  code use [[forward-line][~forward-line~]] instead.

  Go to LINE, counting from line 1 at beginning of buffer.  If called
  interactively, a numeric prefix argument specifies LINE; without a numeric
  prefix argument, read LINE from the minibuffer.

  If optional argument BUFFER is non-nil, switch to that buffer and move to
  line LINE there.  If called interactively with C-u as argument, BUFFER is the
  most recently selected other buffer.

  This function is usually the wrong thing to use in a Lisp program. What you
  probably want instead is something like:

  #+begin_src elisp :eval no
  (goto-char (point-min))
  (forward-line (1- N))
  #+end_src

  If at all possible, an even better solution is to use char counts rather than
  line counts.

- ~goto-line~ (=C-u M-g M-g=) ::

  reads a number N using the minibuffer, selects the most recently selected
  buffer other than the current buffer in another window, and then moves point
  to the beginning of line number N in that buffer.

  This is mainly useful in a buffer that refers to line numbers in another
  buffer: if point is on or just after a number, ‘goto-line’ uses that number
  as the default for N.

  Note that prefix arguments other than just ‘C-u’ behave differently.  ‘C-u 4
  M-g M-g’ goes to line 4 in the _current_ buffer, without reading a number
  from the minibuffer.

- ~forward-line &optional N~ ::
  <<forward-line>>

  Move N lines forward (backward if N is negative).  Precisely, if point is on
  line I, move to the start of line I + N.  If there isn’t room, go as far as
  possible (no error).

  - RETURN VALUE :: Returns the count of lines left to move.  If moving
    forward, that is N minus number of lines moved; if backward, N plus number
    moved.

*** Current Buffer
#+cindex:current buffer
At any time, one buffer is designated the /current buffer/---the buffer in
which most editing takes place.  Most of the primitives for examining or
changing text operate implicitly on the current buffer.

Normally, the buffer displayed in the selected window is the current buffer,
but this is not always so: a Lisp program can temporarily designate any buffer
as current in order to operate on its contents, without changing what is
displayed on the screen.

**** current-buffer

#+attr_texinfo: :options current-buffer
#+begin_defun
Return the current buffer as a Lisp object.
#+end_defun

**** set-buffer

#+attr_texinfo: :options set-buffer @var{buffer-or-name}
#+begin_defun
Make buffer BUFFER-OR-NAME current for editing operations.

- BUFFER-OR-NAME :: may be a buffer or the name of an existing buffer.
#+end_defun

When an editing command returns to the editor command loop, Emacs automatically
calls ~set-buffer~ on the buffer shown in the selected window.  you should not
use set-buffer to switch visibly to a different buffer; for that, use the
functions described in Switching Buffers.  However, when writing a Lisp
function, do not rely on this behavior of the command loop to restore the
current buffer after an operation.

To operate temporarily on another buffer, put the ~set-buffer~ within a
[[*save-current-buffer][~save-current-buffer~]] form.

**** save-current-buffer

#+attr_texinfo: :options save-current-buffer &rest body
#+begin_defun
Record which buffer is current; execute BODY; can use ~set-buffer~ to make a
different buffer current without displaying it.  At the conclusion of BODY,
make the original buffer current.

BODY is executed just like ‘progn’.
#+end_defun

**** with-current-buffer

#+attr_texinfo: :options with-current-buffer buffer-or-name &rest body
#+begin_defun
Execute the forms in BODY with BUFFER-OR-NAME temporarily current.

- BUFFER-OR-NAME :: must be a buffer or the name of an existing buffer.

- RETURN VALUE :: The value returned is the value of the last form in BODY.
#+end_defun

**** with-temp-buffer

#+attr_texinfo: :options with-temp-buffer &rest body
#+begin_defun
Create a temporary buffer, and evaluate BODY there like ‘progn’.

- RETURN VALUE :: The return value is the value of the last form in body.  You
  can return the contents of the temporary buffer by using ~buffer-string~ as
  the last form.
#+end_defun

**** buffer-string

#+attr_texinfo: :options buffer-string
#+begin_defun
Return the contents of the current buffer as a string.  If narrowing is in
effect, this function returns only the visible part of the buffer.
#+end_defun

*** Buffer Names and File Names
Each buffer has a unique name, which is a string.  Many of the functions that
work on buffers accept either a buffer or a buffer name as an argument.  Any
argument called BUFFER-OR-NAME is of this sort.  Any argument called BUFFER must
be an actual buffer object, not a name.

#+texinfo:@heading Buffer File Names

The /buffer file name/ is the name of the file that is visited in that buffer.
When a buffer is not visiting a file, its buffer file name is ‘nil’.  Most of
the time, the buffer name is the same as the nondirectory part of the buffer
file name, but the buffer file name and the buffer name are distinct and can be
set independently.

#+texinfo:@heading Buffer Name Functions

**** buffer-name

#+attr_texinfo: :options buffer-name &optional buffer
#+begin_defun
This function returns the name of BUFFER as a string.  BUFFER defaults to the
current buffer.
#+end_defun

**** rename-buffer

#+attr_texinfo: :options rename-buffer newname &optional unique
#+begin_defun
This function renames the current buffer to NEWNAME.

Ordinarily, ‘rename-buffer’ signals an error if NEWNAME is already in use.
However, if UNIQUE is non-‘nil’, it modifies NEWNAME to make a name that is not
in use.

This function returns the name actually given to the buffer.
#+end_defun

Also ~rename-uniquely~

**** get-buffer

#+attr_texinfo: :options buffer-or-name
#+begin_defun
This function returns the buffer specified by BUFFER-OR-NAME.

If BUFFER-OR-NAME is a string and there is no buffer with that name, the value
is ‘nil’.
#+end_defun

**** generate-new-buffer-name

#+attr_texinfo: :options starting-name &optional ignore
#+begin_defun
This function returns a name that would be unique for a new buffer---but does
not create the buffer.  It starts with STARTING-NAME, and produces a name not
currently in use for any buffer by appending a number inside of ‘<...>’.

If the optional second argument IGNORE is non-‘nil’, it should be a string, a
potential buffer name.  It means to consider that potential buffer acceptable,
if it is tried, even it is the name of an existing buffer (which would normally
be rejected).
#+end_defun

**** buffer-file-name

#+texinfo:@heading Buffer File Name Functions and Variables

#+attr_texinfo: :options buffer-file-name &optional buffer
#+begin_defun
This function returns the absolute file name of the file that BUFFER is
visiting (defaulting to the current buffer).  It returns 'nil' if BUFFER is not
visiting a file.
#+end_defun

**** buffer-file-name---a permanent buffer-local variable

#+attr_texinfo: :options buffer-file-name
#+begin_defvar
This buffer-local variable contains the name of the file being visited in the
current buffer, or ‘nil’ if it is not visiting a file.

Use [[*set-visited-file-name][~set-visited-file-name~]] to change this variable's value.
#+end_defvar

**** buffer-file-truename---a permanent buffer-local variable

#+attr_texinfo: :options buffer-file-truename
#+begin_defvar
This buffer-local variable holds the abbreviated [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Truenames.html#Truenames][truename]] of the file visited
in the current buffer, or ‘nil’ if no file is visited.
#+end_defvar

**** get-file-buffer

#+attr_texinfo: :options get-file-buffer filename
#+begin_defun
This function returns the buffer visiting file FILENAME, or 'nil' if there is
none.  The argument FILENAME, which must be a string, is expanded then compared
against the visited file names of all live buffers.  Note that the buffer’s
‘buffer-file-name’ must match the expansion of FILENAME exactly.

In unusual circumstances, there can be more than one buffer visiting the same
file name.  In such cases, this function returns the first such buffer in the
buffer list.
#+end_defun

**** find-buffer-visiting

#+attr_texinfo: :options find-buffer-visiting filename &optional predicate
#+begin_defun
This is like ‘get-file-buffer’, except that it can return any buffer visiting
the file possibly under a different name.  That is, the buffer’s
‘buffer-file-name’ does not need to match the expansion of FILENAME exactly, it
only needs to refer to the same file.

If PREDICATE is non-‘nil’, it should be a function of one argument, a buffer
visiting FILENAME.  The buffer is only considered a suitable return value if
PREDICATE returns non-‘nil’.
#+end_defun

**** set-visited-file-name
<<set-visited-file-name>>

#+attr_texinfo: :options set-visited-file-name filename &optional no-query along-with-file
#+begin_defun
If FILENAME is a non-empty string, this function changes (or sets) the name of
the file visited in the current buffer to FILENAME.  The next time the buffer
is saved it will go in the newly-specified file.

This command marks the buffer as modified.  It also renames the buffer to
correspond to the new file name, unless the new name is already in use.

If FILENAME is ‘nil’ or the empty string, that stands for “no visited file”.
In this case, ‘set-visited-file-name’ marks the buffer as having no visited
file, without changing the buffer’s modified flag.

Normally, this function asks the user for confirmation if there already is a
buffer visiting FILENAME.  If NO-QUERY is non-‘nil’, that prevents asking this
question.

If ALONG-WITH-FILE is non-‘nil’, that means to assume that the former visited
file has been renamed to FILENAME.  In this case, the command does not change
the buffer’s modified flag, nor the buffer’s recorded last file modification
time as reported by ‘visited-file-modtime’.  If ALONG-WITH-FILE is ‘nil’, this
function clears the recorded last file modification time, after which
‘visited-file
#+end_defun

*** Modifying Buffers

#+texinfo:@heading Modified Flag

#+cindex:modified flag
Emacs keeps a flag called the “modified flag” for each buffer, to record
whether you have changed the text of the buffer.  This flag is set to ‘t’
whenever you alter the contents of the buffer, and cleared to ‘nil’ when you
save it.

Some Lisp programs set the flag explicitly.  For example, the function
‘set-visited-file-name’ sets the flag to ‘t’, because the text does not match
the newly-visited file, even if it is unchanged from the file formerly visited.

**** buffer-modified-p

This function returns ‘t’ if the buffer BUFFER has been modified since it was
last read in from a file or saved, or ‘nil’ otherwise.

**** set-buffer-modified-p

This function marks the current buffer as modified if FLAG is non-‘nil’, or as
unmodified if the flag is ‘nil’.

Another effect of calling this function is to cause unconditional redisplay of
the mode line for the current buffer.

#+texinfo:@subheading @code{force-mode-line-update}

: (set-buffer-modified-p (buffer-modified-p))

**** restore-buffer-modified-p

Like ‘set-buffer-modified-p’, but does not force redisplay of mode lines.

**** not-modified

This command marks the current buffer as unmodified, and not needing to be
saved.

If ARG is non-‘nil’, it marks the buffer as modified, so that it will be saved
at the next suitable occasion.

Don’t use this function in programs, since it prints a message in the echo
area; use ~set-buffer-modified-p~ (above) instead.

**** buffer-modified-tick

This function returns BUFFER’s modification-count.  This is a counter that
increments every time the buffer is modified.

**** buffer-chars-modified-tick

This function returns BUFFER’s character-change modification-count.  Changes to
text properties leave this counter unchanged;

**** with-silent-modifications

Sometimes there’s a need for modifying buffer in a way that doesn’t really
change its text, like if only its text properties are changed.  If your program
needs to modify a buffer without triggering any hooks and features that react
to buffer modifications, use the ~with-silent-modifications~ macro.

**** Buffer Modification Time

When a buffer and its visited file are changed independently of each, saving
the buffer contents into the file would potentially lose new information.
Emacs therefore checks the file’s modification time using the functions
described below before saving the file.

**** verify-visited-file-modtime

This function compares what BUFFER (by default, the current-buffer) has
recorded for the modification time of its visited file against the actual
modification time of the file as recorded by the operating system.  The two
should be the same unless some other process has written the file since Emacs
visited or saved it.

The function returns ‘t’ if the last actual modification time and Emacs’s
recorded modification time are the same, ‘nil’ otherwise.

**** clear-visited-file-modtime

This function clears out the record of the last modification time of the file
being visited by the current buffer.  As a result, the next attempt to save
this buffer will not complain of a discrepancy in file modification times.

**** visited-file-modtime

This function returns the current buffer’s recorded last file modification
time, as a list of the form ‘(HIGH LOW MICROSEC PICOSEC)’.  (This is the same
format that ‘file-attributes’ uses to return time values;

**** set-visited-file-modtime

This function updates the buffer’s record of the last modification time of the
visited file, to the value specified by TIME if TIME is not ‘nil’, and
otherwise to the last modification time of the visited file.

**** ask-user-about-supersession-threat

This function is used to ask a user how to proceed after an attempt to modify a
buffer visiting file FILENAME when the file is newer than the buffer text.

**** Read-Only Buffers

Read-only buffers are used in two kinds of situations:

- A buffer visiting a write-protected file is normally read-only.

- Modes such as Dired and Rmail make buffers read-only when altering the
  contents with the usual editing commands would probably be a mistake.

**** buffer-read-only---a variable

This buffer-local variable specifies whether the buffer is read-only.

**** inhibit-read-only---a variable

If this variable is non-‘nil’, then read-only buffers and, depending on the
actual value, some or all read-only characters may be modified.

**** read-only-mode

This is the mode command for Read Only minor mode, a buffer-local minor mode.
When the mode is enabled, ‘buffer-read-only’ is non-‘nil’ in the buffer; when
disabled, ‘buffer-read-only’ is ‘nil’ in the buffer.

**** barf-if-buffer-read-only

This function signals a ‘buffer-read-only’ error if the current buffer is
read-only.

*** The Buffer List
*** Creating and Killing Buffers

#+texinfo:@heading Creating Buffers

#+cindex:create
There are two primitives for creating buffers, plus several others:

- ~get-buffer-create~ ::

  creates a buffer if it finds no existing buffer with the specified name;

- ~generate-new-buffer~ ::

  always creates a new buffer and gives it a unique name.

- ~with-output-to-temp-buffer~ ::

- ~create-file-buffer~ :: 

#+texinfo:@heading Killing Buffers

#+cindex:kill
/Killing a buffer/ makes its name unknown to Emacs and makes the memory space
it occupied available for other use.  The ‘buffer-name’ of a buffer is ‘nil’
if, and only if, the buffer is killed.  If you kill a buffer that is current or
displayed in a window, Emacs automatically selects or displays some other
buffer instead.  Killing a buffer can change the current buffer.  If you kill a
buffer that is the base buffer of one or more indirect buffers, the indirect
buffers are automatically killed as well.

#+cindex:live buffer
A buffer that has not been killed is called a /live/ buffer.  To test whether a
buffer is live or killed, use the function ~buffer-live-p~ (see below).

**** get-buffer-create

#+attr_texinfo: :options get-buffer-create buffer-or-name
#+begin_defun
- BUFFER-OR-NAME :: a buffer of this name is returned.  It does not become the
  current buffer, though.  If the buffer exists, it is returned.  If no such
  buffer exists, a new buffer is created.

  The major mode of a newly-created buffer is set to Fundamental.

  If the buffer name begins with a space, undo information recording is
  disabled.
#+end_defun

**** generate-new-buffer

#+attr_texinfo: :options generate-new-buffer name
#+begin_defun

- NAME :: This function returns a newly created, empty buffer, but does not
  make it current.  The name of the buffer is generated by passing NAME to the
  function [[*generate-new-buffer-name][~generate-new-buffer-name~]].

  The major mode for the new buffer is set to Fundamental mode.
#+end_defun

**** with-output-to-temp-buffer

#+attr_texinfo: :options with-output-to-temp-buffer bufname &rest body
#+begin_defun
Bind ‘standard-output’ to buffer BUFNAME, eval BODY, then show that buffer.
#+end_defun

**** create-file-buffer

#+attr_texinfo: :options create-file-buffer filename
#+begin_defun
Create a suitably named buffer for visiting FILENAME, and return it.
#+end_defun

**** kill-buffer

#+attr_texinfo: :options kill-buffer &optional buffer-or-name
#+begin_defun
- BUFFER-OR-NAME ::

  The buffer (or current buffer if the name is omitted) is killed, freeing all
  its memory.

  Any processes that have this buffer as the /process-buffer/ are sent the
  =SIGHUP= (hangup) signal, which normally causes them to terminate.

  If the buffer to be killed has unsaved changes, the user is asked to
  confirm.  To prevent the request, clear the =modified= flag before calling
  this function.  See [[*Modifying Buffers][Modifying Buffers]].

  This function calls ~replace-buffer-in-windows~ for cleaning up all windows
  currently displaying the buffer to be killed.

- RETURN VALUE ::

  t is returned if the buffer is actually killed.  'nil' is returned if the
  user refuses to confirm or if the buffer is already dead.
#+end_defun

**** kill-buffer-query-functions---a variable

#+attr_texinfo: :options kill-buffer-query-functions
#+begin_defvar
Before confirming unsaved changes, ‘kill-buffer’ calls the functions in the
list ‘kill-buffer-query-functions’, in order of appearance, with no arguments.
The buffer being killed is the current buffer when they are called.  The idea
of this feature is that these functions will ask for confirmation from the
user.  If any of them returns ‘nil’, ‘kill-buffer’ spares the buffer’s life.
#+end_defvar

**** kill-buffer-hook---a permanent local variable

#+attr_texinfo: :options kill-buffer-hook
#+begin_defvar
This is a normal hook run by ‘kill-buffer’ after asking all the questions it is
going to ask, just before actually killing the buffer.  The buffer to be killed
is current when the hook functions run.
#+end_defvar

**** buffer-offer-save---a buffer-local user-option

#+attr_texinfo: :options buffer-offer-save
#+begin_defvar
If non-'nil', tells ~save-buffers-kill-emacs~ to offer to save that buffer.

If ~save-some-buffers~ is called with its second optional argument set to t, it
will also offer to save the buffer.

If set to the symbol =always=, both ~save-buffers-kill-emacs~ and
~save-some-buffers~ will always offer to save.
#+end_defvar

**** buffer-save-without-query---a buffer-local variable

#+attr_texinfo: :options buffer-save-without-query
#+begin_defvar
If non-'nil', tells ~save-buffers-kill-emacs~ and ~save-some-buffers~ to save
this buffer if it is modified without asking.
#+end_defvar

**** buffer-live-p

#+attr_texinfo: :options buffer-live-p object
#+begin_defun
Returns t if OBJECT is a live buffer, or 'nil' otherwise.
#+end_defun

*** Indirect Buffers
#+cindex:indirect buffer
#+cindex:base buffer
An /indirect buffer/ shares the text of some other buffer, which is called the
/base buffer/ of the indirect buffer.

The text of the indirect buffer is always identical to the text of its base
buffer; changes made by editing either one are visible immediately in the
other.

But in all other respects, the indirect buffer and its base buffer are
completely separate.  They can have different names, different values of point,
different narrowing, different markers, different major modes, and different
local variables.

An indirect buffer cannot visit a file, but its base buffer can.  If you try to
save the indirect buffer, that actually works by saving the base buffer.
Killing the base buffer effectively kills the indirect buffer, but killing an
indirect buffer has no effect on its base buffer.

**** make-indirect-buffer

The general way to make an indirect buffer.

#+attr_texinfo: :options make-indirect-buffer base-buffer name &optional clone
#+begin_defun
Create and return an indirect buffer for buffer BASE-BUFFER, named NAME.

- BASE-BUFFER :: should be a live buffer or the name of an existing buffer.

- NAME :: should be a string which is not the name of an existing buffer.

- CLONE :: if non-nil, preserve BASE-BUFFER's state in the indirect buffer; if
  nil, the indirect buffer's state is reset to default values.
#+end_defun

**** clone-indirect-buffer
This function creates and returns a new indirect buffer that shares the current
buffer’s base buffer and copies the rest of the current buffer’s attributes.

If DISPLAY-FLAG is non-‘nil’, as it always is in interactive calls, that means
to display the new buffer by calling ~pop-to-buffer~.

#+attr_texinfo: :options clone-indirect-buffer newname display-flag &optional norecord
#+begin_defun
Create an indirect buffer that is a twin copy of the current buffer.

- NEWNAME :: name to give to the new indirect buffer.  If nil, defaults to the
  current buffer's name, modified by adding an <N> suffix to it, or
  incrementing the N in an existing suffix.

- DISPLAY-FLAG :: if non-nil, show the new buffer with ~pop-to-buffer~.

- NORECORD :: if non-nil, do not put this buffer at the front fo the list of
  recently selected ones.

- RETURN VALUE :: the newly-created indirect buffer.
#+end_defun

**** clone-indirect-buffer-other-window---C-x 4 c

#+attr_texinfo: :options clone-indirect-buffer-other-window NEWNAME DISPLAY-FLAG &optional NORECORD
#+begin_defun
Like ~clone-indirect-buffer~, but display in another window.
#+end_defun

**** buffer-base-buffer

#+attr_texinfo: :options buffer-base-buffer &optional buffer
#+begin_defun
This function returns the base buffer of BUFFER, which defaults to the current
buffer.  If BUFFER is not indirect, the value is ‘nil’.  Otherwise, the value
is another buffer, which is never an indirect buffer.
#+end_defun

*** Swapping Text

**** buffer-swap-text

#+attr_texinfo: :options buffer-swap-text buffer
#+begin_defun
Swap the text between current buffer and BUFFER.

This function is very fast because it doesn’t move any text, it only changes
the internal data structures of the buffer object to point to a different chunk
of text.  Using it, you can pretend that a group of two or more buffers are
actually a single virtual buffer that holds the contents of all the individual
buffers together.

If you use ~buffer-swap-text~ on a file-visiting buffer, you should set up a
hook to save the buffer’s original text rather than what it was swapped with.
~write-region-annotate-functions~ works for this purpose.  You should probably
set ~buffer-saved-size~ to −2 in the buffer, so that changes in the text it is
swapped with will not interfere with auto-saving.
#+end_defun

** Insert File Contents

#+cindex:file, insert
#+cindex:insert file
#+attr_texinfo: :indic code
In a Lisp program, if you want to look at the contents of a file but not alter
it, the fastest way is to use ‘insert-file-contents’ in a temporary buffer.
Visiting the file is not necessary and takes longer.

- insert-file =C-x i= ::

     This function is for interactive use only; in Lisp code use
     ~insert-file-contents~ instead

- insert-file-contents ::

     #+attr_texinfo: :options insert-file-contents @var{filename} &optional @var{visit} @var{end} @var{replace}
     #+begin_defun
     Insert contents of file FILENAME after point.  Returns list of absolute
     file name and number of characters inserted. 

     - VISIT if non-nil, the buffer’s visited filename and last save file
       modtime are set, and it is marked unmodified.

     - BEG and END specify what portion of the file to insert.
       These arguments count bytes in the file, not characters in the buffer.
       If VISIT is non-nil, BEG and END must be nil.

     - REPLACE if non-nil, replace the current buffer contents (in the
       accessible portion) with the file contents.  This is better than simply
       deleting and inserting the whole thing because (1) it preserves some
       marker positions and (2) it puts less data in the undo list.  When
       REPLACE is non-nil, the second return value is the number of characters
       that replace previous buffer contents.
     #+end_defun
* Movement

Movement in Emacs is more than characters in a buffer; there’s a host of
supplementary skills that make up navigation, like:

#+cindex:windowing system
- understanding Emacs’s rather complicated windowing system

- movement in Emacs is /local/, /regional/ or /global/.
  #+cindex:local movement
- /local movement/ is what you do when you edit and move around text near to
  the point.
  #+cindex:syntactic unit
- A /syntactic unit/ --- a semi-formal term for commands that operate on a
  group of characters --- is a character, word, line, sentence, paragraph,
  balanced expression, and so forth.
  #+cindex:regional movement
- /regional movement/ involves whole functions or class definitions, if you are
  writing code; or chapters and such constructs, if you are writing prose.
  #+cindex:global movement
- /global movement/ is anything that takes you from one buffer to another, or
  from one window to the next.

#+texinfo:@heading Windows

#+cindex:windows
#+cindex:tiling window manager
Emacs has a penchant for creating windows: when you view a help file, when you
compile a file, or when you open a shell.  Emacs is a /tiling window manager/.

In Emacs, windows are transient; they come and go as you need them.  You can
save your window configuration (and there are several ways of doing this) but
they were never meant to be immutable, like so many editors --- set once and
then never changed again.

#+texinfo:@heading Buffers

#+cindex:buffers
Buffers are rarely killed (that is, closed) when they are no longer needed;
most Emacs hackers will simply switch away to something else, only to return to
it when needed.  That may seem wasteful, but each buffer (aside from assorted
metadata and the buffer’s particular coding system) is only slightly bigger
than the byte size of the characters in it.  A typical Emacs session lasts
weeks between restarts and most Emacs hackers have many hundreds of buffers
running without issue.

** The Basics
Learning the basic key bindings to:

- find and save files,
- change buffers, and
- the bare essentials of day-to-day use 


{{{noindent}}}is the first step on the path to mastering Emacs.

#+caption:Basic Commands
#+name:basic-commands
| Key Binding | Command                      | Purpose                                     |
|-------------+------------------------------+---------------------------------------------|
| C-x C-f     | ~find-file~                  | Find and open a file                        |
| C-x C-s     | ~save-buffer~                | Save the buffer                             |
| C-x b       | ~switch-to-buffer~           | Switch buffer                               |
| C-x k       | ~kill-buffer~                | Kill (close) a buffer                       |
| C-x C-b     | ~list-buffers~               | Display all open buffers                    |
| C-x C-c     | ~save-buffers-kill-terminal~ | Exit Emacs                                  |
| esc-esc-esc | ~keyboard-escape-quit~       | Exit the current mode; return to one window |
| C-/         | ~undo~                       | Undo changes                                |
| F-10        | ~menu-bar-open~              | Activate the menu bar                       |
|-------------+------------------------------+---------------------------------------------|

*** find-file =C-x C-f= 
#+findex:find-file
To *open* a file is to /find/ or /visit/ it.  The two are synonymous.  If the
file does not exist, Emacs will open an empty buffer associated with that
filename.  If the file exists, Emacs will place the contents into a buffer
associated with that filename.

#+texinfo:@heading Major Mode Load Order

When you visit a file, Emacs will pick a major mode.  Emacs supports an array
of detection mechanisms that can all be changed to suit your needs.  They are
listed here in the order they are applied.

**** File-local variables

**** Program loader directives

**** Magic mode detection

**** Automatic mode detection

*** Coding Systems and Line Endings
Emacs applies two other important heuristics you should know about:
- coding systems and
- line endings.

**** Coding Systems
#+cindex:coding system
Emacs has excellent Unicode support, including:
- transparently reading and writing between different coding systems,
- bidirectional right-to-left script support,
- keyboard input method switching, and more.


#+findex:describe-coding-system
- ~describe-coding-system~ (=C-h C=) ::

  To see the coding system in use for the current buffer.  Emacs will display a
  lot of information, including all the coding systems associated with the
  buffer.  For files, they are almost always set to the same coding system.


The modeline will also provide some information:

: U:**-  helloworld.c       92% of 5k   ...

#+cindex:multi-byte
The first character, =U=, means the buffer ~helloworld.c~ has a *multi-byte*
coding system.

#+cindex:ISO character encoding
If it said =1=, it would typically be part 1 of any number of ISO character
encodings.  The exact mnemonic will depend on which of the hundreds of
supported coding systems you are using.

**** Line Endings
#+cindex:line endings
When you open a file, Emacs will determine the line endings used.

#+cindex:DOS line endings
#+cindex:UNIX line endings
If the file uses DOS or UNIX line endings, they will be preserved when you open
and save a file.

The modeline will tell you what line ending you are using:

: U:**-  helloworld.c       92% of 5k   ...

The : means it’s UNIX-style line endings.  For DOS it would say =(DOS)=.

** Window Management

** Frame Management

** Elemental Movement

** Bookmarks and Registers

[[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#index-bookmarks-559][Bookmarks in Manual §13.8]]

/Bookmarks/ record positions you can jump to.  They have long names, and they
persist automatically from one Emacs session to the next.  The prototypical use
of bookmarks is to record where you were reading in various files.

#+cindex:bookmark
Bookmarks in Emacs work identically to the ones in your web browser but with
the notable exception of supporting a wider variety of sources.  That makes
Emacs’s bookmarking system flexible enough for you to bookmark:

- info pages
- files
- dired directories
- remote files using Emacs' Tramp system


Bookmarks are a very efficient way of jumping to frequently-used files or
directories; it is also useful if there are sections of Emacs’s manual that you
want to return to frequently.  And because of the unified nature of Emacs ---
buffers --- the three are seamlessly stored and recalled from the same list of
bookmarks.

#+cindex:bookmark file
Bookmarks are saved to a bookmark file in ~$HOME/.emacs.d/~ called ~bookmarks~.

#+texinfo:@heading Bookmark File

#+vindex:bookmark-default-file
The variable ~bookmark-default-file~ determines where Emacs stores your
bookmarks.

#+cindex:s-expression
The file is plain text (elisp =s-expressions=, actually) meaning it is possible
edit it manually (if you absolutely must) or merge the files if you regularly
add or remove bookmarks from multiple machines.

Here is a sample entry:

#+begin_src elisp :eval never
("mastering-emacs.org"
 (filename . "~/Dev/Emacs/MasteringEmacs/MasteringEmacs.org")
 (front-context-string . "# -*- mode: org;")
 (rear-context-string)
 (position . 1))
#+end_src

#+texinfo:@heading Bookmark Commands

#+caption: Bookmark Commands
#+name:bookmark-commands
|-------------+---------------------|
| Key Binding | Purpose             |
|-------------+---------------------|
| C-x r m     | Set a bookmark      |
| C-x r l     | List bookmarks      |
| C-x r b     | Jump to a bookmark  |
|-------------+---------------------|

#+texinfo:@heading Register Commands

#+cindex:register
Registers, however, are different; they are the flip side of the coin --- where
bookmarks are permanent, registers are transient.  A /register/ is a
single-character store-and-recall mechanism for several types of data,
including:

- Window configurations and framesets
- Points
- Numbers and Text


A register is a single character only.  When you want to store or recall
something, you are asked for a single character to query.

#+caption:Register Commands
#+name:register-commands
|-------------+----------------------------------------|
| Key Binding | Purpose                                |
|-------------+----------------------------------------|
| C-x r n     | Store number in register               |
| C-x r s     | Store region in register               |
| C-x r SPC   | Store point in register                |
| C-x r +     | Increment number in register           |
| C-x r j     | Jumpt to register                      |
| C-x r i     | Insert content in register             |
| C-x r w     | Store window configuration in register |
| C-x r f     | Store frameset in register             |
|-------------+----------------------------------------|

** Selections and Regions

** Searching and Indexing

** Other Movement Commands

* Editing
** Killing and Yanking

** Transposing Text

** Filling and Commenting

** Searching and Replacing

#+cindex:regular expression
When you search for text, you can do so either with regular expressions or
without.  Replacing text in Emacs is no different, but with the added benefit
of letting you leverage the power of elisp in the /replace/ portion of search
and replace.

In that sense, Emacs is different from other editors: you can use elisp and
regexp capturing groups together --- powerful, if you know elisp.

#+cindex:PCRE
#+cindex:regular expression, GNU standard
Emacs’s regular expression implementation is also different from PCRE.  It
follows the GNU standard for regular expressions with many additions (and quite
a few omissions) to make it suitable for both package developers and Emacs
users.

*** Regular Expressions

#+cindex:regexp
Emacs’s regexp engine is nowhere near as user-friendly as it could be.  It’s
old, weathered and too entrenched --- and heavily modified to suit Emacs’s
peculiar needs --- to be easily replaced.  In practical terms, that causes
confusion in regexp building for people unaccustomed to Emacs’s quirky regexp
engine.  It’s even worse if you write elisp as you have to escape the escape
character as Emacs’s C-style string reader would otherwise trigger on
backslashes.

I will not cover regular expressions in great detail since that is a whole book
onto itself.  Instead, I will tell you how Emacs’s regexp engine differs from
modern ones.

**** Backslashed Constructs

The following constructs require backslashes or Emacs will treat them like
literal characters:

| Construct | Description     |
|-----------+-----------------|
| =\pipe=   | Alternative     |
| =\(...\)= | Capturing group |
| =\{...\}= | Repetition      |
|-----------+-----------------|


See also [[*Backslash Constructs][Backslash Constructs]]

**** Missing Features

**** Emacs-Only Features

#+cindex:match construct
#+cindex:Unicode
One area where Emacs’s regexp engine does shine is its support for /match
constructs/ and /Unicode support/:

#+caption:Match Constructs and Unicode Support
#+name:match-constructs-and-unicode-support
| Constructs   | Description                                               |
|--------------+-----------------------------------------------------------|
| =\<=, =\>=   | Matches beginning and end of word                         |
| =\_<=, =\_>= | Matches beginning and end of symbol                       |
| =\scode=     | Matches any character whose syntax table code is code     |
| =\Scode=     | Matches any character whose syntax table code is not code |
|--------------+-----------------------------------------------------------|

**** Syntax of Regular Expressions

#+cindex:syntax, regexp
#+cindex:regexp syntax
Regular expressions have a syntax in which a few characters are “special
constructs” and the rest are “ordinary”.

#+texinfo:@heading Special Characters

#+cindex:special characters, regexp
#+cindex:regexp special characters
The “special characters” are:

#+attr_texinfo: :indic code
- .
- *
- +
- ?
- [ and sometimes ]
- [: ... :]
- ^
- $
- \
- -


Any other character appearing in a regular expression is ordinary, unless a ‘\’
precedes it.

Things to note:

#+texinfo: :indic code
- ^ :: For historical compatibility reasons, ‘^’ can be used only at the
  beginning of the regular expression, or after ‘\(’, ‘\(?:’ or ‘\|’.

- $ :: For historical compatibility reasons, ‘$’ can be used only at the end of
  the regular expression, or before ‘\)’ or ‘\|’.

- \ :: also has special meaning in the read syntax of Lisp strings and must be
  quoted with ‘\’.

#+begin_example
\\   => \
\\\\ => \\
#+end_example

#+texinfo:@heading Character Alternatives

=[ ... ]= is a /character alternative/.

#+attr_texinfo: :indic code
- [ad] ::
- [a-z] ::
- [a-z$%.] ::
- []a-z]  :: To include a ‘]’ in a character alternative, you must make it the
  first character.
- []a-z-] :: To include a ‘-’, write ‘-’ as the first or last character of the
  character alternative, or as the upper bound of a range.
- ^ :: To include ‘^’ in a character alternative, put it anywhere but at the
  beginning.
  #+cindex:newline, regexp
- [^...] :: ‘[^’ begins a “complemented character alternative”.  This matches
  any character except the ones specified.  ‘^’ is not special in a character
  alternative unless it is the first character.  A complemented character
  alternative can match a newline, unless newline is mentioned as one of the
  characters not to match.  This is in contrast to the handling of regexps in
  programs such as ‘grep’.


#+texinfo:@heading Rules Regarding ]

The exact rules are that:
- at the beginning of a regexp, ‘[’ is special and ‘]’ not. 
- This lasts until the first unquoted ‘[’,
  - after which we are in a character alternative;
  - ‘[’ is no longer special
    - (except when it starts a character class)
  - but ‘]’ is special,
    - unless it immediately follows the special ‘[’ or
    - that ‘[’ followed by a ‘^’.
  - This lasts until the next special ‘]’ that does not end a character class.
- This ends the character alternative and restores the ordinary syntax of regular expressions;
- an unquoted ‘[’ is special again and a ‘]’ not.

#+texinfo:@heading POSIX Features

#+cindex:POSIX regexp
The following aspects of ranges are specific to Emacs, in that POSIX allows but
does not require this behavior and programs other than Emacs may behave
differently:

#+vindex:case-fold-search
#+cindex:collation sequence
#+cindex:unibyte character
1. If ~case-fold-search~ is non-‘nil’, =[a-z]= also matches upper-case letters.

2. A range is not affected by the locale’s collation sequence: it always
   represents the set of characters with codepoints ranging between those of
   its bounds, so that =[a-z]= matches only ASCII letters, even outside the C
   or POSIX locale.

3. As a special case, if either bound of a range is a raw 8-bit byte, the other
   bound should be a unibyte character, and the range matches only unibyte
   characters.

4. If the lower bound of a range is greater than its upper bound, the range is
   empty and represents no characters.  Thus, ‘[b-a]’ always fails to match,
   and ‘[^b-a]’ matches any character, including newline.  However, the lower
   bound should be at most one greater than the upper bound; for example,
   ‘[c-a]’ should be avoided.

5. A character alternative can also specify [[*Char Classes][named character classes]].  This is
   a POSIX feature.  Using a character class is equivalent to mentioning each
   of the characters in that class; but the latter is not feasible in practice,
   since some classes include thousands of different characters.  A character
   class should not appear as the lower or upper bound of a range.

**** Syntax Classes

#+cindex:syntax classes
#+cindex:classes, regexp syntax
#+cindex:regexp, syntax classes
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html#Syntax-Class-Table][Table of Syntax Classes]]

**** Char Classes

#+cindex:char classes, regexp
#+cindex:classes, regexp char
#+cindex:regexp, char classes
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Char-Classes.html#Char-Classes][Character Classes]]

**** Backslash Constructs

#+cindex:backslash, regexp
#+cindex:regexp backslash
For the most part, =\= followed by any character matches only that character.
However, there are several exceptions: certain sequences starting with =\= that
have special meanings.  Here is a table of the special =\= constructs.

- =\|= :: an alternative
- =\{M\}= :: repeat the previous pattern exactly M times
- =\{M,N\}= :: specifies repetition
- =\(...\)= :: a grouping construct
- =\(?:...\)= :: the “shy group” (“non-capturing” or “unnumbered”) construct
- =\(?NUM:...\)= :: the “explicitly numbered group” construct
- =\DIGIT= :: matches the same text that matched DIGITth occurrence of a group
- =\w= :: matches any word-constituent character
- =\W= :: matches any character that is not a work constituent
- =\sCODE= :: matches any character whose syntax is CODE
- =\SCODE= :: matches any character whose syntax is not CODE
- =\cC= :: matches any character whose category is C. =M-x describe-categories=
- =\CC= :: matches any character whose category is not C


The following regular expression constructs match the empty string---that is,
they don’t use up any characters---but whether they match depends on the
context.

#+attr_texinfo: :indic code
- \` :: matches the empty string, but only at the beginning of the buffer or
  string being matched against.
- \' :: matches the empty string, but only at the end of the buffer or string
  being matched against.
- \= :: matches the empty string, but only at point.
- =\b= :: matches the empty string, but only at the beginning or end of a word.
- =\B= :: matches the empty string, but _not_ at the beginning or end of a
  word, nor at the beginning or end of the buffer (or string)
- \< :: matches the empty string, but only at the beginning of a word.
- \> :: matches the empty string, but only at the end of a word.
- \_< :: matches the empty string, but only at the beginning of a symbol.
- \_> :: matches the empty string, but only at the end of a symbol.

*** Regular Expression Functions
These functions operate on regular expressions.

**** regexp-quote

#+attr_texinfo: :options regexp-quote string
#+begin_defun
This function returns a regular expression whose only exact match is STRING.
This allows you to request an exact string match or search when calling a
function that wants a regular expression.
#+end_defun

**** regexp-opt

#+attr_texinfo: :options regexp-opt strings &optional paren
#+begin_defun
This function returns an efficient regular expression that will match any of
the strings in the list STRINGS.  This is useful when you need to make matching
or searching as fast as possible—for example, for Font Lock mode.

- STRINGS :: list of strings

- PAREN :: The optional argument PAREN can be any of the following:

  - a string :: The resulting regexp is preceded by PAREN and followed by ‘\)’;
    =\\(?1:=

  - words :: The resulting regexp is surrounded by ‘\<\(’ and ‘\)\>’.

  - symbols :: The resulting regexp is surrounded by ‘\_<\(’ and ‘\)\_>’

  - non-nil :: The resulting regexp is surrounded by ‘\(’ and ‘\)’.

  - nil :: The resulting regexp is surrounded by ‘\(?:’ and ‘\)’
#+end_defun

**** regexp-opt-charset

#+attr_texinfo: :options regexp-opt-depth regexp
#+begin_defun
This function returns the total number of grouping constructs (parenthesized
expressions) in REGEXP.  This does not include shy groups.
#+end_defun

**** regexp-opt-charset chars

#+attr_texinfo: :options regexp-opt-charset chars
#+begin_defun
This function returns a regular expression matching a character in the list of
characters CHARS.
#+end_defun

*** Regular Expression Searching in Programs

**** re-search-forward

#+attr_texinfo: :options re-search-forward regexp &optional limit noerror count
#+begin_defun
This function searches forward in the current buffer for a string of text that
is matched by the regular expression REGEXP.  The function skips over any
amount of text that is not matched by REGEXP, and leaves point at the end of
the first match found.  It returns the new value of point.

- REGEXP :: The regexp to match against

- LIMIT :: The upper bound to the search, unless nil

- NOERROR :: What ‘re-search-forward’ does when the search fails depends on the
  value of NOERROR:

  - nil :: Signal a ‘search-failed’ error.

  - t :: Do nothing and return ‘nil’.

  - other :: Move point to LIMIT (or the end of the accessible portion of the
    buffer) and return ‘nil’.

- COUNT :: If COUNT is positive number, N, search N times.  If all searches
  succeed, function call succeeds, moves point and return point’s new value.
  Otherwise, function call fails.

  If COUNT is a negative number -N, the search is done N times in the backward
  direction.

- RETURN VALUE :: Upon success, the value of point; nil on failure.
#+end_defun

**** string-match

#+attr_texinfo: :options string-match regexp string &optional start
#+begin_defun
This function returns the index of the start of the first match for the regular
expression REGEXP in STRING, or ‘nil’ if there is no match

- REGEXP :: regexp to match against

- STRING :: string to use for match

- START :: if non-nil, start search at that index in STRING

- RETURN VALUE :: index of the start of the first match in STRING, or nil if
  there is no match.
  #+findex:match-end
- ~(match-end 0)~ :: If this function finds a match, the index of the first
  character beyond the match is available as ‘(match-end 0)’.


You can use the function <<match-string>> [[*match-string][~match-string~]] to extract the
substrings matched by the parenthesis constructions in REGEXP.
#+end_defun

**** string-match-p

#+attr_texinfo: :options string-match-p regexp string &optional start
#+begin_defun
This predicate function does what ~string-match~ does, but it avoids modifying
the match data.
#+end_defun

**** looking-at

#+attr_texinfo: :options looking-at regexp
#+begin_defun
This function determines whether the text in the current buffer directly
following point matches the regular expression REGEXP.  The result is ‘t’ if
so, ‘nil’ otherwise.  This function does not move point, but it does update the
match data.
#+end_defun

**** looking-at-p

#+attr_texinfo: :options looking-at-p regexp
#+begin_defun
This predicate function works like ‘looking-at’, but without updating the match
     data.
#+end_defun

**** looking-back

#+attr_texinfo: :options looking-back regexp limit &optional greedy
#+begin_defun
This function returns ‘t’ if REGEXP matches the text immediately before point
(i.e., ending at point), and ‘nil’ otherwise.

- REGEXP :: the regexp to match against

- LIMIT :: You can bound the time required by specifying a non-‘nil’ value for
  LIMIT, which says not to search before LIMIT.

- GREEDY :: If GREEDY is non-‘nil’, this function extends the match backwards
  as far as possible, stopping when a single additional previous character
  cannot be part of a match for REGEXP.  When the match is extended, its
  starting position is allowed to occur before LIMIT.
#+end_defun

**** search-spaces-regexp---a variable

#+attr_texinfo: :options search-spaces-regexp
#+begin_defun
If this variable is non-‘nil’, it should be a regular expression that says how
to search for whitespace.  In that case, any group of spaces in a regular
expression being searched for stands for use of this regular expression.

Since this variable affects all regular expression search and match constructs,
you should bind it temporarily for as small as possible a part of the code.
#+end_defun

*** Replacing Text Using Match Data

#+cindex:match data
Emacs keeps track of the start and end positions of the segments of text found
during a search; this is called the “match data”.

All functions are allowed to overwrite the match data unless they’re explicitly
documented not to do so.  A consequence is that functions that are run
implicitly in the background should likely save and restore the match data
explicitly.

**** replace-match

This function replaces all or part of the text matched by the last search.  It
works by means of the match data.

#+attr_texinfo: :options replace-match replacement &optional fixedcase literal string subexp
#+begin_defun
This function performs a replacement operation on a buffer or string.

- REPLACEMENT :: The String to replace the matched text

- FIXEDCASE :: If FIXEDCASE is non-‘nil’, then ~replace-match~ uses the
  replacement text without case conversion; otherwise, it converts the
  replacement text depending upon the capitalization of the text to be
  replaced.

- LITERAL :: If LITERAL is non-‘nil’, then REPLACEMENT is inserted exactly as
  it is, the only alterations being case changes as needed.  If it is ‘nil’
  (the default), then the character ‘\’ is treated specially.

  If a ‘\’ appears in REPLACEMENT, then it must be part of one of the following
  sequences:

  - =\&= :: This stands for the entire text being replaced.

  - =\N= :: where N is a digit; this stands for the text that matched the Nth
    subexpression in the original regexp.

  - =\\= :: This stands for a single ‘\’ in the replacement text.

  - =\?= :: This stands for itself (for compatibility with ‘replace-regexp’ and
    related commands;

  - any other :: error

- STRING :: If you performed the last search on a string, pass the same string
  as STRING.  Then this function returns a new string, in which the matched
  text is replaced by REPLACEMENT.

- SUBEXP :: If SUBEXP is non-‘nil’, that says to replace just subexpression
  number SUBEXP of the regexp that was matched, not the entire match.
#+end_defun

#+texinfo:@heading Replace All Matches in Part of a Buffer

If you want to find all matches for a regexp in part of the buffer, and replace
them, the best way is to write an explicit loop using [[*re-search-forward][~re-search-forward~]] and
~replace-match~, like this:

#+begin_src elisp :eval no
  (while (re-search-forward "foo[ \t]+bar" nil t)
    (replace-match "foobar"))
#+end_src

Replacing matches in a string is more complex, especially if you want to do it
efficiently.  So Emacs provides a function to do this: [[*replace-regexp-in-string][~replace-regexp-in-string~]].

**** match-substitue-replacement

#+attr_texinfo: :options match-substitute-replacement replacement &optional fixedcase literal string subexp
#+begin_defun
This function returns the text that would be inserted into the buffer by
‘replace-match’, but without modifying the buffer.

It is useful if you want to present the user with actual replacement result,
with constructs like ‘\N’ or ‘\&’ substituted with matched groups.

Arguments REPLACEMENT and optional FIXEDCASE, LITERAL, STRING and SUBEXP have
the same meaning as for ‘replace-match’.

#+end_defun
**** replace-regexp-in-string

#+attr_texinfo: :options replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
#+begin_defun

This function uses [[*replace-match][~replace-match~]] to do the replacement.

- REGEXP :: the regexp to use

- REP :: replacement string or function.

  If a function, ~replace-regexp-in-string~ calls REP for each match, passing
  the text of the match as its sole argument.  It collects the value REP
  returns and passes that to ~replace-match~ as the replacement string.

- STRING :: string to search; this function copies STRING and searches it for
  matches for REGEXP, and replaces them with REP.

- FIXEDCASE :: passed to ~replace-match~

- LITERAL :: passed to ~replace-match~

- SUBEXP :: passed to ~replace-match~

- START :: If START is non-‘nil’, the search for matches starts at that index
  in STRING, so matches starting before that index are not changed.

- RETURN VALUE :: It returns the modified copy.
#+end_defun

**** perform-replace

If you want to write a command along the lines of ~query-replace~, you can use
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Search-and-Replace.html#Search-and-Replace][~perform-replace~]] to do the work.

#+attr_texinfo: :options perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end backward region-noncontiguous-p
#+begin_defun
This function is the guts of ‘query-replace’ and related commands.

It searches for occurrences of FROM-STRING in the text between positions START
and END and replaces some or all of them.  If START is ‘nil’ (or omitted),
point is used instead, and the end of the buffer’s accessible portion is used
for END.  (If the optional argument BACKWARD is non-‘nil’, the search starts at
END and goes backward.)
#+end_defun

*** Accessing Matched Text Using Match Data
This section explains how to use the match data to find out what was matched by
the last search or match operation, if it succeeded.

Every successful search sets the match data.  You should query the match data
immediately after searching, before calling any other function that might
perform another search, or save and restore the match data around the call to
functions that could perform another search, or use the functions that
explicitly do not modify the match data.

You can ask about the entire matching text, or about a particular parenthetical
subexpression of a regular expression, using the COUNT argument.

- If count is zero, you are asking about the entire match.
- If count is positive, it specifies which subexpression you want.

**** match-string

#+attr_texinfo: :options match-string count &optional in-string
#+begin_defun

- COUNT :: if zero, return the entire matched text; if positive integer,
  return the COUNTth matched parenthetical subexpression.

- IN-STRING :: If the last such operation was done against a string with
  [[match-string][~string-match~]], then you should pass the same string as the argument
  IN-STRING.

  After a buffer search or match, you should omit IN-STRING or pass ‘nil’ for
  it; but you should make sure that the current buffer when you call
  ~match-string~ is the one in which you did the searching or matching.

- RETURN VALUE :: The matched text or a portion of the matched text as a string
  depending on the value of COUNT.

  The value is ‘nil’ if COUNT is out of range, or for a subexpression inside a
  ‘\|’ alternative that wasn’t used or a repetition that repeated zero times.

#+end_defun

**** match-string-no-properties

#+attr_texinfo: :options match-string-no-properties count &optional in-string
#+begin_defun
This function is like ~match-string~ except that the result has no text
properties.
#+end_defun

**** match-beginning

#+attr_texinfo: :options match-beginning count
#+begin_defun
If the last regular expression search found a match, this function returns the
position of the start of the matching text or of a subexpression of it.

- COUNT :: If COUNT is zero, then the value is the position of the start of the
  entire match.  Otherwise, COUNT specifies a subexpression in the regular
  expression, and the value of the function is the starting position of the
  match for that subexpression.

  The value is ‘nil’ for a subexpression inside a ‘\|’ alternative that wasn’t
  used or a repetition that repeated zero times.
#+end_defun

**** match-end

#+attr_texinfo: :options match-end count
#+begin_defun
This function is like ~match-beginning~ except that it returns the position of
the end of the match, rather than the position of the beginning.
#+end_defun

**** match-data

#+attr_texinfo: :options match-data &optional integers reuse reseat
#+begin_defun
This function returns a list of positions (markers or integers) that record all
the information on the text that the last search matched.

- RETURN VALUE ::

  - Element zero is the position of the beginning of the match for the whole
    expression;

  - element one is the position of the end of the match for the expression.

  - The next two elements are the positions of the beginning and end of the match
    for the first subexpression, and so on.

  - In general, element number 2N corresponds to ‘(match-beginning N)’; and
  element number 2N + 1 corresponds to ‘(match-end N)’.

- INTEGERS :: Applies only to buffer searches; normally all the elements are
  markers or ‘nil’, but if INTEGERS is non-‘nil’, that means to use integers
  instead of markers.  (In that case, the buffer itself is appended as an
  additional element at the end of the list, to facilitate complete restoration
  of the match data.)

- REUSE :: If REUSE is non-‘nil’, it should be a list.  In that case,
  ‘match-data’ stores the match data in REUSE.  REUSE is destructively
  modified.  The purpose of this feature is to reduce the need for garbage
  collection.

- RESEAT :: If RESEAT is non-‘nil’, all markers on the REUSE list are reseated
  to point to nowhere.
#+end_defun

**** set-match-data

#+attr_texinfo: :options set-match-data match-list &optional reseat
#+begin_defun
This function sets the match data from the elements of MATCH-LIST, which should
be a list that was the value of a previous call to ‘match-data’.

If RESEAT is non-‘nil’, all markers on the MATCH-LIST list are reseated to
point to nowhere.
#+end_defun

**** save-match-data

#+attr_texinfo: :options save-match-data body
#+begin_defun
This macro executes BODY, saving and restoring the match data around it.  The
return value is the value of the last form in BODY.
#+end_defun

*** Using RE Builder Command

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Regular-Expressions.html#Regular-Expressions


For interactive development of regular expressions, you can use the =M-x
re-builder= command.  It provides a convenient interface for creating regular
expressions, by giving immediate visual feedback in a separate buffer.  As you
edit the regexp, all its matches in the target buffer are highlighted.  Each
parenthesized sub-expression of the regexp is shown in a distinct face, which
makes it easier to verify even very complex regexps.

#+attr_texinfo: :options re-builder
#+begin_defun
Construct a regexp interactively.

This command makes the current buffer the "target" buffer of
the regexp builder.  It displays a buffer named "*RE-Builder*"
in another window, initially containing an empty regexp.

As you edit the regexp in the "*RE-Builder*" buffer, the
matching parts of the target buffer will be highlighted.
#+end_defun

** Changing Case

** Counting

** Text Manipulation

** Keyboard Macros

** Text Expansion

** Indenting

** Sorting and Aligning

** Zapping

** Spell Checking

** Quoted Insert

** Comparing Diffing and Merging
{{{heading(Diff Mode)}}}

=M-x diff= command produces Diff mode, which displays the differences between
two files in a =*diff*= buffer through running the ~diff~ program.  Switches
are found in the ~diff-switches~ variable (the default is =-u=, a unified
context diff).

{{{heading(Ediff Package)}}}

Ediff is a more sophisticated alternative to Diff mode.  See info:ediff.

{{{heading(Comparing a File to a Backup)}}}

=M-x diff-backack= compares a file with its most recent backup.  If you specify
the name of a backup file, this command compares it with the source file
instead.  Otherwise, it is the same as =M-x diff=.

{{{heading(Compare a Buffer with its File)}}}

=M-x diff-buffer-with-file= compares a specified buffer with its corresponding
file.  This shows you what changes you would make to the file if you save the
buffer.

{{{heading(Compare Windows)}}}

=M-x compare-windows= compares the text in the current window with that in the
window that was the selected window before you selected the current one.

{{{heading(Smerge Mode)}}}

=M-x smerge-mode= turns on Smerge mode, a minor mode for editing output from
the ‘diff3’ program.

{{{heading(Emerge)}}}

The Emerge commands compare two files or buffers, and display the comparison in
three buffers: one for each input text (the “A buffer” and the “B buffer”), and
one (the “merge buffer”) where merging takes place.  The merge buffer shows the
full merged text, not just the differences.  Wherever the two input texts
differ, you can choose which one of them to include in the merge buffer.

- =M-x emerge-files= :: to merge two specific files.

- =M-x emerge-files-with-ancestor= :: to merge two files with reference to a
     common ancestor.

- =M-x emerge-buffers= :: to merge two buffers

- =M-x emerge-buffers-with-ancestor= :: to merge two buffers with reference to
     a common ancestor in a third buffer.

*** Diff Mode
#+cindex:diff mode
Used for the output of =M-x diff=.  Select Diff mode manually with =M-x
diff-mode=.

- =M-x diff= ‘(diff OLD NEW &optional SWITCHES)’ :: Find and display the
     differences between OLD and NEW files.  When called interactively, read
     NEW, then OLD, using the minibuffer.  The default for NEW is the current
     buffer’s file name, and the default for OLD is a backup file for NEW, if
     one exists.  When called interactively with a prefix argument, prompt
     interactively for diff switches.  Otherwise, the switches specified in the
     variable ‘diff-switches’ are passed to the diff command.

{{{heading(Hunks)}}}

#+cindex:hunks
#+cindex:hunk header
The changes specified in a patch are grouped into “hunks”, which are contiguous
chunks of text that contain one or more changed lines.  Each hunk is preceded
by a “hunk header”, which specifies the old and new line numbers where the
hunk’s changes occur.  Diff mode highlights each hunk header

{{{subheading(File Header)}}}

#+cindex:file header
The first hunk in a patch is preceded by a file header, which shows the names
of the new and the old versions of the file, and their time stamps.

{{{subheading(Editing Hunks)}}}

- =M-n= ‘(diff-hunk-next)’ :: Move to the next hunk-start (‘diff-hunk-next’).
     With prefix argument N, move forward to the Nth next hunk.

- =M-p= ‘(diff-hunk-prev)’ :: Move to the previous hunk-start
     (‘diff-hunk-prev’).  With prefix argument N, move back to the Nth previous
     hunk.

- =M-}= ‘(diff-file-next)’ :: Move to the next file-start, in a multi-file
     patch (‘diff-file-next’).  With prefix argument N, move forward to the
     start of the Nth next file.

- =M-{= ‘(diff-file-pref)’ :: Move to the previous file-start, in a multi-file
     patch (‘diff-file-prev’).  With prefix argument N, move back to the start
     of the Nth previous file.

- =M-k= ‘(diff-hunk-kill)’ :: Kill the hunk at point (‘diff-hunk-kill’).

- =M-K= ‘(diff-file-kill)’ :: In a multi-file patch, kill the current file
     part.  (‘diff-file-kill’).

- =C-c C-a= ‘(diff-apply-hunk)’ :: Apply this hunk to its target file
     (‘diff-apply-hunk’).  With a prefix argument of ‘C-u’, revert this hunk,
     i.e. apply the reverse of the hunk, which changes the “new” version into
     the “old” version.

- =C-c C-b= ‘(diff-refine-hunk)’ :: Highlight the changes of the hunk at point
     with a finer granularity (‘diff-refine-hunk’).  This allows you to see
     exactly which parts of each changed line were actually changed.

- =C-c C-c= ‘(diff-goto-source)’ :: Go to the source file and line
     corresponding to this hunk (‘diff-goto-source’).  By default, this jumps
     to the “new” version of the file, the one shown first on the file header.
     With a prefix argument, jump to the “old” version instead.

- =C-c C-e= ‘(diff-ediff-patch)’ :: Start an Ediff session with the patch
     (‘diff-ediff-patch’).  See info:ediff

- =C-c C-n= ‘(diff-restrict-view)’ :: Restrict the view to the current hunk
     (‘diff-restrict-view’).  *Note info:emacs#Narrowing.  With a prefix argument,
     restrict the view to the current file of a multiple-file patch.  To widen
     again, use ‘C-x n w’ (‘widen’).

- =C-c C-d= ‘(diff-unified->context)’ :: Convert the entire buffer to the
     “context diff format” (‘diff-unified->context’).  With a prefix argument,
     convert only the hunks within the region.

- =C-c C-u= ‘(diff-context->unified)’ :: Convert the entire buffer to unified
     diff format (‘diff-context->unified’).  With a prefix argument, convert
     unified format to context format.  When the mark is active, convert only
     the hunks within the region.

- =C-c C-w= ‘(diff-ignore-whitespace-hunk)’ :: Re-generate the current hunk,
     disregarding changes in whitespace (‘diff-ignore-whitespace-hunk’).

- =C-x 4 A= ‘(diff-add-change-log-entries-other-window)’ :: Generate a
     ChangeLog entry, like ‘C-x 4 a’ does (*note [[info:emacs#Change%20Log]]), for
     each one of the hunks.

*** eDiff Mode
See [[info:ediff][Ediff]]

Ediff is a comprehensive visual interface to Unix diff and patch utilities.

*** sMerge
~smerge-mode~ is a minor mode to simplify editing output from the ~diff3~
program.  This is typically the result of a failed merge from a version control
system update outside VC, due to conflicting changes to a file.  Smerge mode
provides commands to resolve conflicts by selecting specific changes.

*** eMerge
See info:emacs#Emerge

{{{noindent}}}See [[info:emacs#Merge%20Commands]]

It’s not unusual for programmers to get their signals crossed and modify the
same program in two different directions.  To recover from this confusion, you
need to merge the two versions.

- =M-x emerge-files= :: Merge two specified files.

- =M-x emerge-files-with-ancestor= :: Merge two specified files, with reference
     to a common ancestor.

- =M-x emerge-buffers= :: Merge two buffers.

- =M-x emeerge-buffers-with-ancestor= :: Merge two buffers with reference to a
     common ancestor in a third buffer.


The Emerge commands compare two files or buffers, and display the comparison in
three buffers: one for each input text (the “A buffer” and the “B buffer”), and
one (the “merge buffer”) where merging takes place.  The merge buffer shows the
full merged text, not just the differences.  Wherever the two input texts
differ, you can choose which one of them to include in the merge buffer.

If a common ancestor version is available, from which the two texts to be
merged were both derived, Emerge can use it to guess which alternative is
right.  Wherever one current version agrees with the ancestor, Emerge presumes
that the other current version is a deliberate change which should be kept in
the merged version.  Use the ‘with-ancestor’ commands if you want to specify a
common ancestor text.  These commands read three file or buffer names—variant
A, variant B, and the common ancestor.

**** Interactive Merging
#+cindex:emerge mode
You control the merging by typing special “merge commands” in the merge buffer.
For each run of differences between the input texts, you can choose which one
of them to keep, or edit them both together.  The merge buffer uses a special
major mode, Emerge mode, with commands for making these choices.  But you can
also edit the buffer with ordinary Emacs commands.

Normally, the merge buffer starts out with the A version of the text.  But when
the A version of a difference agrees with the common ancestor, then the B
version is initially preferred for that difference.

{{{heading(Selected Difference)}}}

At any given time, the attention of Emerge is focused on one particular
difference, called the “selected” difference.  This difference is marked off in
the three buffers like this:

#+BEGIN_EXAMPLE

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

#+END_EXAMPLE

Emerge numbers all the differences sequentially and the mode line always shows
the number of the selected difference.

{{{heading(Exiting Emerge)}}}

Emerge leaves the merged text in the merge buffer when you exit.

- =C-x C-w= :: save the merge buffer in a file.  If you give a
numeric argument to ‘emerge-files’ or ‘emerge-files-with-ancestor’, it reads
the name of the output file using the minibuffer.  Then exiting from Emerge
saves the merged text in the output file.

- =C-]= :: abort Emerge without saving.

**** Submodes in Emerge

There are two modes for giving merge commands: Fast Mode and Edit Mode.  The
mode line indicates Edit and Fast modes with ‘E’ and ‘F’.

There are two additional submodes that affect how particular merge commands
work: Auto Advance Mode, and Skip Prefers Mode.

{{{heading(Fast Mode)}}}

- =C-c C-c f= :: switch to Fast mode (from Edit mode)

In Fast mode, basic merge commands are single characters, but ordinary Emacs
commands are disabled.

{{{heading(Edit Mode)}}}

- =e= :: swith to Edit mode (from Fast mode)

In Edit mode, all merge commands start with the prefix key ‘C-c C-c’, and the
normal Emacs commands are also available.  This allows editing the merge
buffer, but slows down Emerge operations.

{{{heading(Auto Advance Mode)}}}

If Auto Advance mode is in effect, the ‘a’ and ‘b’ commands advance to the next
difference.  This lets you go through the merge faster as long as you simply
choose one of the alternatives from the input.  The mode line indicates Auto
Advance mode with ‘A’.

{{{heading(Skip Prefers Mode)}}}

If Skip Prefers mode is in effect, the ‘n’ and ‘p’ commands skip over
differences in states “prefer-A” and “prefer-B” (*note State of Difference::).
Thus you see only differences for which neither version is presumed correct.
The mode line indicates Skip Prefers mode with ‘S’.  This mode is only relevant
when there is an ancestor.

Use the command ‘s a’ (‘emerge-auto-advance’) to set or clear Auto Advance
mode.  Use ‘s s’ (‘emerge-skip-prefers’) to set or clear Skip Prefers mode.
These commands turn on the mode with a positive argument, turn it off with a
negative or zero argument, and toggle the mode with no argument.

**** State of a Difference
In the merge buffer, a difference is marked with lines of ‘v’ and ‘^’
characters.  Each difference has one of these seven states:

- =A= :: The difference is showing the A version.  The ‘a’ command always
         produces this state; the mode line indicates it with ‘A’.

- =B= :: The difference is showing the B version.  The ‘b’ command always
         produces this state; the mode line indicates it with ‘B’.

- =default-A= or =default-B= :: The difference is showing the A or the B state
     by default, because you haven’t made a choice.  All differences start in
     the default-A state (and thus the merge buffer is a copy of the A buffer),
     except those for which one alternative is preferred (see below).

     When you select a difference, its state changes from default-A or
     default-B to plain A or B.  Thus, the selected difference never has state
     default-A or default-B, and these states are never displayed in the mode
     line.

     The command ‘d a’ chooses default-A as the default state, and ‘d b’
     chooses default-B.  This chosen default applies to all differences that
     you have never selected and for which no alternative is preferred.  If you
     are moving through the merge sequentially, the differences you haven’t
     selected are those following the selected one.  Thus, while moving
     sequentially, you can effectively make the A version the default for some
     sections of the merge buffer and the B version the default for others by
     using ‘d a’ and ‘d b’ between sections.

- =prefer-A= or =prefer-B= :: The difference is showing the A or B state
     because it is “preferred”.  This means that you haven’t made an explicit
     choice, but one alternative seems likely to be right because the other
     alternative agrees with the common ancestor.  Thus, where the A buffer
     agrees with the common ancestor, the B version is preferred, because
     chances are it is the one that was actually changed.

     These two states are displayed in the mode line as ‘A*’ and ‘B*’.

- =combined= :: The difference is showing a combination of the A and B states,
                as a result of the ‘x c’ or ‘x C’ commands. The mode line
                displays this state as ‘comb’.

                Once a difference is in this state, the ‘a’ and ‘b’ commands
                don’t do anything to it unless you give them a numeric
                argument.

** Entering Special Symbols
   #+cindex:Section § symbol
   #+cindex:symbol §
- Section § symbol :: =C-x 8 S=

* Practicals
** Exploring Emacs

** Log Files

** TRAMP

** Dired
#+cindex:dired
You can manipulate directories and files using Emacs’s directory editor, dired.

Ways to access dired:

- From IDO Mode :: =C-x C-f C-d= when finding files to open a dired buffer in
                   that file's current directory.

- As a command :: =M-x dired=

- As a key bind :: =C-x d= =C-x 4 d=


#+cindex:@command{dired-listing-switches}
Dired Buffer is usually based upon ~ls -al~.  This can be configured using
~dired-listing-switches~.

*** Dired Navigation

*** Dired Marking and Unmarking

*** Dired Operations

*** Working Across Directories

**** Include Additional Directories

#+cindex:directories, include subdirectories
#+cindex:subdirectories, include
#+cindex:include subdirectories
- ~dired-maybe-insert-subdir~ ::

  - =i= :: insert this subdirectory into the same dired buffer (like ~ls -lR~)

  #+cindex:switches, @command{ls}
  #+cindex:@command{ls} switches
  - =C-u i= :: edit the ~ls~ switches; add =R= to the switches to expand
                    the whole tree starting at this subdirectory

  - [[info:emacs#Subdir%20switches][Subdir Switches]] :: for more details

- ~dired-hide-subdir~ :: =$= --- hide or unhide the current subdirectory and
     move to next directory

     - =M-$= :: (un)hide all directories

- ~dired-reset-subdir-switches~ :: reset all subdirectory switches to the
     default


**** Find Wrapper Commands
#+cindex:@command{find} wrapper commands
To recursively apply a dired or shell command, use Emac's ~find~ wrapper
commands.

All commands take the output of find and build a dired buffer relative to a
starting directory. Emacs is clever enough to notice the relative paths in what
was the filename portion of the buffer. All commands in dired work as usual.

| Commands               | Description                                                |
|------------------------+------------------------------------------------------------|
| ~find-dired~           | Calls ~find~ with a pattern                                |
| ~find-name-dired~      | Calls ~find~ with =-name= using glob patterns              |
| ~find-grep-dired~      | Calls ~find~ and ~grep~                                    |
| ~find-lisp-find-dired~ | Uses Emacs and regexp to find files (elisp implementation) |
|                        | does not use shell globbing                                |
|------------------------+------------------------------------------------------------|

** Shell Commands
The following shell commands work on generic buffers.

#+caption:Shell command key bindings
#+name:shell-command-bindings
|------------+---------------------------------------|
| Keys       | Description                           |
|------------+---------------------------------------|
| M-!        | Calls shell command and prints output |
| C-u M-!    | As above, but inserts into buffer     |
| M-&        | Like M-! but asynchronous             |
| C-u M-&    | Like C-u M-! but asynchronous         |
| M-pipe     | Pipes region to shell command         |
| C-u M-pipe | Likes M-pipe, but replaces region     |
|------------+---------------------------------------|

- [ =C-u= ] =M-!= and =M-&= :: Invoke any shell command; output is
     printed to the mini-buffer if it is only a small amount, or to a
     dedicated buffer otherwise.  Add a prefix argument to insert the
     output into the buffer.

- [ =C-u= ] =M-|= :: Takes the region as input and sends it to the
     standard input of a shell command, and returns the output to
     either the mini-buffer or a dedicated buffer.  Add a prefix
     argument to replace the region with the shell output.

*** Compiling in Emacs
=M-x compile= asynchronously runs a compilation command (by default
~make -k~).  You can run any command or script, however, and track the
output.  Error messages go to the "*compilation*" buffer.

#+caption:Compilation command key bindings
#+name:compilation-command-bindings
|-----------------------------+------------------------------------------------------|
| Commands                    | Description                                          |
|-----------------------------+------------------------------------------------------|
| =M-x compile=               | Runs a command, and tracks errors                    |
| =M-x recompile=             | Re-runs last command                                 |
| =M-g M-n=, =M-g M-p=        | Jumps to next or previous error                      |
| =C-x `=                     | Visit errors sequentially                            |
| =g= (Compilation mode)      | Re-runs last command                                 |
| =M-x kill-compilation=      | Kill the running compilation subprocess              |
| =compile-command=           | Variable holding prior command                       |
| =compilation-scroll-output= | Variable controlling scrolling of compilation buffer |
| =compilation-environment=   | Variable to control the environment passed           |
|-----------------------------+------------------------------------------------------|

*** Compilation Mode
The "*compilation*" buffer uses a major mode called Compilation mode.
This mode turns each error message in the buffer into a hyperlink; you
can move point to it and type <RET> to visit "locus" of the error
message in a separate window.

- =compilation-auto-jump-to-first-error= :: Variable allowing Emacs to
     automatically jump to the first error message that appears in the
     compilation buffer (when set to non-=nil=).

** Shells

*** Shell Mode

*** Terminal Emulator

*** eshell---Emac's Shell

* Packages

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging


#+cindex:package
Emacs provides a standard way to distribute Emacs Lisp code to users.
A package is a collection of one or more files, formatted and bundled
in such a way that users can easily download, install, uninstall, and
upgrade it.

** Installing and Using Packages
- https://www.emacswiki.org/emacs/InstallingPackages

The most common method of installing packages of Emacs Lisp since
Emacs 24 has been *ELPA* packages.  Additional package archives such
as *MELPA* exist to supplement what is in GnuELPA.

#+cindex:UsePackage
#+cindex:use-package
[[https://github.com/jwiegley/use-package][UsePackage]] can make it easier for you to organize your package-related
configuration.

** Emacs Lisp Package Manager and Archives
#+cindex:ELPA
#+cindex:@code{package.el}
#+cindex:Tromey, Tom

- http://tromey.com/elpa/index.html


ELPA is the Emacs Lisp Package Archive, written originally by [[https://www.emacswiki.org/emacs/TomTromey][Tom Tromey]].  It
is included in GnuEmacs, starting with version 24 as ~package.el~.
~package.el~ supports multiple ELPA repositories.

*** GnuElpa

#+cindex:ELPA
#+cindex:GnuElpa
“GNU Emacs Lisp Package Archive---The default package repository for
GNU Emacs.”

- http://elpa.gnu.org

- [[http://elpa.gnu.org/packages/][Browse the Repositories]]

- [[http://git.savannah.gnu.org/cgit/emacs/elpa.git][The Gnu ELPA Repository]]

- [[https://savannah.gnu.org/projects/emacs][Gnu ELPA Project Page]]


This should already be in Emacs (for Emacs 24+):

- ~package-archives~ ::

    : (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")))


You can also add repositories one at a time:

: (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
: (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t) ; Org-mode's repository

To use it, type =M-x list-packages= in Emacs.

Since you'll probably want to use your installed packages, it's also
recommended that you add ~(package-initialize)~ somewhere in your
~$HOME/.emacs~ file.

*** Milkypostman’s Emacs Lisp Package Archive---MELPA

- https://melpa.org/

- https://www.emacswiki.org/emacs/MELPA


#+cindex:MELPA
MELPA is an ELPA-compatible package repository that contains an enormous amount
of useful Emacs packages.

#+texinfo:@heading Features

- Up-to-date packages built on our servers from upstream source

- Installable in any Emacs with 'package.el' - no local version-control tools
  needed

- Curated - no obsolete, renamed, forked or randomly hacked packages

- Comprehensive - more packages than any other archive

- Automatic updates - new commits result in new packages

- Extensible - contribute recipes via github, and we'll build the packages

**** Getting Started with MELPA

***** Installing MELPA

You need ~package.el~.  Emacs 24 on has ~package.el~ bundled.

#+cindex:@code{package-archives}
#+vindex:package-archives
#+cindex:@code{package-initialize}
Enable installation of packages from MELPA by adding an entry to
~package-archives~ after ~(require 'package)~ and before the call to
~package-initialize~ in your ~init.el~ or ~.emacs~ file:

: (add-to-list 'package-archives (cons "melpa" "https://melpa.org/packages/") t)
: (add-to-list 'package-archives (cons "melpa-stable" "https://stable.melpa.org/packages/") t)

*** How Packages Work

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html#Packaging-Basics


Whenever Emacs starts up, it automatically calls the function
‘package-initialize’ to load installed packages.  This is done after
loading the init file and before running ‘after-init-hook’.  Automatic
package loading is disabled if the user option
~package-enable-at-startup~ is nil.

This means you should NOT put package specific initialization into
your ~init.el~ except in a few ways:

- customization variables for a package can be set before a package
  has loaded;

- ~auto-mode-alist~ changes can be made in a way that does not require
  the package to be loaded before they are setup:
  : (add-to-list 'auto-mode-alist '("\\.gradle" . groovy-mode))

- mode specific customization of a package could go in a package hook
  which can be set before the package is loaded, for example:
  : (add-hook 'groovy-mode-hook (lambda () (setq tab-width 4)))

- key bindings can also be done in such a way to not cause init
  failure, even if the package is not loaded:
  : (global-set-key (kbd "C-'")     'shell-switcher-switch-buffer)

- some package specific initialization can be done with
  ~eval-after-load~


It might be easier just to move ~package-initialize~ to another point
during startup so you can ~(require)~ ELPA packages; this takes care
of a lot of the described issues:

#+begin_src emacs-lisp :eval no
  ;; basic initialization, (require) non-ELPA packages, etc.
  (setq package-enable-at-startup nil)
  (package-initialize)
  ;; (require) your ELPA packages, configure them as normal
#+end_src

#+texinfo:@heading Using with-eval-after-load For Package Config

Starting in emacs 24.4, ~with-eval-after-load~ is simpler than
~eval-after-load~:

#+begin_src emacs-lisp :eval no
  (with-eval-after-load 'abcd-mode
         (setq-default abcd-basic-offset 7) ; setting some option
         (add-to-list 'abcd-globals-list "console") ; appending to a list option
         (add-hook 'abcd-mode-hook 'prepare-some-abcd-soup) ; things to do for abcd mode buffers
         (define-key abcd-mode-map (kbd "C-c C-c") 'play-some-abcd-song) ; add some key binding for abcd mode
         )
#+end_src

** UsePackage

- https://jwiegley.github.io/use-package/

- https://github.com/jwiegley/use-package


“The ~use-package~ macro allows you to isolate package configuration
in your ~.emacs~ file in a way that is both performance-oriented and,
well, tidy.  I created it because I have over 80 packages that I use
in Emacs, and things were getting difficult to manage.  Yet with this
utility my total load time is around 2 seconds, with no loss of
functionality!”

~use-package~ is /not/ a package manager!  Although ~use-package~ does
have the useful capability to interface with package managers (see
below), /its primary purpose is for the configuration and loading of
packages/.

~use-package~ is available from Melpa and Melpa-Stable.

To install:
: M-x package-install RET use-package RET

* Special Packages
** Polymode
Multiple Major Modes and How to Use SQL and Python in one Buffer

- [[https://www.masteringemacs.org/article/polymode-multiple-major-modes-how-to-use-sql-python-in-one-buffer][About Polymode]]

** Magit
‘A Git Porcelain inside Emacs’

See [[https://www.masteringemacs.org/article/introduction-magit-emacs-mode-git][“An introduction to Magit, an Emacs mode for Git”]]

Magit is an interface to the version control system Git, implemented as an
Emacs package. Magit aspires to be a complete Git porcelain; it is complete
enough to allow even experienced Git users to perform almost all of their daily
version control tasks directly from within Emacs.

- [[https://magit.vc][Magit Home]]
- [[https://magit.vc/manual/magit/index.html#SEC_Contents][Magit User Manual]]


{{{heading(Staging and Unstaging)}}}

Staging and otherwise applying changes is one of the most important features in
a Git porcelain and here Magit outshines anything else, including Git itself.
Git’s own staging interface (git add --patch) is so cumbersome that many users
only use it in exceptional cases.  In Magit staging a hunk or even just part of
a hunk is as trivial as staging all changes made to a file.

{{{subheading(Status Buffer)}}}

The most visible part of Magit’s interface is the status buffer, which displays
information about the current repository. Its content is created by running
several Git commands and making their output actionable.  Among other things,
it displays information about the current branch, lists unpulled and unpushed
changes and contains sections displaying the staged and unstaged changes.  That
might sound noisy, but, since sections are collapsible, it’s not.

{{{subheading(Stage and Unstage)}}}

To stage or unstage a change one places the cursor on the change and then types
=s= or =u=.  The change can be a file or a hunk, or when the region is active
(i.e. when there is a selection) several files or hunks, or even just part of a
hunk.  The change or changes that these commands --- and many others --- would
act on are highlighted.

{{{subheading(Apply Variants)}}}

Magit also implements several other “apply variants” in addition to staging and
unstaging.  One can discard or reverse a change, or apply it to the working
tree.  Git’s own porcelain only supports this for staging and unstaging and you
would have to do something like =git diff ... | ??? | git apply ...= to
discard, revert, or apply a single hunk on the command line.  In fact that’s
exactly what Magit does internally (which is what lead to the term “apply
variants”).

{{{heading(Advanced Features)}}}

Magit fully embraces Git. It exposes many advanced features using a simple but
flexible interface instead of only wrapping the trivial ones like many GUI
clients do. Of course Magit supports logging, cloning, pushing, and other
commands that usually don’t fail in spectacular ways; but it also supports
tasks that often cannot be completed in a single step. Magit fully supports
tasks such as:

- merging
- rebasing
- cherry-picking
- reverting
- blaming


{{{noindent}}}by not only providing a command to initiate these tasks but also
by displaying context sensitive information along the way and providing
commands that are useful for resolving conflicts and resuming the sequence
after doing so.

Magit wraps and in many cases improves upon at least the following Git
porcelain commands:

- add
- am
- bisect
- blame
- branch
- checkout
- cherry
- cherry-pick
- clean
- clone
- commit
- config
- describe
- diff
- fetch
- format-patch
- init
- log
- merge
- merge-tree
- mv
- notes
- pull
- rebase
- reflog
- remote
- request-pull
- reset
- revert
- rm
- show
- stash
- submodule
- tag


Many more Magit porcelain commands are implemented on top of Git plumbing
commands.
*** Status Buffer

{{{heading(Status)}}}

#+cindex:status
#+cindex:magit-status
To display information about the current Git repository, type =M-x magit-status
RET=.  You will be using this command a lot, and should therefore give it a
global key binding.  This is what we recommend:

: (global-set-key (kbd "C-x g") 'magit-status)

{{{subheading(Status Buffer)}}}

#+cindex:status buffer
Most Magit commands are commonly invoked from the status buffer.  It can be
considered the primary interface for interacting with Git using Magit.  Many
other Magit buffers may exist at a given time, but they are often created from
this buffer.

{{{subheading(Safe State)}}}

Return to a safe state:

: git reset --hard PRE-MAGIT-STATE

{{{subheading(Refresh Status Buffer)}}}

#+cindex:refresh status buffer
#+cindex:status buffer, refresh
Go to the status buffer, while at the same time refreshing it, by typing =C-x
g=.  (When the status buffer, or any Magit buffer for that matter, is the
current buffer, then you can also use just =g= to refresh it).

{{{subheading(Move Between Sections)}}}

Move between sections using =p= and =n=.  Note that the bodies of some sections
are hidden.  Type =TAB= to expand or collapse the section at point.  You can
also use =C-tab= to cycle the visibility of the current section and its
children.

{{{subheading(Stage Changes)}}}

#+cindex:stage changes
Move to a file section inside the section named “Unstaged changes”
and type =s= to stage the changes you have made to that file.  That file now
appears under “Staged changes”.

{{{subheading(Stage and Unstage Hunks)}}}

Magit can stage and unstage individual hunks, not just complete files.  Move to
the file you have just staged, expand it using =TAB=, move to one of the hunks
using =n=, and unstage just that by typing =u=.  Note how the staging (=s=) and
unstaging (=u=) commands operate on the change at point. Many other commands
behave the same way.

* Additional Resources
:PROPERTIES:
:appendix: t
:END:
** WikEmacs

#+cindex:WikEmacs
- http://wikemacs.org/wiki/Main_Page

** Mastering Emacs in One Year
- https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-en.org
- http://blog.binchen.org
** How to Learn Emacs---A Hand-drawn One-pager for Beginners
- https://sachachua.com/blog/2013/05/how-to-learn-emacs-a-hand-drawn-one-pager-for-beginners/
- https://sachachua.com/blog/
** Emacs Rocks
- http://emacsrocks.com
** Planet Emacsen
- https://github.com/hober/planet.emacsen.org
- web site is currently /down/
- https://planet.emacslife.com (unofficial version)
** Awesome Emacs
- https://github.com/emacs-tw/awesome-emacs
** Using Emacs Series
- https://cestlaz.github.io/stories/emacs/
** Xah Emacs and Tutorial
- http://ergoemacs.org/index.html
- http://ergoemacs.org/emacs/emacs.html
** Emacs Mini Tutorial
- [[http://tuhdo.github.io/emacs-tutor.html][Emacs Mini Manual (PART 1) - THE BASICS]]
** r/emacs
- https://www.reddit.com/r/emacs
** Emacs StackExchange
- https://emacs.stackexchange.com
** Effective emacs
- https://a-nickels-worth.blogspot.com/2007/11/effective-emacs.html

* Sequences in Elisp
:PROPERTIES:
:appendix: t
:END:

#+cindex:sequence type
The /sequence/ type is the union of two other Lisp types: lists and arrays.  In
other words, any list is a sequence, and any array is a sequence.  The common
property that all sequences have is that each is an ordered collection of
elements.

#+texinfo: @heading The List

#+cindex:list
A list is a sequence of elements, but it is not a single primitive object; it
is made of /cons cells/, one cell per element.  Finding the Nth element
requires looking through N cons cells, so elements farther from the beginning
of the list take longer to access.  But it is possible to add elements to the
list, or remove elements.

#+texinfo:@heading The Array

#+cindex:array
An /array/ is a fixed-length object with a slot for each of its elements.  All
the elements are accessible in constant time.  The four types of arrays are:
- strings
- vectors
- char-tables
- bool-vectors

** Sequence Functions

This section describes functions that accept any kind of sequence.

** Lists in Elisp
:PROPERTIES:
:appendix: t
:END:

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lists.html#Lists][Lists in the Elisp Manual]]


#+cindex:list
A /list/ represents a sequence of zero or more elements (which may be any Lisp
objects).

Two important differences between lists and vectors is that:
- two or more lists can share part of their structure;
- you can insert or delete elements in a list without copying the whole list.


#+cindex:list
A /list/ represents a sequence of zero or more elements (which may be any Lisp
objects).

*** Cons Cells

A /cons cell/ is a primitive data object that represents an ordered pair.  That
is, it has two slots, and each slot “holds”, or “refers to”, some Lisp object.
One slot is known as the CAR, and the other is known as the CDR.
*** Lists and Cons Cells

#+cindex:cons cell
#+cindex:CAR, CDR
Lists are built up from /cons cells/.  A “list” is a series of cons cells,
linked together so that the CDR slot of each cons cell holds either the next
cons cell or the empty list.  The empty list is actually the symbol ‘nil’.
There is one cons cell for each element of the list.

By convention, the CARs of the cons cells hold the elements of the list, and
the CDRs are used to chain the list (this asymmetry between CAR and CDR is
entirely a matter of convention; at the level of cons cells, the CAR and CDR
slots have similar properties).  Hence, the CDR slot of each cons cell in a
list refers to the following cons cell.

#+texinfo:@heading Proper Lists---CDR is a List

#+cindex:proper list
#+cindex:nil
Also by convention, the CDR of the last cons cell in a list is ‘nil’.  We call
such a ‘nil’-terminated structure a “proper list”.  In Emacs Lisp, the symbol
‘nil’ is both a symbol and a list with no elements.  For convenience, the
symbol ‘nil’ is considered to have ‘nil’ as its CDR (and also as its CAR).

Hence, the CDR of a proper list is always a proper list.  The CDR of a nonempty
proper list is a proper list containing all the elements except the first.

#+texinfo:@heading Dotted Lists

#+cindex:dotted list
If the CDR of a list’s last cons cell is some value other than ‘nil’, we call
the structure a “dotted list”, since its printed representation would use
dotted pair notation

#+texinfo:@heading List Structure

#+cindex:list structure
Because most cons cells are used as part of lists, we refer to any structure
made out of cons cells as a “list structure”.

#+texinfo:@heading Read Syntax and Printed Representation

#+cindex:read syntax, list
#+cindex:printed representation, list
The read syntax and printed representation for lists are identical, and consist
of a left parenthesis, an arbitrary number of elements, and a right
parenthesis.

: (a b c)
: () or nil
: ((a b c) (d e f))

Upon reading, each object inside the parentheses becomes an element of the
list.  That is, a cons cell is made for each element.  The CAR slot of the cons
cell holds the element, and its CDR slot refers to the next cons cell of the
list, which holds the next element in the list.  The CDR slot of the last cons
cell is set to hold ‘nil’.

#+texinfo:@heading Dotted Pair Notation

#+cindex:dotted pair notation
/Dotted pair notation/ is a general syntax for cons cells that represents the
CAR and CDR explicitly.

In this syntax, =(A . B)= stands for a cons cell whose CAR is the object A and
whose CDR is the object B.  In dotted pair notation, the list =(1 2 3)= is
written as (=1 . (2 . (3 . nil)))=.

Dotted pair notation is more general than list syntax because the CDR does not
have to be a list.  However, it is more cumbersome in cases where list syntax
would work.  For ‘nil’-terminated lists, you can use either notation, but list
notation is usually clearer and more convenient.  When printing a list, the
dotted pair notation is only used if the CDR of a cons cell is not a list.

You can combine dotted pair notation with list notation to represent
conveniently a chain of cons cells with a non-‘nil’ final CDR.  You write a dot
after the last element of the list, followed by the CDR of the final cons cell.
For example, =(rose violet . buttercup)= is equivalent to =(rose . (violet
. buttercup))=.  The list =(rose violet)= is equivalent to =(rose . (violet))=.
Similarly, the three-element list =(rose violet buttercup)= is equivalent to
=(rose . (violet . (buttercup)))=.
*** Association Lists

#+cindex:association list
#+cindex:stack
An /association list/ or /alist/ is a specially-constructed list whose elements
are cons cells.  In each element, the CAR is considered a “key”, and the CDR is
considered an “associated value”.  Association lists are often used as stacks,
since it is easy to add or remove associations at the front of the list.

#+begin_src emacs-lisp :eval no
  (setq alist-of-colors
        '((rose . red) (lily . white) (buttercup . yellow)))
#+end_src

Above, ~alist-of-colors~ is an alist of three elements.  In each element, the
first object is the key, and the second is the value.
*** List Predicates
*** List Elements
*** List Variables
*** Modifying Lists
*** Sets
*** Association Lists
*** Property Lists

** Arrays in Elisp

An /array/ object has slots that hold a number of other Lisp objects, called
the elements of the array.  Any element of an array may be accessed in constant
time.  When you create an array, other than a char-table, you must specify its
length.  You cannot specify the length of a char-table, because that is
determined by the range of character codes.

#+cindex:array types
Emacs defines four types of array, all one-dimensional:

- “strings” (*note String Type::)
- “vectors” (*note Vector Type::)
- “bool-vectors” (*note Bool-Vector Type::)
- “char-tables” (*note Char-Table Type::)


#+cindex:vector
#+cindex:char-table
#+cindex:bool-vector
Vectors and char-tables can hold elements of any type, but strings can only
hold characters, and bool-vectors can only hold ‘t’ and ‘nil’.

#+texinfo:@heading Shared Characteristics

#+cindex:characteristics, array
All four kinds of array share these characteristics:

   - The first element of an array has index zero, the second element has index
     1, and so on.  This is called “zero-origin” indexing.  For example, an
     array of four elements has indices 0, 1, 2, and 3.

   - The length of the array is fixed once you create it; you cannot change the
     length of an existing array.

   - For purposes of evaluation, the array is a constant---i.e., it evaluates
     to itself.

   - The elements of an array may be referenced or changed with the functions
     ‘aref’ and ‘aset’, respectively (*note Array Functions::).


#+texinfo:@heading Text Characters

In principle, if you want an array of text characters, you could use either a
string or a vector.  In practice, we always choose strings for such
applications, for four reasons:

   - They occupy one-fourth the space of a vector of the same elements.

   - Strings are printed in a way that shows the contents more clearly as text.

   - Strings can hold text properties.  *Note Text Properties::.

   - Many of the specialized editing and I/O facilities of Emacs accept only
     strings.  For example, you cannot insert a vector of characters into a
     buffer the way you can insert a string.  *Note Strings and Characters::.


By contrast, for an array of keyboard input characters (such as a key
sequence), a vector may be necessary, because many keyboard input characters
are outside the range that will fit in a string.

*** Functions that Operate on Arrays

* Interacting with the System
:PROPERTIES:
:appendix: t
:END:
** Processes
:PROPERTIES:
:appendix: t
:END:

#+texinfo:@heading Subprocesses

#+cindex:process
#+cindex:subprocess
#+cindex:child process
#+cindex:parent process
#+cindex:synchronous process
#+cindex:asynchronous process
Emacs Lisp programs can invoke other programs in processes of their own.  These
are called “subprocesses” or “child processes” of the Emacs process, which is
their “parent process”.  A subprocess of Emacs may be “synchronous” or
“asynchronous”, depending on how it is created.  When you create a synchronous
subprocess, the Lisp program waits for the subprocess to terminate before
continuing execution.  When you create an asynchronous subprocess, it can run
in parallel with the Lisp program.  This kind of subprocess is represented
within Emacs by a Lisp object which is also called a “process”.  Lisp programs
can use this object to communicate with the subprocess or to control it.

#+attr_texinfo: :options processp object
#+begin_defun
This function returns ‘t’ if OBJECT represents an Emacs process object, ‘nil’
     otherwise.  The process object can represent a subprocess running a
     program or a connection of any supported type.
#+end_defun

#+texinfo:@heading System Processes

#+cindex:system process
In addition to subprocesses of the current Emacs session, you can also access
other processes running on your machine.  These are /system processes/.

*** Creating Subprocesses---In General

#+cindex:new subprocess, create
There are three primitives that create a new subprocess in which to run a
program.

#+cindex:@code{call-process}
#+cindex:@code{call-process-region}
#+cindex:@code{make-process}
#+attr_texinfo: :indic code
- call-process ::

  creates a synchronous process

- call-process-region ::

  creates a synchronous process

- make-process ::

  creates an asynchronous process and returns a process object


The three functions are called in similar fashions; their common arguments are
described here first.

#+texinfo:@heading The Program to Run

In all cases, the functions *specify the program to be run*.

#+texinfo:@subheading exec-path

#+vindex:exec-path
#+vindex:PATH
#+vindex:default-directory
The filename may contain =~=, =.=, and =..=.  If the file name is relative, the
variable ‘exec-path’ contains a list of directories to search.  Emacs
initializes ‘exec-path’ when it starts up, based on the value of the
environment variable ‘PATH’.  ~nil~ in the list refers to ~default-directory~.
The variable ~exec-directory~ can also supply a directory to search.

Your ~exec-path~ has the contents:

#+name:your-exec-path
#+header: :results value :exports results
#+begin_src emacs-lisp
exec-path
#+end_src

#+attr_texinfo: :options exec-directory
#+begin_defun
The value of this variable is a string, the name of a directory that contains
     programs that come with GNU Emacs and are intended for Emacs to invoke.
     The program ‘movemail’ is an example of such a program; Rmail uses it to
     fetch new mail from an inbox.
#+end_defun

Your ~exec-directory~ has the value:

#+name:your-exec-directory
#+header: :results value :exports results
#+begin_src emacs-lisp
exec-directory
#+end_src

Use the function ‘substitute-in-file-name’ to perform environment variable
substitutions (`$HOME').

#+attr_texinfo: :options substitute-in-file-name filename
#+begin_defun
Substitute environment variables referred to in FILENAME.
‘$FOO’ where FOO is an environment variable name means to substitute
the value of that variable.

    (substitute-in-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"
#+end_defun

#+texinfo:@heading Filename Arguments

#+cindex:filename arguments
Each of the subprocess-creating functions has a BUFFER-OR-NAME argument that
specifies where the output from the program will go.  It should be a buffer or
a buffer name; if it is a buffer name, that will create the buffer if it does
not already exist.  It can also be ‘nil’, which says to discard the output,
unless a custom filter function handles it.

For synchronous processes, you can send the output to a file instead of a
buffer.

#+texinfo:@heading Standard Streams

#+cindex:standard streams
#+cindex:standard output, error, input
#+cindex:streams, standard
#+cindex:redirection, standard streams
By default, both standard output and standard error streams go to the same
destination, but all the 3 primitives allow optionally to direct the standard
error stream to a different destination.

#+texinfo:@heading Process Command-Line Arguments

All three of the subprocess-creating functions allow to specify command-line
arguments for the process to run.  The command-line arguments must all be
strings, and they are supplied to the program as separate argument strings.

- For ‘call-process’ and ‘call-process-region’, these come in the form of a
  ‘&rest’ argument, ARGS.

- For ‘make-process’, both the program to run and its command-line arguments
  are specified as a list of strings.


#+texinfo:@heading Inheriting Environment

#+cindex:subprocess environment
The subprocess inherits its environment from Emacs, but you can specify
overrides for it with ‘process-environment’.


#+vindex:default-directory
The subprocess gets its current directory from the value of
‘default-directory’.

**** Specifying Shell Arguments

#+attr_texinfo: :options shell-quote-argument argument
#+begin_defun
This function returns a string that represents, in shell syntax, an argument
     whose actual contents are ARGUMENT.  It should work reliably to
     concatenate the return value into a shell command and then pass it to a
     shell for execution.  The function is designed to work with the syntax of
     your system’s standard shell.

     Here’s an example of using ‘shell-quote-argument’ to construct a
     shell command:

          (concat "diff -u "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))
#+end_defun

#+texinfo:@heading Command-Line Argument Processing

The following two functions are useful for combining a list of individual
command-line argument strings into a single string, and taking a string apart
into a list of individual command-line arguments.

#+attr_texinfo: :options combine-and-quote-strings list-of-strings &optional separator
#+begin_defun
     This function concatenates LIST-OF-STRINGS into a single string, quoting
     each string as necessary.  It also sticks the SEPARATOR string between
     each pair of strings; if SEPARATOR is omitted or ‘nil’, it defaults to ‘"
     "’.  The return value is the resulting string.

     The strings in LIST-OF-STRINGS that need quoting are those that include
     SEPARATOR as their substring.  Quoting a string encloses it in double
     quotes ‘"..."’.  In the simplest case, if you are consing a command from
     the individual command-line arguments, every argument that includes
     embedded blanks will be quoted.
#+end_defun

#+attr_texinfo: :options split-string-and-unquote string &optional separators
#+begin_defun
     This function splits STRING into substrings at matches for the regular
     expression SEPARATORS, like ‘split-string’ does.  In addition, it removes
     quoting from the substrings.  It then makes a list of the substrings and
     returns it.
#+end_defun

*** Creating Synchronous Subprocesses

After a “synchronous process” is created, Emacs waits for the process to
terminate before continuing.  While Emacs waits for the synchronous subprocess
to terminate, the user can quit by typing ‘C-g’.  The first ‘C-g’ tries to kill
the subprocess with a ‘SIGINT’ signal; but it waits until the subprocess
actually terminates before quitting.  If during that time the user types
another ‘C-g’, that kills the subprocess instantly with ‘SIGKILL’ and quits
immediately.  The synchronous subprocess functions return an indication of how
the process terminated.

**** call-process---a primitive

#+attr_texinfo: :options call-process program &optional infile destination display &rest args
#+begin_defun
     This function calls PROGRAM and waits for it to finish.

     The current working directory of the subprocess is set to the current
     buffer’s value of ‘default-directory’ if that is local (as determined by
     ‘unhandled-file-name-directory’), or "~" otherwise.  If you want to run a
     process in a remote directory use ‘process-file’.

     #+attr_texinfo: :indic @var
     - infile :: The standard input for the new process comes from file INFILE
       if INFILE is not ‘nil’, and from the null device otherwise.
     - destination :: The argument DESTINATION says where to put the process
       output.  Here are the possibilities:
       #+attr_texinfo: :indic b
       - a buffer ::

       - a buffer name (a string) ::

       - t :: Insert the output in the current buffer, before point.

       - nill :: Discard the output

       - 0 :: Discard the output, and return ‘nil’ immediately without waiting
         for the subprocess to finish.

       - (:file FILE-NAME) :: Send the output to the file name specified,
         overwriting it if it already exists.

       - (REAL-DESTINATION ERROR-DESTINATION) :: Keep the standard output
         stream separate from the standard error stream; deal with the ordinary
         output as specified by REAL-DESTINATION, and dispose of the error
         output according to ERROR-DESTINATION.  If ERROR-DESTINATION is ‘nil’,
         that means to discard the error output, ‘t’ means mix it with the
         ordinary output, and a string specifies a file name to redirect error
         output into.

         You can’t directly specify a buffer to put the error output in; that
         is too difficult to implement.  But you can achieve this result by
         sending the error output to a temporary file and then inserting the
         file into a buffer when the subprocess finishes.

     - display :: If DISPLAY is non-‘nil’, then ‘call-process’ redisplays the
       buffer as output is inserted.  Otherwise the function ‘call-process’
       does no redisplay, and the results become visible on the screen only
       when Emacs redisplays that buffer in the normal course of events.

     - args :: The remaining arguments, ARGS, are strings that specify command
       line arguments for the program.  Each string is passed to PROGRAM as a
       separate argument.

     - Return Value :: The value returned by ‘call-process’ (unless you told it
       not to wait) indicates the reason for process termination.  A number
       gives the exit status of the subprocess; 0 means success, and any other
       value means failure.  If the process terminated with a signal,
       ‘call-process’ returns a string describing the signal.  If you told
       ‘call-process’ not to wait, it returns ‘nil’.

#+end_defun
**** call-process-region---a primitive

#+attr_texinfo: :options call-process-region start end program &optional delete destination display &rest args
#+begin_defun
     This function sends the text from START to END as standard input to a
     process running PROGRAM.  It deletes the text sent if DELETE is non-‘nil’;
     this is useful when DESTINATION is ‘t’, to insert the output in the
     current buffer in place of the input.

     #+attr_texinfo: :indic var
     - destination, display :: 

       The arguments DESTINATION and DISPLAY control what to do with the output
       from the subprocess, and whether to update the display as it comes in.
       For details, see the description of ‘call-process’, above.  If
       DESTINATION is the integer 0, ‘call-process-region’ discards the output
       and returns ‘nil’ immediately, without waiting for the subprocess to
       finish.

     - args :: 

       The remaining arguments, ARGS, are strings that specify command line
       arguments for the program.

     - Return Value ::

       The return value of ‘call-process-region’ is just like that of
       ‘call-process’: ‘nil’ if you told it to return without waiting;
       otherwise, a number or string which indicates how the subprocess
       terminated.
#+end_defun

#+texinfo:@heading Example using ~call-process-region~

In the following example, we use ~call-process-region~ to run the ~cat~
utility, with standard input being the first five characters in buffer =foo=
(the word =input=).  ~cat~ copies its standard input into its standard output.
Since the argument DESTINATION is ‘t’, this output is inserted in the current
buffer.

#+begin_example
---------- Buffer: foo ----------
input★
---------- Buffer: foo ----------

(call-process-region 1 6 "cat" nil t)
     ⇒ 0

---------- Buffer: foo ----------
inputinput★
---------- Buffer: foo ----------
#+end_example
**** call-process-shell-command

#+attr_texinfo: :options call-process-shell-command command &optional infile destination display
#+begin_defun
#+attr_texinfo: :indic var
- COMMAND :: This function executes the shell command COMMAND synchronously.


The other arguments are handeled as in [[*call-process---a primitive][~call-process~]].
#+end_defun

**** call-shell-region

#+attr_texinfo: :options call-shell-region start end command &optional delete destination
#+begin_defun
This function sends the text from START to END as standard input to an inferior
shell running COMMAND.  This function is similar than ~call-process-region~,
with process being a shell.

The arguments DELETE, DESTINATION and the return value are like in
~call-process-region~.
#+end_defun

**** shell-command-to-string

#+findex:shell-command-to-string
This function executes COMMAND (a string) as a shell command, then returns the
command’s output as a string.

**** process-lines

#+attr_texinfo: :options process-lines program &rest args
#+begin_defun
This function runs PROGRAM, waits for it to finish, and returns its output as a
list of strings.  Each string in the list holds a single line of text output by
the program; the end-of-line characters are stripped from each line.

The arguments beyond PROGRAM, ARGS, are strings that specify command-line
arguments with which to run the program.

This function works by calling [[*call-process---a primitive][~call-process~]], so program output is decoded in
the same way as for ~call-process~.
#+end_defun

**** process-file

#+attr_texinfo: :options process-file program &optional infile buffer display &rest args
#+begin_defun
      This function processes files synchronously in a separate process.  It is
     similar to ~call-process~, but may invoke a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Magic-File-Names.html#Magic-File-Names][file handler]] based on the
     value of the variable ~default-directory~, which specifies the current
     working directory of the subprocess.

     The arguments are handled in almost the same way as for ~call-process~,
     with the following differences:

     1. Some file handlers may not support all combinations and forms of the
        arguments INFILE, BUFFER, and DISPLAY.  For example, some file handlers
        might behave as if DISPLAY were ‘nil’, regardless of the value actually
        passed.  As another example, some file handlers might not support
        separating standard output and error output by way of the BUFFER
        argument.

     2. If a file handler is invoked, it determines the program to run based on
        the first argument PROGRAM.  For instance, suppose that a handler for
        remote files is invoked.  Then the path that is used for searching for
        the program might be different from ‘exec-path’.

     3. The second argument INFILE may invoke a file handler.  The file handler
        could be different from the handler chosen for the ‘process-file’
        function itself.  (For example, ‘default-directory’ could be on one
        remote host, and INFILE on a different remote host.  Or
        ‘default-directory’ could be non-special, whereas INFILE is on a remote
        host.)

     4. If BUFFER is a list of the form ‘(REAL-DESTINATION ERROR-DESTINATION)’,
        and ERROR-DESTINATION names a file, then the same remarks as for INFILE
        apply.

     5. The remaining arguments (ARGS) will be passed to the process verbatim.
        Emacs is not involved in processing file names that are present in
        ARGS.  To avoid confusion, it may be best to avoid absolute file names
        in ARGS, but rather to specify all file names as relative to
        ‘default-directory’.  The function ‘file-relative-name’ is useful for
        constructing such relative file names.  Alternatively, you can use
        ‘file-local-name’ (*note Magic File Names::) to obtain an absolute file
        name as seen from the remote host’s perspective.
#+end_defun
**** process-file-shell-command

#+findex:process-file-shell-command
This function is like ~call-process-shell-command~, but uses ~process-file~
internally.  Depending on ~default-directory~, COMMAND can be executed also on
remote hosts.

**** process-file-side-effects---a variable

#+attr_texinfo: :options process-file
#+begin_defvar
This variable indicates whether a call of ~process-file~ changes remote files.

By default, this variable is always set to ‘t’, meaning that a call of
~process-file~ could potentially change any file on a remote host.  When set to
‘nil’, a file handler could optimize its behavior with respect to remote file
attribute caching.  You should only ever change this variable with a
let-binding; never with ‘setq’.
#+end_defvar

*** Creating Asynchronous Subprocesses

#+cindex:asynchronous process
#+cindex:process, asynchronous
In this section, we describe how to create an “asynchronous process”.  After an
asynchronous process is created, it runs in parallel with Emacs, and Emacs can
communicate with it using the functions described in the following sections.

#+texinfo:@heading Controlling an Asynchronous Process

#+cindex:pty
#+cindex:pseudo-terminal
#+cindex:pipe
#+vindex:process-connection-type
An asynchronous process is controlled either via a “pty” (pseudo-terminal) or a
“pipe”.  The choice of pty or pipe is made when creating the process, by
default based on the value of the variable ‘process-connection-type’ (see
below).

#+texinfo:@subheading ptys

If available, ptys are usually preferable for processes visible to the user, as
in Shell mode, because they allow for job control (‘C-c’, ‘C-z’, etc.) between
the process and its children, and because interactive programs treat ptys as
terminal devices, whereas pipes don’t support these features.  The total number
of ptys is limited on many systems, and it is good not to waste them
unnecessarily.

#+texinfo:@subheading pipes

However, for subprocesses used by Lisp programs for internal purposes (i.e., no
user interaction with the subprocess is required), where significant amounts of
data need to be exchanged between the subprocess and the Lisp program, it is
often better to use a pipe, because pipes are more efficient.

**** make-process---a primitive

#+attr_texinfo: :options &rest args
#+begin_defun
This function is the basic low-level primitive for starting asynchronous
subprocesses.  It returns a process object representing the subprocess.

Compared to the more high-level ~start-process~, described below, it takes
keyword arguments, is more flexible, and allows to specify process filters and
sentinels in a single call.

- ARGS :: The arguments ARGS are a list of keyword/argument pairs.  Omitting a
  keyword is always equivalent to specifying it with value ‘nil’.  Here are the
  meaningful keywords:

  - :name NAME :: Use the string NAME as the process name; if a process with
    this name already exists, then NAME is modified (by appending ‘<1>’, etc.)
    to be unique.

  - :buffer BUFFER :: Use BUFFER as the process buffer.  If the value is ‘nil’,
    the subprocess is not associated with any buffer.

  - :command COMMAND :: Use COMMAND as the command line of the process.  The value
          should be a list starting with the program’s executable file
          name, followed by strings to give to the program as its
          arguments.  If the first element of the list is ‘nil’, Emacs
          opens a new pseudoterminal (pty) and associates its input and
          output with BUFFER, without actually running any program; the
          rest of the list elements are ignored in that case.

  - :coding CODING :: If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.  The coding system used for encoding the data written
          to the program is also used for encoding the command-line
          arguments (but not the program itself, whose file name is
          encoded as any other file name;

  - :connection-type TYPE :: Initialize the type of device used to communicate with the
          subprocess.  Possible values are ‘pty’ to use a pty, ‘pipe’ to
          use a pipe, or ‘nil’ to use the default derived from the value
          of the ‘process-connection-type’ variable.
          #+cindex:@{:stderr} parameter
          This parameter and the value of ‘process-connection-type’ are ignored
    if a non-‘nil’ value is specified for the ‘:stderr’ parameter; in that
    case, the type will always be ‘pipe’.

  - :noquery QUERY-FLAG :: Initialize the process query flag to QUERY-FLAG.

  - :stop STOPPED :: If STOPPED is non-‘nil’, start the process in the stopped
    state.

  - :filter FILTER :: Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be overridden
          later.

  - :sentinel SENTINEL :: Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          overridden later.
    #+cindex:@code{:stderr} keyword
  - :stderr STDERR :: Associate STDERR with the standard error of the process.  A
          non-‘nil’ value should be either a buffer or a pipe process
          created with ‘make-pipe-process’, described below.


#+findex:process-contact
The original argument list, modified with the actual connection information, is
available via the ~process-contact~ function.

#+vindex:default-directory
The current working directory of the subprocess is set to the current buffer’s
value of ‘default-directory’ if that is local (as determined by
‘unhandled-file-name-directory’), or "~" otherwise.  If you want to run a
process in a remote directory use ~start-file-process~.
#+end_defun

**** make-pipe-process

#+attr_texinfo: :options &rest args
#+begin_defun
This function creates a bidirectional pipe which can be attached to a child
process.  This is useful with the =:stderr= keyword of ~make-process~.  The
function returns a process object.

- ARGS :: The arguments ARGS are a list of keyword/argument pairs.  Omitting
     a keyword is always equivalent to specifying it with value ‘nil’.

     Here are the meaningful keywords:

  - :name NAME :: Use the string NAME as the process name.  As with
       ‘make-process’, it is modified if necessary to make it unique.

  - :buffer BUFFER :: Use BUFFER as the process buffer.

  - :coding CODING :: If CODING is a symbol, it specifies the coding system to be
          used for both reading and writing of data from and to the
          connection.  If CODING is a cons cell ‘(DECODING . ENCODING)’,
          then DECODING will be used for reading and ENCODING for
          writing.

          If CODING is ‘nil’, the default rules for finding the coding
          system will apply.

  - :noquery QUERY-FLAG :: Initialize the process query flag to QUERY-FLAG.

  - :stop STOPPED :: If STOPPED is non-‘nil’, start the process in the stopped
          state.  In the stopped state, a pipe process does not accept
          incoming data, but you can send outgoing data.  The stopped
          state is set by ‘stop-process’ and cleared by
          ‘continue-process’

  - :filter FILTER :: Initialize the process filter to FILTER.  If not specified, a
          default filter will be provided, which can be changed later.

  - :sentinel SENTINEL :: Initialize the process sentinel to SENTINEL.  If not
          specified, a default sentinel will be used, which can be
          changed later.


#+findex:process-contact
The original argument list, modified with the actual connection information, is
available via the ‘process-contact’ function.

#+end_defun

**** start-process

#+attr_texinfo: :options start-process name buffer-or-name program &rest args
#+begin_defun
This function is a higher-level wrapper around ‘make-process’, exposing an
interface that is similar to [[*call-process---a primitive][~call-process~]].  It creates a new asynchronous
subprocess and starts the specified PROGRAM running in it.  It returns a
process object that stands for the new subprocess in Lisp.

- NAME :: The argument NAME specifies the name
     for the process object; as with ‘make-process’, it is modified if
     necessary to make it unique.

- BUFFER-OR-NAME :: The buffer BUFFER-OR-NAME is the buffer to associate with
  the process.

- PROGRAM :: If PROGRAM is ‘nil’, Emacs opens a new pseudoterminal (pty) and
     associates its input and output with BUFFER-OR-NAME, without
     creating a subprocess.  In that case, the remaining arguments ARGS
     are ignored.

- ARGS :: The rest of ARGS are strings that specify command line arguments
     for the subprocess.
#+end_defun

**** start-file-process

#+attr_texinfo: :options start-file-process name buffer-or-name program &rest args
#+begin_defun
Like ‘start-process’, this function starts a new asynchronous subprocess
running PROGRAM in it, and returns its process object.

The difference from ‘start-process’ is that this function may invoke a file
handler based on the value of ‘default-directory’.  This handler ought to run
PROGRAM, perhaps on the local host, perhaps on a remote host that corresponds
to ‘default-directory’.  In the latter case, the local part of
‘default-directory’ becomes the working directory of the process.
#+end_defun

**** start-process-shell-command

#+attr_texinfo: :options start-process-shell-command name buffer-or-name command
#+begin_defun
This function is like ~start-process~, except that it uses a shell to execute
the specified COMMAND.

- COMMAND :: The argument COMMAND is a shell command string.


#+vindex:shell-file-name
The variable ~shell-file-name~ specifies which shell to use.

#+cindex:wildcards
#+findex:shell-quote-argument
The point of running a program through the shell, rather than directly with
~make-process~ or ~start-process~, is so that you can employ shell features
such as wildcards in the arguments.  It follows that if you include any
arbitrary user-specified arguments in the command, you should quote them with
[[*Specifying Shell Arguments][~shell-quote-argument~]] first, so that any special shell characters do _not_
have their special shell meanings.
#+end_defun

**** start-file-process-shell-command

#+attr_texinfo: :options start-file-process-shell-command name buffer-or-name command
#+begin_defun
This function is like ~start-process-shell-command~, but uses
~start-file-process~ internally.  Because of this, COMMAND can also be executed
on remote hosts, depending on ~default-directory~.
#+end_defun

**** process-connection-type---a variable

#+attr_texinfo: :options process-connection-type
#+begin_defvar
This variable controls the type of device used to communicate with asynchronous
subprocesses.  If it is non-‘nil’, then ptys are used, when available.
Otherwise, pipes are used.  The value of ‘process-connection-type’ takes effect
when ‘make-process’ or ‘start-process’ is called.  So you can specify how to
communicate with one subprocess by binding the variable around the call to
these functions.

#+cindex:@code{:stderr} parameter
Note that the value of this variable is ignored when ‘make-process’ is called
with a non-‘nil’ value of the ‘:stderr’ parameter; in that case, Emacs will
communicate with the process using pipes.  It is also ignored if ptys are
unavailable (MS-Windows).

#+findex:process-tty-name
To determine whether a given subprocess actually got a pipe or a pty, use the
function ~process-tty-name~.
#+end_defvar

* Debugging
:PROPERTIES:
:appendix: t
:END:

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Debugging.html#Debugging

- https://www.emacswiki.org/emacs/CategoryDebug

** Find Func

https://www.emacswiki.org/emacs/FindFunc

- find-func (=C-x F=) ::

     ~(find-function FUNCTION)~

     Finds the source file containing the definition of the function near point
     (selected by ‘function-called-at-point’) in a buffer and places point
     before the definition.  Set mark before moving, if the buffer already
     existed.

** Debugger Mode

- https://www.emacswiki.org/emacs/DebuggerMode


#+cindex:debugger mode
#+cindex:BacktraceBuffer
#+cindex:execution stack
/Debugger mode/ is the mode used in the BacktraceBuffer (buffer ‘*Backtrace*’).
It shows the “frames” of your execution stack.  A line starts with ‘*’ if
exiting that frame will call the debugger.

#+texinfo:@heading Debugger Keys

=C-h m= gives you information on the current mode.

#+attr_texinfo: :indic code
- b :: break point – place an asterisk (=*=) on a stack frame
- u :: remove break point
- c :: continue
- d :: single step
- j :: keep existing frames until you reach the current frame
- e :: eval another sexp that you input
- q :: quit


#+texinfo:@heading Entering debugger mode

- You can use ~M-x debug-on-entry~ to put breakpoints at the start of
  functions, and ~M-x cancel-debug-on-entry~ to remove them.

- You can put ~(debug)~ in EmacsLisp code at arbitrary points (and then eval
  that code) to put breakpoints at those places.

- You can set any of the following variables:
    #+attr_texinfo: :indic b
  - debug-on-quit ::

                     Debugger is entered when the user hits =C-g=.  This is
                     useful in debugging infinite loops and long delays.  You
                     can toggle this variable using ~M-x toggle-debug-on-quit~.

  - debug-on-error ::

                      Debugger is entered when an uncaught error happens.  This
                      is foiled by condition-case forms that catch errors.  You
                      can toggle this variable using =M-x
                      toggle-debug-on-error=.  Note that some errors are
                      ignored --- you may have to temporarily set
                      ~debug-ignored-errors~ to ‘nil’ in order to debug such
                      errors.

  - stack-trace-on-error ::

       An alternative to ~debug-on-error~.  It shows trace buffers instead of
       entering the debugger.  Example: ~(setq stack-trace-on-error
       '(buffer-read-only))~

** Edebug

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html]]

- https://www.emacswiki.org/emacs/SourceLevelDebugger


#+cindex:instrument
#+cindex:@command{edebug-defun} @code{C-u C-M-x}
#+findex:edebug-defun C-u C-M-x
#+findex:edebug-eval-top-level-form
#+findex:edebug-defun
#+vindex:edebug-all-defs
#+vindex:edebug-all-forms
~Edebug~ is a source level debugger for EmacsLisp.  It instruments code.  This
means that Emacs adds special instructions to the code when it is evaluated, to
invoke Edebug at the proper places.

- edebug-defun (=C-u C-M-x=) ::

     is the main entry point to Edebug.  Use it instead of =C-x C-e= or =C-M-x=
     to evaluate a =defun= and instrument it for debugging.  When you invoke
     command =C-u C-M-x= (~eval-defun~ with a prefix argument) on a function
     definition, it instruments the definition before evaluating it.


See the variables:
#+vindex:edebug-all-defs
#+vindex:edebug-all-forms
- ~edebug-all-defs~ and
- ~edebug-all-forms~


#+texinfo:@noindent to control how ~eval-defun~ operates.

See also the commands:
#+findex:eval-region
#+findex:eval-current-buffer
#+findex:eval-buffer:
- ~eval-region~
- ~eval-current-buffer~
- ~eval-buffer~
- ~edebug-eval-top-level-form~
- ~edebug-defun~ (an alias of ~edebug-eval-top-level-form~


~edebug-defun~ must be able to read your code.  It expects all function
definitions to start in column 0.  If they do not, hitting =C-u C-M-x= will
show you the wrong function name in the echo area.

#+texinfo:@heading Instrumented Source Code

#+cindex:execution mode, default
#+cindex:source code buffer
Once a function is instrumented, any call to the function activates Edebug.
The action that occurs depends on which /execution mode/ is active.  The
default execution mode is =step=, which stops execution.  You will be viewing a
read-only buffer of the source code that is being debugged (the /source code
buffer/).  An arrow in the left fringe indicates the line where the function is
executing.  The special commands of Edebug are available in the source code
buffer in addition to the commands of Emacs Lisp mode.

#+texinfo:@heading Stop Points

#+cindex:stop points
The places within a function where Edebug can stop execution are called “stop
points”.  These occur both before and after each subexpression that is a list,
and also after each variable reference.  When Edebug stops execution after an
expression, it displays the expression’s value in the echo area.

#+texinfo:@heading Commanly Used Edebug Commands

- SPC :: execute until the next stop point

- b :: set a breakpoint at a stop point

- g :: execute until a breakpoint is reached

- q :: exit Edebug

- ? :: display a l ist of all Edebug commands


#+texinfo:@heading Interrupt Edebug Execution

While executing or tracing, you can interrupt the execution by typing any
Edebug command.  Edebug stops the program at the next stop point and then
executes the command you typed.  For example, typing ‘t’ during execution
switches to trace mode at the next stop point.  You can use ‘S’ to stop
execution without doing anything else.

*** Features of Edebug
- Step through evaluation, stopping before and after each expression.

- Set conditional or unconditional breakpoints.

- Stop when a specified condition is true (the global break event).

- Trace slow or fast, stopping briefly at each stop point, or at each
  breakpoint.

- Display expression results and evaluate expressions as if outside of Edebug.

- Automatically re-evaluate a list of expressions and display their results
  each time Edebug updates the display.

- Output trace information on function calls and returns.

- Stop when an error occurs.

- Display a backtrace, omitting Edebug's own frames.

- Specify argument evaluation for macros and defining forms.

- Obtain rudimentary coverage testing and frequency counts.

*** Example of Edebug

Paste the following functions into the =*scratch*= buffer (starting at column
0).  Hit =C-M-x= with the cursor inside each of the function definitions.

#+name:foo-and-bar
#+begin_src elisp
  (defun foo ()
        (interactive)
        (bar))

  (defun bar ()
    (let ((a 5)
          (b 7))
      (message "%d" (+ a b))))
#+end_src

Use =M-x foo=.  This prints `12' in the echo area.

Now instrument ‘bar’ by moving the cursor into its code and hitting =C-u
C-M-x=.  The echo area shows =Edebug: bar=.

Use =M-x foo= again.  Emacs steps through the code of ‘bar’, showing you the
result of evaluating each sexp in the echo area.  Hit ‘SPC’ to step ahead or
‘e’ to evaluate another expression.  The arrow shows you which sexp will be
evaluated next:

#+begin_src elisp
  (defun bar ()
  =>(let ((a 5)
          (b 7))
      (message "%d" (+ a b))))
#+end_src

To quit the debugger, type ‘q’.

Edebug can enter any defun whose source can be found with [[*Find Func][FindFunc]] by hitting
‘i’ which steps into the next function to be evaluated.  This instruments the
function and will be debugged every time it is run.

You can disable edebug on a function by evaluating the function again using
=C-M-x= without a PrefixArgument.

You can see the code coverage of the defun at point with ~C-x X =~ or =M-x
edebug-display-freq-count=.

*** Instrumenting for Edebug

- https://www.gnu.org/software/emacs/manual/html_node/elisp/Instrumenting.html#Instrumenting


#+findex:edebug-instrument-callee
#+findex:edebug-step-in
#+attr_texinfo: :indic command
- I (edebug-instrument-callee) ::

     instruments the definition of the function or macro called by the list form
     after point.

- i (edebug-step-in) ::

     steps into the call after instrumenting the function


#+texinfo:@heading User-Defined Macros

#+cindex:user-defined macro, instrument
Edebug knows how to instrument all the standard special forms, ‘interactive’
forms with an expression argument, anonymous lambda expressions, and other
defining forms.  However, Edebug cannot determine on its own what a
user-defined macro will do with the arguments of a macro call, so you must
provide that information using Edebug specifications.  [[info:elisp#Edebug%20and%20Macros][Edebug and Macros]].

#+texinfo:@heading Syntax Errors

#+cindex:invalid-read-syntax error
If Edebug detects a syntax error while instrumenting, it leaves point at the
erroneous code and signals an =invalid-read-syntax= error.  One potential
reason for such a failure to instrument is that some macro definitions are not
yet known to Emacs.  To work around this, load the file which defines the
function you are about to instrument.

#+texinfo:@heading Remove Instrumentation

#+cindex:instrumenation, remove
To remove instrumentation from a definition, simply re-evaluate its definition
in a way that does not instrument.  There are two ways of evaluating forms that
never instrument them: from a file with ~load~, and from the minibuffer with
~eval-expression~ (=M-:=).

*** Edebug Execution Modes

#+cindex:execution modes
Edebug supports several execution modes for running the program you are
debugging, called /execution modes/.  The current Edebug execution mode
determines how far Edebug continues execution before stopping and how much
Edebug displays the progress of the evaluation before it stops.  Normally, you
specify the Edebug execution mode by typing a command to continue the program
in a certain mode.  All except for =S= resume execution of the program.  In
general, the execution modes earlier in the above list run the program more
slowly or stop sooner than the modes later in the list.

| Command | Mode           | Function                  | Effect                                                                   |
|---------+----------------+---------------------------+--------------------------------------------------------------------------|
| S       | Stop           | edebug-stop               | don’t execute any more of the program, but wait for more Edebug commands |
| SPC     | Step           | edebug-step-mode          | stop at the next stop point encountered                                  |
| n       | Next           | edebug-next-mode          | stop at the next stop point encountered after an expression              |
| t       | Trace          | edebug-trace-mode         | pause (normally one second) at each Edebug stop point                    |
| T       | Rapid Trace    | edebug-Trace-fast-mode    | update the display at each stop point, but don’t actually pause          |
| g       | Go             | edebug-go-mode            | See Breakpoints                                                          |
| c       | Continue       | edebug-continue-mode      | pause one second at each breakpoint, and then continue                   |
| C       | Rapid Continue | edebug-Continue-fast-mode | move point to each breakpoint, but don’t pause                           |
| G       | Go non-stop    | edebug-Go-nonstop-mode    | ignore breakpoints. Stop program with =S=, or editing command            |
|---------+----------------+---------------------------+--------------------------------------------------------------------------|

**** Set Initial Execution Mode

#+cindex:execution mode, initial
#+vindex:edebug-initial-mode
#+findex:edebug-set-initial-mode C-x C-a C-m
- ~edebug-initial-mode~ ::

     Default execution mode is =step=

     When you enter a new Edebug level, Edebug will normally stop at the first
     instrumented function it encounters (=Step=).

- edebug-set-initial-mode (=C-x C-a C-m=) ::

     If you prefer to stop only at a break point, or not at all (for example,
     when gathering coverage data), change the value of ‘edebug-initial-mode’
     from its default ‘step’ to ‘go’, or ‘Go-nonstop’, or one of its other
     values (*note Edebug Options).

**** Waiting Between Execution Steps

#+attr_texinfo: :indic code
- edebug-sit-for-seconds ::

     This option specifies how many seconds to wait between execution steps in
     trace mode or continue mode.  The default is 1 second.

*** Edebug Jumping

#+cindex:jump
The commands described in this section execute until they reach a specified
location.  All except ‘i’ make a temporary breakpoint to establish the place to
stop, then switch to go mode.  Any other breakpoint reached before the intended
stop point will also stop execution.

| Command | Function            | Description                                                    |
|---------+---------------------+----------------------------------------------------------------|
| h       | edebug-goto-here    | Proceed to the stop point near where point is                  |
| [N] f   | edebug-forward-sexp | Run the program for one [N] expression(s)                      |
| o       | edebug-step-out     | Run the program until the end of the containing sexp           |
| i       | edebug-step-in      | Step into the function or macro called by the form after point |
|---------+---------------------+----------------------------------------------------------------|

*** Miscellaneous Edebug Commands

| Command | Function                 | Description                                                          |
|---------+--------------------------+----------------------------------------------------------------------|
| C-]     | abort-recursive-edit     | Abort one level back to the previous command level                   |
| Q       | edebug-top-level-nonstop | Like ‘q’, but don’t stop even for protected code                     |
| r       | edebug-previous-result   | Redisplay the most recently known expression result in the echo area |
| d       | edebug-backtrace         | Display a backtrace, excluding Edebug’s own functions for clarity    |
|---------+--------------------------+----------------------------------------------------------------------|

*** Edebug Breaks
There are three other ways (other than stop points) to stop Edebug execution
once it has started:
#+cindex:breaks
- breakpoints,
- the global break condition, and
- source breakpoints.

**** Breakpoints
While using Edebug, you can specify “breakpoints” in the program you are
testing: these are places where execution should stop.  You can set a
breakpoint at any stop point, as defined in *note Using Edebug.  Re-evaluating
or reinstrumenting a definition removes all of its previous breakpoints.
Edebug always stops or pauses at a breakpoint, except when the Edebug mode is
Go-nonstop.  In that mode, it ignores breakpoints entirely.

To find out where your breakpoints are, use the ‘B’ command, which moves point
to the next breakpoint following point, within the same function, or to the
first breakpoint if there are no following breakpoints.  This command does not
continue execution---it just moves point in the buffer.

| Command | Function                          | Description                                                                                                  |
|---------+-----------------------------------+--------------------------------------------------------------------------------------------------------------|
| b       | edebug-set-breakpoint             | Set a breakpoint at the stop point at or after point                                                         |
| u       | edebug-unset-breakpoint           | Unset the breakpoint (if any) at the stop point at or after point                                            |
| x COND  | edebug-set-conditional-breakpoint | Set a conditional breakpoint which stops the program only if evaluating COND produces a non-‘nil’ value      |
| B       | edebug-next-breakpoint            | Move point to the next breakpoint in the current definition                                                  |
|---------+-----------------------------------+--------------------------------------------------------------------------------------------------------------|

#+texinfo:@heading Conditional Breakpoints

#+cindex:conditional breakpoint
#+cindex:breakpoint, conditional
A “conditional breakpoint” tests a condition each time the program gets there.
Any errors that occur as a result of evaluating the condition are ignored, as
if the result were ‘nil’.

To set a conditional breakpoint, use ‘x’, and specify the condition expression
in the minibuffer.  Setting a conditional breakpoint at a stop point that has a
previously established conditional breakpoint puts the previous condition
expression in the minibuffer so you can edit it.

#+texinfo:@subheading Making a Breakpoint Temporary

#+cindex:temporary breakpoint
You can make a conditional or unconditional breakpoint “temporary” by using a
prefix argument with the command to set the breakpoint.  When a temporary
breakpoint stops the program, it is automatically unset.

**** Global Break Condition

#+cindex:global break condition
#+cindex:break condition, global
A “global break condition” stops execution when a specified condition is
satisfied, no matter where that may occur.  Edebug evaluates the global break
condition at every stop point; if it evaluates to a non-‘nil’ value, then
execution stops or pauses depending on the execution mode, as if a breakpoint
had been hit.  If evaluating the condition gets an error, execution does not
stop.

The global break condition is the simplest way to find where in your code some
event occurs, but it makes code run much more slowly.  So you should reset the
condition to ‘nil’ when not using it.

#+attr_texinfo: :indic code
- edebug-global-break-condition ::

     The variable in which the condition expression is stored.

- edebug-set-global-break-condition ::

     You can specify a new expression using the ‘X’ command from the source
     code buffer while Edebug is active, or using ‘C-x X X’ from any buffer at
     any time, as long as Edebug is loaded

**** Source Breakpoints

#+cindex:source breakpoint
#+cindex:breakpoint, source
All breakpoints in a definition are forgotten each time you reinstrument it.
If you wish to make a breakpoint that won’t be forgotten, you can write a
“source breakpoint”, which is simply a call to the function ‘edebug’ in your
source code.  You can, of course, make such a call conditional.  If no
instrumented code is being executed when ‘edebug’ is called, that function
calls ‘debug’.

*** Edebug Views

#+cindex:outside window configuration
The outside window configuration is the collection of windows and contents that
were in effect outside of Edebug.

| Command | Function                  | Description                                                                       |
|---------+---------------------------+-----------------------------------------------------------------------------------|
| v       | edebug-view-outside       | Switch to viewing the outside window configuration                                |
| C-x X w |                           | return to Edebug                                                                  |
| p       | edebug-bounce-point       | Temporarily display the outside current buffer with point at its outside position |
| w       | edebug-where              | Move point back to the current stop point in the source code buffer               |
| W       | edebug-toggle-sae-windows | Toggle whether Edebug saves and restores the outside window configuration         |
| C-u W   |                           | Toggle saving and restoring of the selected window only                           |
|---------+---------------------------+-----------------------------------------------------------------------------------|

*** Edebug Evaluation

While within Edebug, you can evaluate expressions as if Edebug were not
running.

| Command | Function               | Description                                                            |
|---------+------------------------+------------------------------------------------------------------------|
| e EXP   | edebug-eval-expression | Evaluate expression EXP in the context outside of Edebug               |
| M-: EXP | eval-expression        | Evaluate expression EXP in the context of Edebug itself                |
| C-x C-e | edebut-eval-last-sexp  | Evaluate the expression before point, in the context outside of Edebug |
|---------+------------------------+------------------------------------------------------------------------|

*** Edebug Evaluation List Buffer

#+cindex:evaluation list buffer
#+cindex:@code{*edebug*} buffer
You can use the “evaluation list buffer”, called ‘*edebug*’, to evaluate
expressions interactively.  You can also set up the “evaluation list” of
expressions to be evaluated automatically each time Edebug updates the display.

You can evaluate expressions in the evaluation list window with ‘C-j’ or ‘C-x
C-e’, just as you would in ‘*scratch*’; but they are evaluated in the context
outside of Edebug.

The expressions you enter interactively (and their results) are lost when you
continue execution; but you can set up an “evaluation list” consisting of
expressions to be evaluated each time execution stops.

In the ‘*edebug*’ buffer you can use the commands of Lisp Interaction mode
(*note Lisp Interaction) as well as these special commands:

| Command | Function                    | Description                                                                                      |
|---------+-----------------------------+--------------------------------------------------------------------------------------------------|
| E       | edebug-visit-eval-list      | Switch to the evaluation list buffer ‘*edebug*’                                                  |
| C-j     | edebug-eval-print-last-sexp | Evaluate the expression before point, in the outside context, and insert the value in the buffer |
| C-x C-e | edebug-eval-last-sexp       | Evaluate the expression before point, in the context outside of Edebug                           |
| C-c C-u | edebug-update-eval-list     | Build a new evaluation list from the contents of the buffer                                      |
| C-c C-d | edebug-delete-eval-item     | Delete the evaluation list group that point is in                                                |
| C-c C-w | edebug-where                | Switch back to the source code buffer at the current stop point                                  |
|---------+-----------------------------+--------------------------------------------------------------------------------------------------|

*** Insert a Direct Call to Edebug

#+begin_src elisp
  (defmacro stop-here (fn)
         "Call edebug here. FN is assumed to be a symbol of the function you are in."
         `(if (consp (get ,fn 'edebug))
             (edebug)))

  (defun clear-edebug (fn-sym)
    "Remove 'edebug property from FN-SYM, a function symbol."
    (put fn-sym 'edebug nil))
#+end_src

#+begin_src elisp
   ;; An example of use:
  (defun fact (n)
    (cond ((= n 0) )
          ((= n 1) 1)
          ((>  n 1) (progn (stop-here 'fact) (* n (fact (1- n)))))
          (t nil)))
#+end_src

If you eval the above and then ~edebug-defun~ while the point is on =fact=,
you’ll first stop at =fact= but then when you enter ‘g’ for ‘go’ it will next
stop after the ~(* n… )~ which is what I want.

And note you could also put a condition around `stop-here` for example:

: ((>  n 1) (progn (if (= n 3) (stop-here 'fact)) (* n (fact (1- n)))))

*** Trace Buffer

https://www.gnu.org/software/emacs/manual/html_node/elisp/Trace-Buffer.html#Trace-Buffer

#+cindex:trace buffer
#+cindex:execution trace
#+cindex:trace recording
#+cindex:@code{*edebug-trace*}
Edebug can record an execution trace, storing it in a buffer named
=*edebug-trace*=.  This is a log of function calls and returns, showing the
function names and their arguments and values.

#+vindex:edebug-trace
- ~edebug-trace~ :: To enable trace recording, set ~edebug-trace~ to a non-nil
                    value.


Making a trace buffer is not the same thing as using =trace execution mode=
(see Edebug Execution Modes).

#+texinfo:@heading Trace Recording

When trace recording is enabled, each function entry and exit adds lines to the
trace buffer.  A function entry record consists of =::::{=, followed by the
function name and argument values.  A function exit record consists of =::::}=,
followed by the function name and result of the function.  The number of =:='s
in an entry shows its recursion depth.

** Debug Messages
:PROPERTIES:
:header-args: :eval no
:END:

- https://www.emacswiki.org/emacs/DebugMessages


Sometimes you want to find out where a particular error, warning or just plain
annoying message in Messages is coming from.

This piece of advice allows you to see the function call sequence that resulted
in each message in the Messages buffer:

#+begin_src elisp
  (defadvice message (before who-said-that activate)
      "Find out who said that thing. and say so."
      (let ((trace nil) (n 1) (frame nil))
        (while (setq frame (backtrace-frame n))
          (setq n     (1+ n) 
                trace (cons (cadr frame) trace)) )
        (ad-set-arg 0 (concat "<<%S>>:\n" (ad-get-arg 0)))
        (ad-set-args 1 (cons trace (ad-get-args 1))) ))
#+end_src

To deactivate this, call

#+begin_src elisp
  (ad-disable-advice 'message 'before 'who-said-that)
     (ad-update 'message)
#+end_src

To get timestamps:

#+begin_src elisp
  (defadvice message (before when-was-that activate)
      "Add timestamps to `message' output."
      (ad-set-arg 0 (concat (format-time-string "[%Y-%m-%d %T %Z] ") 
                            (ad-get-arg 0)) ))
#+end_src

And to deactivate this, call:

#+begin_src elisp
  (ad-disable-advice 'message 'before 'when-was-that)
      (ad-update 'message)
#+end_src

** Elisp Tracing

- https://www.emacswiki.org/emacs/EmacsLispTracing


#+texinfo:@heading Commands
#+cindex:trace
#+cindex:tracing

#+attr_texinfo: :indic b
- M-x trace-function

- M-x trace-function-background

- M-x untrace-function

- M-x untrace-all

** Elisp Benchmarking

- https://www.emacswiki.org/emacs/EmacsLispBenchmark


#+cindex:benchmark
#+cindex:benchmarking
Emacs comes with ~GIT:emacs-lisp/benchmark.el~ by DaveLove that can display the
elapsed time of running an EmacsLisp expression.  It observes the timing from
running a form once or repeatedly.  Any time spent by Emacs on
=GarbageCollection= is also determined.  These features are available
interactively with ~M-x benchmark~ or programmatically with ~benchmark-run~.

** Elisp Profiler

- https://www.emacswiki.org/emacs/EmacsLispProfiler


#+cindex:profiler
#+cindex:@code{elp.el}
Emacs comes with ~GIT:emacs-lisp/elp.el~ by Barry Warsaw that can display the
elapsed time of running an EmacsLisp function.  It is possible to instrument
more than one function, so it displays the results as a table in a buffer
called =*Elp Profiling Results*=.  It tracks the total timing for each call of
an instrumented function and determines the average time for each call.

** Emacs Native Profiler

https://www.emacswiki.org/emacs/EmacsNativeProfiler
#+cindex:native profiler
#+cindex:profiler library

The =profiler= library provides CPU & memory profiling for all Emacs functions.

Unlike =EmacsLispProfiler= you do not have to specify which functions or
packages you wish to profile (however ELP remains complementary as it records
overall time taken, which includes time spent waiting for external processes to
return, which is something that the native profiler will not report on).

** Elisp Logging

- https://www.emacswiki.org/emacs/Log4E_Logging_For_Elisp

- https://github.com/aki2o/log4e


~log4e.el~ provides a logging framework for Elisp.
* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Table Listings
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo: @listoffloats Table

* Concept Index
:PROPERTIES:
:INDEX:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:    vr
:unnumbered: t
:END:

* Program Index
:PROPERTIES:
:unnumbered: t
:index:    pg
:END:

* Footnotes

[fn:1]For example, Mac OS is case-insensitive by default, but can be configured
to be case-sensitive. 

* Build Tools
:PROPERTIES:
:appendix: t
:END:

** Makefile                                     :dependencies:env_vars:perl:
:PROPERTIES:
:appendix: t
:dependency1: "make"
:dependency2: "AWS Account with ~/.aws/credentials and ~/.aws/config"
:dependency3: "S3 bucket set up for serving a static web pages"
:dependency4: "GitHub Account with personal token"
:env_var1: ORG_TEMPLATE
:env_var2: EMACSLOADPATH
:env_var3: AWS_S3_BUCKET
:env_var4: GITHUB_TOKEN
:END:

#+name:Makefile
#+header: :tangle Makefile
#+header: :noweb tangle
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src makefile

  ###############################################################################
  ### USER-DEPENDENT VARIABLES
  ### USE ENVIRONMENT VARIABLES FOR SENSITIVE DATA
  ### ALL OTHERS CAN BE HARD-CODED
  ### YOU ALSO NEED ~/.aws/credentials

  EMACS   := /Applications/MacPorts/EmacsMac.app/Contents/MacOS/bin/emacs-26.3
  EMACS_D := $(HOME)/.emacs.d
  INIT_EL := init.el

  # The fully-qualified path to the Template file

  TEMPLATE := $(ORG_TEMPLATE)

  # User’s personal GitHub token for authentication
  # DO NOT HARD-CODE THIS VALUE

  TOKEN := $(GITHUB_TOKEN)

  # The AWS S3 bucket to use to store the html source files

  BUCKET := s3://$(AWS_S3_BUCKET)

  # The aws command to use (version 1 or version 2)

  AWS := aws2

  # The AWS region of choice; this can also be in .aws/config

  REGION := --region us-west-2

  ### END OF USER-DEPENDENT VARIABLES
  ###############################################################################

  ### ORG
  ### NOTE: there can be only one Org file in the directory;
  ### so far this has not been a problem, but it might be.

  PROJ := $(basename $(shell ls *.org))
  ORG   := $(PROJ).org

  # DIR is not necessarily the same as PROJ; it is the exported .info
  # name found at #+texinfo_filename:<DIR>.info without its extension,
  # used as the directory name for the html exports; use the lowercased
  # PROJ name if there is no texinfo_filename in the Org file 

  DIR := $(shell sed -nEe '/^[[:space:]]*\#\+(texinfo_filename|TEXINFO_FILENAME):(.*)\.info/ { s//\2/p; q; }' $(ORG))
  DIR ?= $(shell echo $(PROJ) | tr "[:upper:]" "[:lower:]")

  # VERS
  # The version number of this Org document.
  # If sync is run after the version number has been updated, then VERS
  # picks up the newly-changed value.  VERS used to be staticly imbedded
  # when the Makefile was tangled, but it needs to be dynamic for
  # development.

  VERS := $(shell sed -Ene '/^\#\+(macro|MACRO):version Version (([[:digit:]]+[[:punct:]]?){3})/ { s//v\2\//p; q; }' $(ORG))

  ### AWS
  # PROJ_LIST contains the list of projects currently uploaded to
  # the S3 bucket; each item contains the name of the project and its
  # current version.

  PROJ_LIST := $(strip $(filter-out PRE, $(shell $(AWS) s3 ls $(BUCKET))))

  # S3PROJ is the name of the current project as obtained from S3
  # S3VERS is the version of this project currently installed in the S3 bucket

  S3PROJ := $(filter $(DIR)%,$(PROJ_LIST))
  S3VERS := $(subst $(DIR)-,,$(filter $(DIR)%, $(PROJ_LIST)))

  ### GITHUB
  # USER is the current user's GitHub login name.

  # The user name used to be statically embedded into the Makefile
  # during tangle, but in an effort to make the Makefile dynamically
  # indepedent, dynamic code has replaced the static code.  The code
  # that placed the static name in the Makefile was a 'node' script that
  # ran in a separate Org process during tangle.  An unfortunate fact of
  # 'make' is that 'make' strips the quote marks from the string
  # obtained from the 'curl' command when the 'make shell' command
  # returns the string.  This makes the string malformed JSON and
  # unparsable by most JSON parsers, including 'node’.  However,
  # 'perl'’s core module JSON::PP (but not JSON::XS) has facilities to
  # parse very malformed JSON strings.  Therefore, this dynamic code
  # uses 'perl' and the core module JSON::PP to parse the 'curl' string
  # into a 'perl' JSON object which can return the login name.  This
  # code should work with any version of 'perl' without having to
  # install any modules.

  USER := $(shell \
		curl -sH "Authorization: token $(TOKEN)" https://api.github.com/user \
		| \
		perl -MJSON::PP -e \
		    '$$/ = ""; \
		     my $$json = JSON::PP->new->loose->allow_barekey->decode(<STDIN>); \
		     print $$json->{login};' \
		)

  ### TOOLS & RESOURCES
  TOOLS  := tools
  CMPRPL := $(TOOLS)/cmprpl
  SAVE   := resources

  ### TEXINFO
  TEXI  := $(PROJ).texi
  INFO  := $(DIR).info
  PDF   := $(PROJ).pdf
  INDEX := index.html
  HTML  := $(DIR)/$(INDEX)
  DIR_OLD := $(DIR)-old

  ### AWS
  S3     := $(AWS) s3
  SRC    := $(DIR)/

  DST_OLD := $(BUCKET)/$(S3PROJ)
  DST_NEW := $(BUCKET)/$(DIR)-$(VERS)
  EXCL_INCL := --exclude "*" --include "*.html"
  GRANTS  := --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  S3SYNC  := $(S3) sync $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
  S3MOVE  := $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)

  default: check texi info html pdf

  PHONY: check default all \
	  texi info html pdf \
	  open-org open-texi open-html open-pdf \
	  clean dist-clean wiped-clean \
	  help sync update values

  values: check
	  @echo USER:   	$(USER)
	  @echo PROJ:   	$(PROJ)
	  @echo VERS:   	$(VERS)
	  @echo S3PROJ: 	$(S3PROJ)
	  @echo S3VERS: 	$(S3VERS)
	  @echo DIR:    	$(DIR)
	  @echo DIR_OLD:	$(DIR_OLD)
	  @echo SRC:    	$(SRC)
	  @echo DST_OLD:	$(DST_OLD)
	  @echo DST_NEW:	$(DST_NEW)
	  @echo PROJ_LIST:$(PROJ_LIST)

  check:
	  @[[ -z $${AWS_S3_BUCKET} ]] && \
	     { printf "$${RED}\$$AWS_S3_BUCKET $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${GREEN}AWS_S3_BUCKET: $${CYAN}$${AWS_S3_BUCKET}$${CLEAR}\n";
	  @[[ -z $${GITHUB_TOKEN} ]] && \
	     { printf "$${RED}GITHUB_TOKEN $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${GREEN}GITHUB_TOKEN: set$${CLEAR}\n";
	  @[ -d ~/.aws -a -f ~/.aws/credentials -a -f ~/.aws/config ] && \
	     printf "$${GREEN}~/.aws credentials and config: set$${CLEAR}\n" || \
	     { printf "$${RED}~/.aws 'credentials' and 'config' must be set.$${CLEAR}\n"; exit 1; }
	  @$(EMACS) --batch --load="$(EMACS_D)/$(INIT_EL)" --eval '\
		  (progn \
			  (if \
				  (member (quote texinfo) org-export-backends) \
				  (princ "texinfo backend: INSTALLED in org-export-backends") \
				  (princ "texinfo backend: NOT INSTALLED in org-export-backends")) \
			  (terpri) \
			  (if \
				  org-confirm-babel-evaluate \
				  (princ "org-confirm-babel-evaluate: SET to t; consider setting to nil") \
				  (princ "org-confirm-babel-evaluate: SET to nil")) \
			  (terpri))'

  open-org: $(ORG)
	  emacsclient $(ORG) &
  $(ORG):
	  @echo 'THERE IS NO $(ORG) FILE!!!'
	  exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	  $(EMACS) --batch --eval '\
	  (progn \
	    (require (quote org)) \
	    (require (quote ob-shell)) \
	    (setq org-confirm-babel-evaluate nil) \
	    (find-file "$(ORG)") \
	    (org-texinfo-export-to-texinfo))'

  open-texi: texi
	  emacsclient $(TEXI) &

  info: $(INFO)
  $(INFO): $(TEXI)
	  makeinfo $(TEXI)
  open-info: info
	  emacsclient $(INFO)

  html: $(HTML)
  $(HTML): $(TEXI)
	  makeinfo --html $(TEXI)
	  $(CMPRPL) $(DIR) $(DIR_OLD)
  open-html: html
	  open $(HTML)

  pdf: $(PDF)
  $(PDF): $(TEXI)
	  pdftexi2dvi --quiet --build=clean $(TEXI)
  open-pdf: pdf
	  open $(PDF)

  sync: $(HTML)
	  $(S3SYNC)
	  [[ $(VERS) != $(S3VERS) ]] && { $(S3MOVE); make homepage; } || :

  homepage: $(ORG)
	  curl -i \
	       -H "Authorization: token $(TOKEN)" \
	       -H "Content-Type: application/json" \
	       -X PATCH \
	       -d '{"homepage":"https://$(AWS_S3_BUCKET)/$(DIR)-$(VERS)"}' \
	       https://api.github.com/repos/$(USER)/$(PROJ)

  update: $(ORG)
	  $(EMACS) -Q --batch --eval \
	  '(progn \
	     (require (quote org)) \
	     (require (quote ob)) \
	     (require (quote ob-shell)) \
	     (find-file "$(TEMPLATE)") \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-copy-subtree) \
	     (kill-buffer) \
	     (find-file "$(ORG)") \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-yank) \
	     (org-cut-subtree) \
	     (save-buffer) \
	     (kill-buffer) \
	     (setq org-confirm-babel-evaluate nil) \
	     (org-babel-tangle-file "$(ORG)"))'

  clean:
	  -rm *~

  dist-clean: clean
	  -rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)
	  -for dir in *; \
	   do \
		  [ -d $$dir -a $$dir != "$(DIR_OLD)" -a $$dir != $(SAVE) ] && \
		  rm -vr $$dir; \
	   done

  wipe-clean: dist-clean
	  -rm -rf Makefile Readme.md $(DIR_OLD)

  help:
	  @echo '"make default" makes the .texi file, the .info file, \
	  the html files, and the .pdf file.'
	  @echo

	  @echo '"make check" checks for prerequistes'
	  @echo '"make values" runs check and prints variable values'
	  @echo

	  @echo '"make sync" syncs the html files in the AWS S3 bucket BUCKET; \
	  you must have your AWS S3 bucket name in the env var AWS_S3_BUCKET; \
	  You must have your AWS credentials installed in ~/.aws/credentials'
	  @echo

	  @echo '"make texi" makes the .texi file'
	  @echo '"make info" makes the .info file'
	  @echo '"make html" makes the html distribution in a subdirectory'
	  @echo '"make pdf" makes the .pdf file'
	  @echo

	  @echo '"make open-org" opens the ORG program using emacsclient for editing'
	  @echo '"make open-texi" opens the .texi file using emacsclient for review'
	  @echo '"make open-html" opens the distribution index.html file \
	  in the default web browser'
	  @echo '"make open-pdf" opens the .pdf file'
	  @echo

	  @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	  @echo '"make clean-dist" cleans, removes the html distribution, \
	  and removes the build directory'

#+end_src

*** TODO Next
1. The CloudFront configuration needs to be updated recognize the new version
   directory that is created as part of the ~sync~ operation.

2. Update the GitHub HOME website link for each new sync operation.

3. Store on GitHub a version of each other format upon a sync operation (i.e.,
   the INFO and PDF versions)

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation.  This
is to make sure the ~cmprpl~ source code exists in the ~tools/~ directory
before running the Makefile target =html=.  It also makes sure there is a
Makefile on an initial export.  The following code is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The AWS ~sync~ command relies upon time stamps to determine whether two
programs are identical or not, as well as content.  If two otherwise identical
files have different time stamps, ~sync~ will assume they are different and
will process the newer.  However, the ~texinfo~ ~makeinfo --html~ command
produces all new files even if some files (or most files) remain unchanged.
This means that all files will be uploaded to the AWS S3 bucket on every
iteration, even though the majority of the files are actually unchanged.

The ~cmprpl~ source code attempts to resolve the issue of identical exported
code having different time stamps, thus defeating the benefit provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: =$DIR_NEW=.  If
it doesn’t, then it is in an improper state and the program stops with an error
message.

The program then checks if an old directory exists, =$DIR_OLD=.  If one
doesn’t, then one is created by copying the current new directory.  This
provides a baseline for comparisons going forward.  The program exits at that
point.  It is very important that the =$DIR_OLD= directory not be deleted going
forward.

Given that =$DIR_OLD= exists, the program then loops through all files in
=$DIR_NEW= and compares them to the files in =$DIR_OLD=.  If the files are
identical, the =$DIR_OLD= file replaces the =$DIR_NEW= file while retaining the
old time stamp (using the ~-p~ option of ~cp~.  If a file is different, then
the =$DIR_NEW= file replaces the =$DIR_OLD= file, thus giving it updated
content and an updated time stamp.  If the file does not exist in the
=$DIR_OLD= directory, then it is added.

The program then loops through all of the files in the old directory and deletes
any that do not exist in the new directory.  Now both directories should be in
sync.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  DIR_NEW=$1
  DIR_OLD=$2

  [[ -d $DIR_NEW ]] || { echo "ERROR: $DIR_NEW does not exist"; exit 1; }
  [[ -d $DIR_OLD ]] || { echo "CREATING: $DIR_OLD does not exist"; cp -a $DIR_NEW $DIR_OLD; exit 0; }

  for newfile in $DIR_NEW/*
  do
      oldfile=$DIR_OLD/$(basename $newfile)
      if [[ -e $oldfile ]]
      then
	 if cmp -s $newfile $oldfile
	 then
	     printf "${GREEN}copying OLD to NEW${CLEAR}: "
	     cp -vp $oldfile $newfile
	 else
	     printf "${PURPLE}copying NEW to OLD${CLEAR}: "
	     cp -vp $newfile $oldfile
	 fi
      else
	  printf "${BLUE}creating NEW in OLD${CLEAR}: "
	  cp -vp $newfile $oldfile
      fi
  done

  for oldfile in $DIR_OLD/*
  do
      newfile=$DIR_NEW/$(basename $oldfile)
      if [[ ! -e $newfile ]]
      then
	  printf "${RED}removing OLD${CLEAR}: "
	  rm -v $oldfile
      fi
  done
#+end_src


* Macro Definitions
#+macro: heading @@texinfo:@heading @@$1
#+macro: subheading @@texinfo:@subheading @@$1
#+macro: dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+macro: noindent @@texinfo:@noindent @@

* Export Setup                                                     :noexport:
#+texinfo_filename:mastering_emacs.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Emacs
#+texinfo_dir_title:Mastering
#+texinfo_dir_desc:notes about mastering Emacs
#+texinfo_printed_title:Mastering Emacs

* Options
#+options: H:4 toc:3

* Local Variables                                                  :noexport:
# Local variables:
# fill-column: 79
# electric-quote-local-mode: t
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
